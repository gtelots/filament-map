var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$5 = Symbol.for("react.element"), n$4 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$2 = {};
function E$3(a, b, e2) {
  this.props = a;
  this.context = b;
  this.refs = D$2;
  this.updater = e2 || B$3;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E$3.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$3.prototype;
function G$2(a, b, e2) {
  this.props = a;
  this.context = b;
  this.refs = D$2;
  this.updater = e2 || B$3;
}
var H$3 = G$2.prototype = new F$1();
H$3.constructor = G$2;
C$2(H$3, E$3.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$5 = { key: true, ref: true, __self: true, __source: true };
function M$3(a, b, e2) {
  var d, c = {}, k2 = null, h2 = null;
  if (null != b) for (d in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J$2.call(b, d) && !L$5.hasOwnProperty(d) && (c[d] = b[d]);
  var g2 = arguments.length - 2;
  if (1 === g2) c.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps) for (d in g2 = a.defaultProps, g2) void 0 === c[d] && (c[d] = g2[d]);
  return { $$typeof: l$5, type: a, key: k2, ref: h2, props: c, _owner: K$3.current };
}
function N$3(a, b) {
  return { $$typeof: l$5, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$3(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$5;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var P$3 = /\/+/g;
function Q$3(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R$3(a, b, e2, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h2 = false;
  if (null === a) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$5:
        case n$4:
          h2 = true;
      }
  }
  if (h2) return h2 = a, c = c(h2), a = "" === d ? "." + Q$3(h2, 0) : d, I$3(c) ? (e2 = "", null != a && (e2 = a.replace(P$3, "$&/") + "/"), R$3(c, b, e2, "", function(a2) {
    return a2;
  })) : null != c && (O$3(c) && (c = N$3(c, e2 + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$3, "$&/") + "/") + a)), b.push(c)), 1;
  h2 = 0;
  d = "" === d ? "." : d + ":";
  if (I$3(a)) for (var g2 = 0; g2 < a.length; g2++) {
    k2 = a[g2];
    var f2 = d + Q$3(k2, g2);
    h2 += R$3(k2, b, e2, f2, c);
  }
  else if (f2 = A$2(a), "function" === typeof f2) for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d + Q$3(k2, g2++), h2 += R$3(k2, b, e2, f2, c);
  else if ("object" === k2) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$3(a, b, e2) {
  if (null == a) return a;
  var d = [], c = 0;
  R$3(a, d, "", "", function(a2) {
    return b.call(e2, a2, c++);
  });
  return d;
}
function T$3(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
    }, function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$3 = { current: null }, V$3 = { transition: null }, W$3 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$3 };
function X$3() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$3, forEach: function(a, b, e2) {
  S$3(a, function() {
    b.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b = 0;
  S$3(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return S$3(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$3(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$3;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
react_production_min.act = X$3;
react_production_min.cloneElement = function(a, b, e2) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$2({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k2 = b.ref, h2 = K$3.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g2 = a.type.defaultProps;
    for (f2 in b) J$2.call(b, f2) && !L$5.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g2 ? g2[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d.children = g2;
  }
  return { $$typeof: l$5, type: a.type, key: c, ref: k2, props: d, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u$4, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$4, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a) {
  var b = M$3.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$3, render: a };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a }, _init: T$3 };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: x$2, type: a, compare: void 0 === b ? null : b };
};
react_production_min.startTransition = function(a) {
  var b = V$3.transition;
  V$3.transition = {};
  try {
    a();
  } finally {
    V$3.transition = b;
  }
};
react_production_min.unstable_act = X$3;
react_production_min.useCallback = function(a, b) {
  return U$3.current.useCallback(a, b);
};
react_production_min.useContext = function(a) {
  return U$3.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$3.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b) {
  return U$3.current.useEffect(a, b);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a, b, e2) {
  return U$3.current.useImperativeHandle(a, b, e2);
};
react_production_min.useInsertionEffect = function(a, b) {
  return U$3.current.useInsertionEffect(a, b);
};
react_production_min.useLayoutEffect = function(a, b) {
  return U$3.current.useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return U$3.current.useMemo(a, b);
};
react_production_min.useReducer = function(a, b, e2) {
  return U$3.current.useReducer(a, b, e2);
};
react_production_min.useRef = function(a) {
  return U$3.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$3.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b, e2) {
  return U$3.current.useSyncExternalStore(a, b, e2);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const ReactExports = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports, k$2 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$3 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q$2(c, a, g2) {
  var b, d = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b in a) m$2.call(a, b) && !p$5.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: k$2, type: c, key: e2, ref: h2, props: d, _owner: n$3.current };
}
reactJsxRuntime_production_min.Fragment = l$4;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b) {
    var c = a.length;
    a.push(b);
    a: for (; 0 < c; ) {
      var d = c - 1 >>> 1, e2 = a[d];
      if (0 < g2(e2, b)) a[d] = b, a[c] = e2, c = d;
      else break a;
    }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b = a[0], c = a.pop();
    if (c !== b) {
      a[0] = c;
      a: for (var d = 0, e2 = a.length, w2 = e2 >>> 1; d < w2; ) {
        var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
        if (0 > g2(C2, c)) n2 < e2 && 0 > g2(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
        else if (n2 < e2 && 0 > g2(x2, c)) a[d] = x2, a[n2] = c, d = n2;
        else break a;
      }
    }
    return b;
  }
  function g2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b = h2(t2); null !== b; ) {
      if (null === b.callback) k2(t2);
      else if (b.startTime <= a) k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
      else break;
      b = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b = h2(t2);
      null !== b && K2(H2, b.startTime - a);
    }
  }
  function J2(a, b) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
        var d = v2.callback;
        if ("function" === typeof d) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d(v2.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b = true;
      try {
        b = O2(true, a);
      } finally {
        b ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = y2;
    }
    var c = y2;
    y2 = b;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c + e2;
    a = { id: u2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e2, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b = y2;
    return function() {
      var c = y2;
      y2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$2 = reactExports, ca$1 = schedulerExports;
function p$4(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da$1 = /* @__PURE__ */ new Set(), ea$1 = {};
function fa$2(a, b) {
  ha$2(a, b);
  ha$2(a + "Capture", b);
}
function ha$2(a, b) {
  ea$1[a] = b;
  for (a = 0; a < b.length; a++) da$1.add(b[a]);
}
var ia$2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja$2 = Object.prototype.hasOwnProperty, ka$2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la$2 = {}, ma$1 = {};
function oa$2(a) {
  if (ja$2.call(ma$1, a)) return true;
  if (ja$2.call(la$2, a)) return false;
  if (ka$2.test(a)) return ma$1[a] = true;
  la$2[a] = true;
  return false;
}
function pa$2(a, b, c, d) {
  if (null !== c && 0 === c.type) return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d) return false;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa$2(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa$2(a, b, c, d)) return true;
  if (d) return false;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;
    case 4:
      return false === b;
    case 5:
      return isNaN(b);
    case 6:
      return isNaN(b) || 1 > b;
  }
  return false;
}
function v$2(a, b, c, d, e2, f2, g2) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$2(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  z$1[b] = new v$2(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$2(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$2(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$2(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$2(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$2(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$2(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$2(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra$2 = /[\-:]([a-z])/g;
function sa$2(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ra$2,
    sa$2
  );
  z$1[b] = new v$2(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ra$2, sa$2);
  z$1[b] = new v$2(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ra$2, sa$2);
  z$1[b] = new v$2(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta$2(a, b, c, d) {
  var e2 = z$1.hasOwnProperty(b) ? z$1[b] : null;
  if (null !== e2 ? 0 !== e2.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa$2(b, c, e2, d) && (c = null), d || null === e2 ? oa$2(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e2.mustUseProperty ? a[e2.propertyName] = null === c ? 3 === e2.type ? false : "" : c : (b = e2.attributeName, d = e2.attributeNamespace, null === c ? a.removeAttribute(b) : (e2 = e2.type, c = 3 === e2 || 4 === e2 && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}
var ua$2 = aa$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va$2 = Symbol.for("react.element"), wa$2 = Symbol.for("react.portal"), ya$2 = Symbol.for("react.fragment"), za$2 = Symbol.for("react.strict_mode"), Aa$2 = Symbol.for("react.profiler"), Ba$2 = Symbol.for("react.provider"), Ca$2 = Symbol.for("react.context"), Da$2 = Symbol.for("react.forward_ref"), Ea$2 = Symbol.for("react.suspense"), Fa$2 = Symbol.for("react.suspense_list"), Ga$2 = Symbol.for("react.memo"), Ha$2 = Symbol.for("react.lazy");
var Ia$2 = Symbol.for("react.offscreen");
var Ja$2 = Symbol.iterator;
function Ka$2(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja$2 && a[Ja$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$1 = Object.assign, La$2;
function Ma$2(a) {
  if (void 0 === La$2) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    La$2 = b && b[1] || "";
  }
  return "\n" + La$2 + a;
}
var Na$2 = false;
function Oa$2(a, b) {
  if (!a || Na$2) return "";
  Na$2 = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b) if (b = function() {
      throw Error();
    }, Object.defineProperty(b.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b, []);
      } catch (l2) {
        var d = l2;
      }
      Reflect.construct(a, [], b);
    } else {
      try {
        b.call();
      } catch (l2) {
        d = l2;
      }
      a.call(b.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na$2 = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma$2(a) : "";
}
function Pa$2(a) {
  switch (a.tag) {
    case 5:
      return Ma$2(a.type);
    case 16:
      return Ma$2("Lazy");
    case 13:
      return Ma$2("Suspense");
    case 19:
      return Ma$2("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa$2(a.type, false), a;
    case 11:
      return a = Oa$2(a.type.render, false), a;
    case 1:
      return a = Oa$2(a.type, true), a;
    default:
      return "";
  }
}
function Qa$2(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya$2:
      return "Fragment";
    case wa$2:
      return "Portal";
    case Aa$2:
      return "Profiler";
    case za$2:
      return "StrictMode";
    case Ea$2:
      return "Suspense";
    case Fa$2:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca$2:
      return (a.displayName || "Context") + ".Consumer";
    case Ba$2:
      return (a._context.displayName || "Context") + ".Provider";
    case Da$2:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga$2:
      return b = a.displayName || null, null !== b ? b : Qa$2(a.type) || "Memo";
    case Ha$2:
      b = a._payload;
      a = a._init;
      try {
        return Qa$2(a(b));
      } catch (c) {
      }
  }
  return null;
}
function Ra$2(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa$2(b);
    case 8:
      return b === za$2 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b) return b.displayName || b.name || null;
      if ("string" === typeof b) return b;
  }
  return null;
}
function Sa$2(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta$2(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua$2(a) {
  var b = Ta$2(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e2 = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va$2(a) {
  a._valueTracker || (a._valueTracker = Ua$2(a));
}
function Wa$2(a) {
  if (!a) return false;
  var b = a._valueTracker;
  if (!b) return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta$2(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa$2(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya$2(a, b) {
  var c = b.checked;
  return A$1({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za$2(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa$2(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function ab$2(a, b) {
  b = b.checked;
  null != b && ta$2(a, "checked", b, false);
}
function bb$2(a, b) {
  ab$2(a, b);
  var c = Sa$2(b.value), d = b.type;
  if (null != c) if ("number" === d) {
    if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
  } else a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb$2(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb$2(a, b.type, Sa$2(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db$2(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb$2(a, b, c) {
  if ("number" !== b || Xa$2(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb$2 = Array.isArray;
function fb$2(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e2 = 0; e2 < c.length; e2++) b["$" + c[e2]] = true;
    for (c = 0; c < a.length; c++) e2 = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e2 && (a[c].selected = e2), e2 && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa$2(c);
    b = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c) {
        a[e2].selected = true;
        d && (a[e2].defaultSelected = true);
        return;
      }
      null !== b || a[e2].disabled || (b = a[e2]);
    }
    null !== b && (b.selected = true);
  }
}
function gb$2(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(p$4(91));
  return A$1({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb$2(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b) throw Error(p$4(92));
      if (eb$2(c)) {
        if (1 < c.length) throw Error(p$4(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa$2(c) };
}
function ib$2(a, b) {
  var c = Sa$2(b.value), d = Sa$2(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb$2(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb$2(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb$2(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb$2(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb$1, nb$1 = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e2);
    });
  } : a;
}(function(a, b) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
  else {
    mb$1 = mb$1 || document.createElement("div");
    mb$1.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = mb$1.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b.firstChild; ) a.appendChild(b.firstChild);
  }
});
function ob$2(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb$2 = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb$2 = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb$2).forEach(function(a) {
  qb$2.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb$2[b] = pb$2[a];
  });
});
function rb$2(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb$2.hasOwnProperty(a) && pb$2[a] ? ("" + b).trim() : b + "px";
}
function sb$2(a, b) {
  a = a.style;
  for (var c in b) if (b.hasOwnProperty(c)) {
    var d = 0 === c.indexOf("--"), e2 = rb$2(c, b[c], d);
    "float" === c && (c = "cssFloat");
    d ? a.setProperty(c, e2) : a[c] = e2;
  }
}
var tb$2 = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub$2(a, b) {
  if (b) {
    if (tb$2[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p$4(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(p$4(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p$4(61));
    }
    if (null != b.style && "object" !== typeof b.style) throw Error(p$4(62));
  }
}
function vb$2(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb$2 = null;
function xb$2(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb$2 = null, zb$2 = null, Ab$2 = null;
function Bb$2(a) {
  if (a = Cb$2(a)) {
    if ("function" !== typeof yb$2) throw Error(p$4(280));
    var b = a.stateNode;
    b && (b = Db$2(b), yb$2(a.stateNode, a.type, b));
  }
}
function Eb$2(a) {
  zb$2 ? Ab$2 ? Ab$2.push(a) : Ab$2 = [a] : zb$2 = a;
}
function Fb$1() {
  if (zb$2) {
    var a = zb$2, b = Ab$2;
    Ab$2 = zb$2 = null;
    Bb$2(a);
    if (b) for (a = 0; a < b.length; a++) Bb$2(b[a]);
  }
}
function Gb$2(a, b) {
  return a(b);
}
function Hb$2() {
}
var Ib$2 = false;
function Jb$2(a, b, c) {
  if (Ib$2) return a(b, c);
  Ib$2 = true;
  try {
    return Gb$2(a, b, c);
  } finally {
    if (Ib$2 = false, null !== zb$2 || null !== Ab$2) Hb$2(), Fb$1();
  }
}
function Kb$2(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db$2(c);
  if (null === d) return null;
  c = d[b];
  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c && "function" !== typeof c) throw Error(p$4(231, b, typeof c));
  return c;
}
var Lb$2 = false;
if (ia$2) try {
  var Mb$2 = {};
  Object.defineProperty(Mb$2, "passive", { get: function() {
    Lb$2 = true;
  } });
  window.addEventListener("test", Mb$2, Mb$2);
  window.removeEventListener("test", Mb$2, Mb$2);
} catch (a) {
  Lb$2 = false;
}
function Nb$2(a, b, c, d, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob$2 = false, Pb$2 = null, Qb$2 = false, Rb$2 = null, Sb$2 = { onError: function(a) {
  Ob$2 = true;
  Pb$2 = a;
} };
function Tb$2(a, b, c, d, e2, f2, g2, h2, k2) {
  Ob$2 = false;
  Pb$2 = null;
  Nb$2.apply(Sb$2, arguments);
}
function Ub$1(a, b, c, d, e2, f2, g2, h2, k2) {
  Tb$2.apply(this, arguments);
  if (Ob$2) {
    if (Ob$2) {
      var l2 = Pb$2;
      Ob$2 = false;
      Pb$2 = null;
    } else throw Error(p$4(198));
    Qb$2 || (Qb$2 = true, Rb$2 = l2);
  }
}
function Vb$1(a) {
  var b = a, c = a;
  if (a.alternate) for (; b.return; ) b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb$1(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }
  return null;
}
function Xb$1(a) {
  if (Vb$1(a) !== a) throw Error(p$4(188));
}
function Yb$1(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb$1(a);
    if (null === b) throw Error(p$4(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e2 = c.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d = e2.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c) return Xb$1(e2), a;
        if (f2 === d) return Xb$1(e2), b;
        f2 = f2.sibling;
      }
      throw Error(p$4(188));
    }
    if (c.return !== d.return) c = e2, d = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c) {
          g2 = true;
          c = e2;
          d = f2;
          break;
        }
        if (h2 === d) {
          g2 = true;
          d = e2;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g2 = true;
            c = f2;
            d = e2;
            break;
          }
          if (h2 === d) {
            g2 = true;
            d = f2;
            c = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$4(189));
      }
    }
    if (c.alternate !== d) throw Error(p$4(190));
  }
  if (3 !== c.tag) throw Error(p$4(188));
  return c.stateNode.current === c ? a : b;
}
function Zb$1(a) {
  a = Yb$1(a);
  return null !== a ? $b$1(a) : null;
}
function $b$1(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b = $b$1(a);
    if (null !== b) return b;
    a = a.sibling;
  }
  return null;
}
var ac$1 = ca$1.unstable_scheduleCallback, bc$1 = ca$1.unstable_cancelCallback, cc$1 = ca$1.unstable_shouldYield, dc$1 = ca$1.unstable_requestPaint, B$2 = ca$1.unstable_now, ec$1 = ca$1.unstable_getCurrentPriorityLevel, fc$1 = ca$1.unstable_ImmediatePriority, gc$1 = ca$1.unstable_UserBlockingPriority, hc$1 = ca$1.unstable_NormalPriority, ic$1 = ca$1.unstable_LowPriority, jc$1 = ca$1.unstable_IdlePriority, kc$1 = null, lc$1 = null;
function mc$1(a) {
  if (lc$1 && "function" === typeof lc$1.onCommitFiberRoot) try {
    lc$1.onCommitFiberRoot(kc$1, a, void 0, 128 === (a.current.flags & 128));
  } catch (b) {
  }
}
var oc$1 = Math.clz32 ? Math.clz32 : nc$1, pc$1 = Math.log, qc$1 = Math.LN2;
function nc$1(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc$1(a) / qc$1 | 0) | 0;
}
var rc$1 = 64, sc$1 = 4194304;
function tc$1(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc$1(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return 0;
  var d = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d = tc$1(h2) : (f2 &= g2, 0 !== f2 && (d = tc$1(f2)));
  } else g2 = c & ~e2, 0 !== g2 ? d = tc$1(g2) : 0 !== f2 && (d = tc$1(f2));
  if (0 === d) return 0;
  if (0 !== b && b !== d && 0 === (b & e2) && (e2 = d & -d, f2 = b & -b, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc$1(b), e2 = 1 << c, d |= a[c], b &= ~e2;
  return d;
}
function vc$1(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc$1(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc$1(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c) || 0 !== (h2 & d)) e2[g2] = vc$1(h2, b);
    } else k2 <= b && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc$1(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc$1() {
  var a = rc$1;
  rc$1 <<= 1;
  0 === (rc$1 & 4194240) && (rc$1 = 64);
  return a;
}
function zc$1(a) {
  for (var b = [], c = 0; 31 > c; c++) b.push(a);
  return b;
}
function Ac$1(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc$1(b);
  a[b] = c;
}
function Bc$1(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e2 = 31 - oc$1(c), f2 = 1 << e2;
    b[e2] = 0;
    d[e2] = -1;
    a[e2] = -1;
    c &= ~f2;
  }
}
function Cc$1(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c; ) {
    var d = 31 - oc$1(c), e2 = 1 << d;
    e2 & b | a[d] & b && (a[d] |= b);
    c &= ~e2;
  }
}
var C$1 = 0;
function Dc$1(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec$1, Fc$1, Gc$1, Hc$1, Ic$1, Jc$1 = false, Kc$1 = [], Lc$1 = null, Mc$1 = null, Nc$1 = null, Oc$1 = /* @__PURE__ */ new Map(), Pc$1 = /* @__PURE__ */ new Map(), Qc$1 = [], Rc$1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc$1(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc$1 = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc$1 = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc$1 = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc$1.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc$1.delete(b.pointerId);
  }
}
function Tc$1(a, b, c, d, e2, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e2] }, null !== b && (b = Cb$2(b), null !== b && Fc$1(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e2 && -1 === b.indexOf(e2) && b.push(e2);
  return a;
}
function Uc$1(a, b, c, d, e2) {
  switch (b) {
    case "focusin":
      return Lc$1 = Tc$1(Lc$1, a, b, c, d, e2), true;
    case "dragenter":
      return Mc$1 = Tc$1(Mc$1, a, b, c, d, e2), true;
    case "mouseover":
      return Nc$1 = Tc$1(Nc$1, a, b, c, d, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc$1.set(f2, Tc$1(Oc$1.get(f2) || null, a, b, c, d, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc$1.set(f2, Tc$1(Pc$1.get(f2) || null, a, b, c, d, e2)), true;
  }
  return false;
}
function Vc$1(a) {
  var b = Wc$1(a.target);
  if (null !== b) {
    var c = Vb$1(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = Wb$1(c), null !== b) {
          a.blockedOn = b;
          Ic$1(a.priority, function() {
            Gc$1(c);
          });
          return;
        }
      } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc$1(a) {
  if (null !== a.blockedOn) return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = Yc$1(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb$2 = d;
      c.target.dispatchEvent(d);
      wb$2 = null;
    } else return b = Cb$2(c), null !== b && Fc$1(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function Zc$1(a, b, c) {
  Xc$1(a) && c.delete(b);
}
function $c$1() {
  Jc$1 = false;
  null !== Lc$1 && Xc$1(Lc$1) && (Lc$1 = null);
  null !== Mc$1 && Xc$1(Mc$1) && (Mc$1 = null);
  null !== Nc$1 && Xc$1(Nc$1) && (Nc$1 = null);
  Oc$1.forEach(Zc$1);
  Pc$1.forEach(Zc$1);
}
function ad$1(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc$1 || (Jc$1 = true, ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority, $c$1)));
}
function bd$1(a) {
  function b(b2) {
    return ad$1(b2, a);
  }
  if (0 < Kc$1.length) {
    ad$1(Kc$1[0], a);
    for (var c = 1; c < Kc$1.length; c++) {
      var d = Kc$1[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc$1 && ad$1(Lc$1, a);
  null !== Mc$1 && ad$1(Mc$1, a);
  null !== Nc$1 && ad$1(Nc$1, a);
  Oc$1.forEach(b);
  Pc$1.forEach(b);
  for (c = 0; c < Qc$1.length; c++) d = Qc$1[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc$1.length && (c = Qc$1[0], null === c.blockedOn); ) Vc$1(c), null === c.blockedOn && Qc$1.shift();
}
var cd$1 = ua$2.ReactCurrentBatchConfig, dd$1 = true;
function ed$1(a, b, c, d) {
  var e2 = C$1, f2 = cd$1.transition;
  cd$1.transition = null;
  try {
    C$1 = 1, fd$1(a, b, c, d);
  } finally {
    C$1 = e2, cd$1.transition = f2;
  }
}
function gd$1(a, b, c, d) {
  var e2 = C$1, f2 = cd$1.transition;
  cd$1.transition = null;
  try {
    C$1 = 4, fd$1(a, b, c, d);
  } finally {
    C$1 = e2, cd$1.transition = f2;
  }
}
function fd$1(a, b, c, d) {
  if (dd$1) {
    var e2 = Yc$1(a, b, c, d);
    if (null === e2) hd$1(a, b, d, id$1, c), Sc$1(a, d);
    else if (Uc$1(e2, a, b, c, d)) d.stopPropagation();
    else if (Sc$1(a, d), b & 4 && -1 < Rc$1.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb$2(e2);
        null !== f2 && Ec$1(f2);
        f2 = Yc$1(a, b, c, d);
        null === f2 && hd$1(a, b, d, id$1, c);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d.stopPropagation();
    } else hd$1(a, b, d, null, c);
  }
}
var id$1 = null;
function Yc$1(a, b, c, d) {
  id$1 = null;
  a = xb$2(d);
  a = Wc$1(a);
  if (null !== a) if (b = Vb$1(a), null === b) a = null;
  else if (c = b.tag, 13 === c) {
    a = Wb$1(b);
    if (null !== a) return a;
    a = null;
  } else if (3 === c) {
    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
    a = null;
  } else b !== a && (a = null);
  id$1 = a;
  return null;
}
function jd$1(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc$1:
          return 1;
        case gc$1:
          return 4;
        case hc$1:
        case ic$1:
          return 16;
        case jc$1:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd$1 = null, ld$1 = null, md = null;
function nd() {
  if (md) return md;
  var a, b = ld$1, c = b.length, d, e2 = "value" in kd$1 ? kd$1.value : kd$1.textContent, f2 = e2.length;
  for (a = 0; a < c && b[a] === e2[a]; a++) ;
  var g2 = c - a;
  for (d = 1; d <= g2 && b[c - d] === e2[f2 - d]; d++) ;
  return md = e2.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e2, f2, g2) {
    this._reactName = b2;
    this._targetInst = e2;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b) return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia$2 && "CompositionEvent" in window, be = null;
ia$2 && "documentMode" in document && (be = document.documentMode);
var ce = ia$2 && "TextEvent" in window && !be, de = ia$2 && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld$1 = kd$1 = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb$2(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa$2(b)) return a;
}
function ve(a, b) {
  if ("change" === a) return b;
}
var we = false;
if (ia$2) {
  var xe;
  if (ia$2) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb$2(a));
    Jb$2(re, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b) {
  if ("click" === a) return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length) return false;
  for (d = 0; d < c.length; d++) {
    var e2 = c[d];
    if (!ja$2.call(b, e2) || !He(a[e2], b[e2])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Me() {
  for (var a = window, b = Xa$2(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c) a = b.contentWindow;
    else break;
    b = Xa$2(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(), c = a.focusedElem, d = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) {
      if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c.textContent.length, f2 = Math.min(d.start, e2);
        d = void 0 === d.end ? f2 : Math.min(d.end, e2);
        !a.extend && f2 > d && (e2 = d, d = f2, f2 = e2);
        e2 = Ke(c, f2);
        var g2 = Ke(
          c,
          d
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b = b.createRange(), b.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g2.node, g2.offset)) : (b.setEnd(g2.node, g2.offset), a.addRange(b)));
      }
    }
    b = [];
    for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia$2 && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa$2(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia$2 && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b = We[a], c;
  for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa$2(b, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha$2("onMouseEnter", ["mouseout", "mouseover"]);
ha$2("onMouseLeave", ["mouseout", "mouseover"]);
ha$2("onPointerEnter", ["pointerout", "pointerover"]);
ha$2("onPointerLeave", ["pointerout", "pointerover"]);
fa$2("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa$2("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa$2("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa$2("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa$2("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa$2("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub$1(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e2 = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b) for (var g2 = d.length - 1; 0 <= g2; g2--) {
        var h2 = d[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d.length; g2++) {
        h2 = d[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb$2) throw a = Rb$2, Qb$2 = false, Rb$2 = null, a;
}
function D$1(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, false), c.add(d));
}
function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da$1.forEach(function(b2) {
      "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
  }
}
function pf(a, b, c, d) {
  switch (jd$1(b)) {
    case 1:
      var e2 = ed$1;
      break;
    case 4:
      e2 = gd$1;
      break;
    default:
      e2 = fd$1;
  }
  c = e2.bind(null, b, c, a);
  e2 = void 0;
  !Lb$2 || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e2 = true);
  d ? void 0 !== e2 ? a.addEventListener(b, c, { capture: true, passive: e2 }) : a.addEventListener(b, c, true) : void 0 !== e2 ? a.addEventListener(b, c, { passive: e2 }) : a.addEventListener(b, c, false);
}
function hd$1(a, b, c, d, e2) {
  var f2 = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
    if (null === d) return;
    var g2 = d.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc$1(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d = d.return;
  }
  Jb$2(function() {
    var d2 = f2, e3 = xb$2(c), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d2, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb$2(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c !== wb$2 && (n2 = c.relatedTarget || c.fromElement) && (Wc$1(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc$1(n2) : null, null !== n2 && (J2 = Vb$1(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d2;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc$1(e3) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d2 ? ue(d2) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na2 = ve;
        else if (me(h3)) if (we) na2 = Fe;
        else {
          na2 = De;
          var xa2 = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na2 = Ee);
        if (na2 && (na2 = na2(a, d2))) {
          ne(g3, na2, c, e3);
          break a;
        }
        xa2 && xa2(a, h3, d2);
        "focusout" === a && (xa2 = h3._wrapperState) && xa2.controlled && "number" === h3.type && cb$2(h3, "number", h3.value);
      }
      xa2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(xa2) || "true" === xa2.contentEditable) Qe = xa2, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c, e3);
      }
      var $a2;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba2 = "onCompositionStart";
            break b;
          case "compositionend":
            ba2 = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba2 = "onCompositionUpdate";
            break b;
        }
        ba2 = void 0;
      }
      else ie ? ge(a, c) && (ba2 = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba2 = "onCompositionStart");
      ba2 && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie && ($a2 = nd()) : (kd$1 = e3, ld$1 = "value" in kd$1 ? kd$1.value : kd$1.textContent, ie = true)), xa2 = oe(d2, ba2), 0 < xa2.length && (ba2 = new Ld(ba2, a, null, c, e3), g3.push({ event: ba2, listeners: xa2 }), $a2 ? ba2.data = $a2 : ($a2 = he(c), null !== $a2 && (ba2.data = $a2))));
      if ($a2 = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c, e3), g3.push({ event: e3, listeners: d2 }), e3.data = $a2);
    }
    se(g3, b);
  });
}
function tf(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb$2(a, c), null != f2 && d.unshift(tf(a, f2, e2)), f2 = Kb$2(a, b), null != f2 && d.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d, e2) {
  for (var f2 = b._reactName, g2 = []; null !== c && c !== d; ) {
    var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb$2(c, f2), null != k2 && g2.unshift(tf(c, k2, h2))) : e2 || (k2 = Kb$2(c, f2), null != k2 && g2.push(tf(c, k2, h2))));
    c = c.return;
  }
  0 !== g2.length && a.push({ event: b, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c) throw Error(p$4(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b) {
  var c = b, d = 0;
  do {
    var e2 = c.nextSibling;
    a.removeChild(c);
    if (e2 && 8 === e2.nodeType) if (c = e2.data, "/$" === c) {
      if (0 === d) {
        a.removeChild(e2);
        bd$1(b);
        return;
      }
      d--;
    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e2;
  } while (c);
  bd$1(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b) break;
      if ("/$" === b) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc$1(a) {
  var b = a[Of];
  if (b) return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
        if (c = a[Of]) return c;
        a = Mf(a);
      }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb$2(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p$4(33));
}
function Db$2(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E$2(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c) e2[f2] = b[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E$2(Wf);
  E$2(H$2);
}
function ag(a, b, c) {
  if (H$2.current !== Vf) throw Error(p$4(168));
  G$1(H$2, b);
  G$1(Wf, c);
}
function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();
  for (var e2 in d) if (!(e2 in b)) throw Error(p$4(108, Ra$2(a) || "Unknown", e2));
  return A$1({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$1(H$2, a);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(p$4(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E$2(Wf), E$2(H$2), G$1(H$2, a)) : E$2(Wf);
  G$1(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b = C$1;
    try {
      var c = eg;
      for (C$1 = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (null !== d);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac$1(fc$1, jg), e2;
    } finally {
      C$1 = b, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e2 = 32 - oc$1(d) - 1;
  d &= ~(1 << e2);
  c += 1;
  var f2 = 32 - oc$1(b) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d & (1 << g2) - 1).toString(32);
    d >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc$1(b) + e2 | c << e2 | d;
    sg = f2 + a;
  } else rg = 1 << f2 | c << e2 | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I$2) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a)) throw Error(p$4(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I$2 = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p$4(418));
      a.flags = a.flags & -4097 | 2;
      I$2 = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I$2) return Fg(a), I$2 = true, false;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a)) throw Hg(), Error(p$4(418));
    for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p$4(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua$2.ReactCurrentBatchConfig;
function Lg(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag) throw Error(p$4(309));
        var d = c.stateNode;
      }
      if (!d) throw Error(p$4(147, a));
      var e2 = d, f2 = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2) return b.ref;
      b = function(a2) {
        var b2 = e2.refs;
        null === a2 ? delete b2[f2] : b2[f2] = a2;
      };
      b._stringRef = f2;
      return b;
    }
    if ("string" !== typeof a) throw Error(p$4(284));
    if (!c._owner) throw Error(p$4(290, a));
  }
  return a;
}
function Mg(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p$4(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function Ng(a) {
  var b = a._init;
  return b(a._payload);
}
function Og(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.deletions;
      null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a) return null;
    for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e2(a2, b2) {
    a2 = Pg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d2) {
    b2.index = d2;
    if (!a) return b2.flags |= 1048576, c2;
    d2 = b2.alternate;
    if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
    b2.flags |= 2;
    return c2;
  }
  function g2(b2) {
    a && null === b2.alternate && (b2.flags |= 2);
    return b2;
  }
  function h2(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e2(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k2(a2, b2, c2, d2) {
    var f3 = c2.type;
    if (f3 === ya$2) return m2(a2, b2, c2.props.children, d2, c2.key);
    if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha$2 && Ng(f3) === b2.type)) return d2 = e2(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
    d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Lg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e2(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function m2(a2, b2, c2, d2, f3) {
    if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f3), b2.return = a2, b2;
    b2 = e2(b2, c2);
    b2.return = a2;
    return b2;
  }
  function q2(a2, b2, c2) {
    if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case va$2:
          return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
        case wa$2:
          return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
        case Ha$2:
          var d2 = b2._init;
          return q2(a2, d2(b2._payload), c2);
      }
      if (eb$2(b2) || Ka$2(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Mg(a2, b2);
    }
    return null;
  }
  function r2(a2, b2, c2, d2) {
    var e3 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e3 ? null : h2(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va$2:
          return c2.key === e3 ? k2(a2, b2, c2, d2) : null;
        case wa$2:
          return c2.key === e3 ? l2(a2, b2, c2, d2) : null;
        case Ha$2:
          return e3 = c2._init, r2(
            a2,
            b2,
            e3(c2._payload),
            d2
          );
      }
      if (eb$2(c2) || Ka$2(c2)) return null !== e3 ? null : m2(a2, b2, c2, d2, null);
      Mg(a2, c2);
    }
    return null;
  }
  function y2(a2, b2, c2, d2, e3) {
    if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e3);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case va$2:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b2, a2, d2, e3);
        case wa$2:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e3);
        case Ha$2:
          var f3 = d2._init;
          return y2(a2, b2, c2, f3(d2._payload), e3);
      }
      if (eb$2(d2) || Ka$2(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e3, null);
      Mg(b2, d2);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b(e3, a2);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka$2(h3);
    if ("function" !== typeof l3) throw Error(p$4(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$4(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c(
      e3,
      m3
    ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b(e3, a2);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a2, d2, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya$2 && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va$2:
          a: {
            for (var k3 = f3.key, l3 = d2; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya$2) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d2 = e2(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha$2 && Ng(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e2(l3, f3.props);
                  d2.ref = Lg(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else b(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya$2 ? (d2 = Tg(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d2, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa$2:
          a: {
            for (l3 = f3.key; null !== d2; ) {
              if (d2.key === l3) if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                c(a2, d2.sibling);
                d2 = e2(d2, f3.children || []);
                d2.return = a2;
                a2 = d2;
                break a;
              } else {
                c(a2, d2);
                break;
              }
              else b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Sg(f3, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g2(a2);
        case Ha$2:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
      }
      if (eb$2(f3)) return n2(a2, d2, f3, h3);
      if (Ka$2(f3)) return t2(a2, d2, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e2(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f3, a2.mode, h3), d2.return = a2, a2 = d2), g2(a2)) : c(a2, d2);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b = Wg.current;
  E$2(Wg);
  a._currentValue = b;
}
function bh(a, b, c) {
  for (; null !== a; ) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c) break;
    a = a.return;
  }
}
function ch(a, b) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b = a._currentValue;
  if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$4(308));
    Yg = a;
    Xg.dependencies = { lanes: 0, firstContext: a };
  } else Yg = Yg.next = a;
  return b;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b, c, d) {
  var e2 = b.interleaved;
  null === e2 ? (c.next = c, gh(b)) : (c.next = e2.next, e2.next = c);
  b.interleaved = c;
  return ih(a, d);
}
function ih(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b, c) {
  var d = a.updateQueue;
  if (null === d) return null;
  d = d.shared;
  if (0 !== (K$2 & 2)) {
    var e2 = d.pending;
    null === e2 ? b.next = b : (b.next = e2.next, e2.next = b);
    d.pending = b;
    return ih(a, c);
  }
  e2 = d.interleaved;
  null === e2 ? (b.next = b, gh(d)) : (b.next = e2.next, e2.next = b);
  d.interleaved = b;
  return ih(a, c);
}
function oh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc$1(a, c);
  }
}
function ph(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e2 = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c = c.next;
      } while (null !== c);
      null === f2 ? e2 = f2 = b : f2 = f2.next = b;
    } else e2 = f2 = b;
    c = { baseState: d.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function qh(a, b, c, d) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b = e2.shared.interleaved;
    if (null !== b) {
      e2 = b;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function sh(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b], e2 = d.callback;
    if (null !== e2) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e2) throw Error(p$4(191, e2));
      e2.call(d);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th) throw Error(p$4(174));
  return a;
}
function yh(a, b) {
  G$1(wh, b);
  G$1(vh, a);
  G$1(uh, th);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb$2(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb$2(b, a);
  }
  E$2(uh);
  G$1(uh, b);
}
function zh() {
  E$2(uh);
  E$2(vh);
  E$2(wh);
}
function Ah(a) {
  xh(wh.current);
  var b = xh(uh.current);
  var c = lb$2(b, a.type);
  b !== c && (G$1(vh, a), G$1(uh, c));
}
function Bh(a) {
  vh.current === a && (E$2(uh), E$2(vh));
}
var L$4 = Uf(0);
function Ch(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128)) return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a) break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a) return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua$2.ReactCurrentDispatcher, Gh = ua$2.ReactCurrentBatchConfig, Hh = 0, M$2 = null, N$2 = null, O$2 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$2() {
  throw Error(p$4(321));
}
function Mh(a, b) {
  if (null === b) return false;
  for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
  return true;
}
function Nh(a, b, c, d, e2, f2) {
  Hh = f2;
  M$2 = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c(d, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$4(301));
      f2 += 1;
      O$2 = N$2 = null;
      b.updateQueue = null;
      Fh.current = Qh;
      a = c(d, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b = null !== N$2 && null !== N$2.next;
  Hh = 0;
  O$2 = N$2 = M$2 = null;
  Ih = false;
  if (b) throw Error(p$4(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O$2 ? M$2.memoizedState = O$2 = a : O$2 = O$2.next = a;
  return O$2;
}
function Uh() {
  if (null === N$2) {
    var a = M$2.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = N$2.next;
  var b = null === O$2 ? M$2.memoizedState : O$2.next;
  if (null !== b) O$2 = b, N$2 = a;
  else {
    if (null === a) throw Error(p$4(310));
    N$2 = a;
    a = { memoizedState: N$2.memoizedState, baseState: N$2.baseState, baseQueue: N$2.baseQueue, queue: N$2.queue, next: null };
    null === O$2 ? M$2.memoizedState = O$2 = a : O$2 = O$2.next = a;
  }
  return O$2;
}
function Vh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Wh(a) {
  var b = Uh(), c = b.queue;
  if (null === c) throw Error(p$4(311));
  c.lastRenderedReducer = a;
  var d = N$2, e2 = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d.baseQueue = e2 = f2;
    c.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d = d.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d) : k2 = k2.next = q2;
        M$2.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d : k2.next = h2;
    He(d, b.memoizedState) || (dh = true);
    b.memoizedState = d;
    b.baseState = g2;
    b.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M$2.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else null === e2 && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function Xh(a) {
  var b = Uh(), c = b.queue;
  if (null === c) throw Error(p$4(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e2 = c.pending, f2 = b.memoizedState;
  if (null !== e2) {
    c.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b.memoizedState) || (dh = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function Yh() {
}
function Zh(a, b) {
  var c = M$2, d = Uh(), e2 = b(), f2 = !He(d.memoizedState, e2);
  f2 && (d.memoizedState = e2, dh = true);
  d = d.queue;
  $h(ai.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b || f2 || null !== O$2 && O$2.memoizedState.tag & 1) {
    c.flags |= 2048;
    bi(9, ci.bind(null, c, d, e2, b), void 0, null);
    if (null === Q$2) throw Error(p$4(349));
    0 !== (Hh & 30) || di(c, b, e2);
  }
  return e2;
}
function di(a, b, c) {
  a.flags |= 16384;
  a = { getSnapshot: b, value: c };
  b = M$2.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, M$2.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function ci(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  ei(b) && fi(a);
}
function ai(a, b, c) {
  return c(function() {
    ei(b) && fi(a);
  });
}
function ei(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return true;
  }
}
function fi(a) {
  var b = ih(a, 1);
  null !== b && gi(b, a, 1, -1);
}
function hi(a) {
  var b = Th();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b.queue = a;
  a = a.dispatch = ii.bind(null, M$2, a);
  return [b.memoizedState, a];
}
function bi(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = M$2.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, M$2.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b, c, d) {
  var e2 = Th();
  M$2.flags |= a;
  e2.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
}
function li(a, b, c, d) {
  var e2 = Uh();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== N$2) {
    var g2 = N$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d && Mh(d, g2.deps)) {
      e2.memoizedState = bi(b, c, f2, d);
      return;
    }
  }
  M$2.flags |= a;
  e2.memoizedState = bi(1 | b, c, f2, d);
}
function mi(a, b) {
  return ki(8390656, 8, a, b);
}
function $h(a, b) {
  return li(2048, 8, a, b);
}
function ni(a, b) {
  return li(4, 2, a, b);
}
function oi(a, b) {
  return li(4, 4, a, b);
}
function pi(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function() {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
    b.current = null;
  };
}
function qi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return li(4, 4, pi.bind(null, b, a), c);
}
function ri() {
}
function si(a, b) {
  var c = Uh();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Mh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ti(a, b) {
  var c = Uh();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Mh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function ui(a, b, c) {
  if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
  He(c, b) || (c = yc$1(), M$2.lanes |= c, rh |= c, a.baseState = true);
  return b;
}
function vi(a, b) {
  var c = C$1;
  C$1 = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b();
  } finally {
    C$1 = c, Gh.transition = d;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b, c) {
  var d = yi(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b, c);
  else if (c = hh(a, b, c, d), null !== c) {
    var e2 = R$2();
    gi(c, a, d, e2);
    Bi(c, b, d);
  }
}
function ii(a, b, c) {
  var d = yi(a), e2 = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2)) try {
      var g2 = b.lastRenderedState, h2 = f2(g2, c);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b.interleaved;
        null === k2 ? (e2.next = e2, gh(b)) : (e2.next = k2.next, k2.next = e2);
        b.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c = hh(a, b, e2, d);
    null !== c && (e2 = R$2(), gi(c, a, d, e2), Bi(c, b, d));
  }
}
function zi(a) {
  var b = a.alternate;
  return a === M$2 || null !== b && b === M$2;
}
function Ai(a, b) {
  Jh = Ih = true;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Bi(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc$1(a, c);
  }
}
var Rh = { readContext: eh, useCallback: P$2, useContext: P$2, useEffect: P$2, useImperativeHandle: P$2, useInsertionEffect: P$2, useLayoutEffect: P$2, useMemo: P$2, useReducer: P$2, useRef: P$2, useState: P$2, useDebugValue: P$2, useDeferredValue: P$2, useTransition: P$2, useMutableSource: P$2, useSyncExternalStore: P$2, useId: P$2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
  Th().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b, a),
    c
  );
}, useLayoutEffect: function(a, b) {
  return ki(4194308, 4, a, b);
}, useInsertionEffect: function(a, b) {
  return ki(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Th();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Th();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  d.queue = a;
  a = a.dispatch = xi.bind(null, M$2, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b = Th();
  a = { current: a };
  return b.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b, c) {
  var d = M$2, e2 = Th();
  if (I$2) {
    if (void 0 === c) throw Error(p$4(407));
    c = c();
  } else {
    c = b();
    if (null === Q$2) throw Error(p$4(349));
    0 !== (Hh & 30) || di(d, b, c);
  }
  e2.memoizedState = c;
  var f2 = { value: c, getSnapshot: b };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d,
    f2,
    a
  ), [a]);
  d.flags |= 2048;
  bi(9, ci.bind(null, d, f2, c, b), void 0, null);
  return c;
}, useId: function() {
  var a = Th(), b = Q$2.identifierPrefix;
  if (I$2) {
    var c = sg;
    var d = rg;
    c = (d & ~(1 << 32 - oc$1(d) - 1)).toString(32) + c;
    b = ":" + b + "R" + c;
    c = Kh++;
    0 < c && (b += "H" + c.toString(32));
    b += ":";
  } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
  return a.memoizedState = b;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b = Uh();
    return ui(b, N$2.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b = Uh();
  return null === N$2 ? b.memoizedState = a : ui(b, N$2.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b = Uh().memoizedState;
  return [a, b];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b) {
  if (a && a.defaultProps) {
    b = A$1({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
function Di(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A$1({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb$1(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = R$2(), e2 = yi(a), f2 = mh(d, e2);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = nh(a, f2, e2);
  null !== b && (gi(b, a, e2, d), oh(b, a, e2));
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = R$2(), e2 = yi(a), f2 = mh(d, e2);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = nh(a, f2, e2);
  null !== b && (gi(b, a, e2, d), oh(b, a, e2));
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = R$2(), d = yi(a), e2 = mh(c, d);
  e2.tag = 2;
  void 0 !== b && null !== b && (e2.callback = b);
  b = nh(a, e2, d);
  null !== b && (gi(b, a, d, c), oh(b, a, d));
} };
function Fi(a, b, c, d, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e2, f2) : true;
}
function Gi(a, b, c) {
  var d = false, e2 = Vf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b) ? Xf : H$2.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e2) : Vf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Ei;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function Hi(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
}
function Ii(a, b, c, d) {
  var e2 = a.stateNode;
  e2.props = c;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b) ? Xf : H$2.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b, f2, c), e2.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c, e2, d), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b) {
  try {
    var c = "", d = b;
    do
      c += Pa$2(d), d = d.return;
    while (d);
    var e2 = c;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e2, digest: null };
}
function Ki(a, b, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
}
function Li(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b, c) {
  c = mh(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Oi || (Oi = true, Pi = d);
    Li(a, b);
  };
  return c;
}
function Qi(a, b, c) {
  c = mh(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e2 = b.value;
    c.payload = function() {
      return d(e2);
    };
    c.callback = function() {
      Li(a, b);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Li(a, b);
    "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Si(a, b, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d.set(b, e2);
  } else e2 = d.get(b), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d.set(b, e2));
  e2.has(c) || (e2.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
}
function Ui(a) {
  do {
    var b;
    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
    if (b) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b, c, d, e2) {
  if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Wi = ua$2.ReactCurrentOwner, dh = false;
function Xi(a, b, c, d) {
  b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
}
function Yi(a, b, c, d, e2) {
  c = c.render;
  var f2 = b.ref;
  ch(b, e2);
  d = Nh(a, b, c, d, f2, e2);
  c = Sh();
  if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e2, Zi(a, b, e2);
  I$2 && c && vg(b);
  b.flags |= 1;
  Xi(a, b, d, e2);
  return b.child;
}
function $i(a, b, c, d, e2) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f2, bj(a, b, f2, d, e2);
    a = Rg(c.type, null, d, b, b.mode, e2);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g2, d) && a.ref === b.ref) return Zi(a, b, e2);
  }
  b.flags |= 1;
  a = Pg(f2, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function bj(a, b, c, d, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f2, 0 !== (a.lanes & e2)) 0 !== (a.flags & 131072) && (dh = true);
    else return b.lanes = a.lanes, Zi(a, b, e2);
  }
  return cj(a, b, c, d, e2);
}
function dj(a, b, c) {
  var d = b.pendingProps, e2 = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(ej, fj), fj |= c;
  else {
    if (0 === (c & 1073741824)) return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G$1(ej, fj), fj |= a, null;
    b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d = null !== f2 ? f2.baseLanes : c;
    G$1(ej, fj);
    fj |= d;
  }
  else null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G$1(ej, fj), fj |= d;
  Xi(a, b, e2, c);
  return b.child;
}
function gj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
}
function cj(a, b, c, d, e2) {
  var f2 = Zf(c) ? Xf : H$2.current;
  f2 = Yf(b, f2);
  ch(b, e2);
  c = Nh(a, b, c, d, f2, e2);
  d = Sh();
  if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e2, Zi(a, b, e2);
  I$2 && d && vg(b);
  b.flags |= 1;
  Xi(a, b, c, e2);
  return b.child;
}
function hj(a, b, c, d, e2) {
  if (Zf(c)) {
    var f2 = true;
    cg(b);
  } else f2 = false;
  ch(b, e2);
  if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e2), d = true;
  else if (null === a) {
    var g2 = b.stateNode, h2 = b.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c) ? Xf : H$2.current, l2 = Yf(b, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k2 !== l2) && Hi(b, g2, d, l2);
    jh = false;
    var r2 = b.memoizedState;
    g2.state = r2;
    qh(b, d, g2, e2);
    k2 = b.memoizedState;
    h2 !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c, m2, d), k2 = b.memoizedState), (h2 = jh || Fi(b, c, h2, d, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g2.props = d, g2.state = k2, g2.context = l2, d = h2) : ("function" === typeof g2.componentDidMount && (b.flags |= 4194308), d = false);
  } else {
    g2 = b.stateNode;
    lh(a, b);
    h2 = b.memoizedProps;
    l2 = b.type === b.elementType ? h2 : Ci(b.type, h2);
    g2.props = l2;
    q2 = b.pendingProps;
    r2 = g2.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c) ? Xf : H$2.current, k2 = Yf(b, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b, g2, d, k2);
    jh = false;
    r2 = b.memoizedState;
    g2.state = r2;
    qh(b, d, g2, e2);
    var n2 = b.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c, y2, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g2.componentDidUpdate && (b.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g2.props = d, g2.state = n2, g2.context = k2, d = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
  }
  return jj(a, b, c, d, f2, e2);
}
function jj(a, b, c, d, e2, f2) {
  gj(a, b);
  var g2 = 0 !== (b.flags & 128);
  if (!d && !g2) return e2 && dg(b, c, false), Zi(a, b, f2);
  d = b.stateNode;
  Wi.current = b;
  var h2 = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g2 ? (b.child = Ug(b, a.child, null, f2), b.child = Ug(b, null, h2, f2)) : Xi(a, b, h2, f2);
  b.memoizedState = d.state;
  e2 && dg(b, c, true);
  return b.child;
}
function kj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
  yh(a, b.containerInfo);
}
function lj(a, b, c, d, e2) {
  Ig();
  Jg(e2);
  b.flags |= 256;
  Xi(a, b, c, d);
  return b.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b, c) {
  var d = b.pendingProps, e2 = L$4.current, f2 = false, g2 = 0 !== (b.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b.flags &= -129;
  else if (null === a || null !== a.memoizedState) e2 |= 1;
  G$1(L$4, e2 & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g2 = d.children;
    a = d.fallback;
    return f2 ? (d = b.mode, f2 = b.child, g2 = { mode: "hidden", children: g2 }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d, 0, null), a = Tg(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a, b, g2, d, h2, e2, c);
  if (f2) {
    f2 = d.fallback;
    g2 = b.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d.children };
    0 === (g2 & 1) && b.child !== e2 ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e2, k2), d.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c, null), f2.flags |= 2);
    f2.return = b;
    d.return = b;
    d.sibling = f2;
    b.child = d;
    d = f2;
    f2 = b.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? nj(c) : { baseLanes: g2.baseLanes | c, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c;
    b.memoizedState = mj;
    return d;
  }
  f2 = a.child;
  a = f2.sibling;
  d = Pg(f2, { mode: "visible", children: d.children });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}
function qj(a, b) {
  b = pj({ mode: "visible", children: b }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function sj(a, b, c, d) {
  null !== d && Jg(d);
  Ug(b, a.child, null, c);
  a = qj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function rj(a, b, c, d, e2, f2, g2) {
  if (c) {
    if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p$4(422))), sj(a, b, g2, d);
    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
    f2 = d.fallback;
    e2 = b.mode;
    d = pj({ mode: "visible", children: d.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d.return = b;
    f2.return = b;
    d.sibling = f2;
    b.child = d;
    0 !== (b.mode & 1) && Ug(b, a.child, null, g2);
    b.child.memoizedState = nj(g2);
    b.memoizedState = mj;
    return f2;
  }
  if (0 === (b.mode & 1)) return sj(a, b, g2, null);
  if ("$!" === e2.data) {
    d = e2.nextSibling && e2.nextSibling.dataset;
    if (d) var h2 = d.dgst;
    d = h2;
    f2 = Error(p$4(419));
    d = Ki(f2, d, void 0);
    return sj(a, b, g2, d);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (dh || h2) {
    d = Q$2;
    if (null !== d) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d, a, e2, -1));
    }
    tj();
    d = Ki(Error(p$4(421)));
    return sj(a, b, g2, d);
  }
  if ("$?" === e2.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e2._reactRetry = b, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b;
  I$2 = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = qj(b, d.children);
  b.flags |= 4096;
  return b;
}
function vj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  bh(a.return, b, c);
}
function wj(a, b, c, d, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e2 } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e2);
}
function xj(a, b, c) {
  var d = b.pendingProps, e2 = d.revealOrder, f2 = d.tail;
  Xi(a, b, d.children, c);
  d = L$4.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
      else if (19 === a.tag) vj(a, c, b);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d &= 1;
  }
  G$1(L$4, d);
  if (0 === (b.mode & 1)) b.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c = b.child;
      for (e2 = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e2 = c), c = c.sibling;
      c = e2;
      null === c ? (e2 = b.child, b.child = null) : (e2 = c.sibling, c.sibling = null);
      wj(b, false, e2, c, f2);
      break;
    case "backwards":
      c = null;
      e2 = b.child;
      for (b.child = null; null !== e2; ) {
        a = e2.alternate;
        if (null !== a && null === Ch(a)) {
          b.child = e2;
          break;
        }
        a = e2.sibling;
        e2.sibling = c;
        c = e2;
        e2 = a;
      }
      wj(b, true, c, null, f2);
      break;
    case "together":
      wj(b, false, null, null, void 0);
      break;
    default:
      b.memoizedState = null;
  }
  return b.child;
}
function ij(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function Zi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  rh |= b.lanes;
  if (0 === (c & b.childLanes)) return null;
  if (null !== a && b.child !== a.child) throw Error(p$4(153));
  if (null !== b.child) {
    a = b.child;
    c = Pg(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function yj(a, b, c) {
  switch (b.tag) {
    case 3:
      kj(b);
      Ig();
      break;
    case 5:
      Ah(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      yh(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d = b.type._context, e2 = b.memoizedProps.value;
      G$1(Wg, d._currentValue);
      d._currentValue = e2;
      break;
    case 13:
      d = b.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated) return G$1(L$4, L$4.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
        G$1(L$4, L$4.current & 1);
        a = Zi(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G$1(L$4, L$4.current & 1);
      break;
    case 19:
      d = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d) return xj(a, b, c);
        b.flags |= 128;
      }
      e2 = b.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(L$4, L$4.current);
      if (d) break;
      else return null;
    case 22:
    case 23:
      return b.lanes = 0, dj(a, b, c);
  }
  return Zi(a, b, c);
}
var zj, Aj, Bj, Cj;
zj = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b) break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b) return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b, c, d) {
  var e2 = a.memoizedProps;
  if (e2 !== d) {
    a = b.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e2 = Ya$2(a, e2);
        d = Ya$2(a, d);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d = A$1({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb$2(a, e2);
        d = gb$2(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub$2(c, d);
    var g2;
    c = null;
    for (l2 in e2) if (!d.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea$1.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c || (c = {}), c[g2] = k2[g2]);
      } else c || (f2 || (f2 = []), f2.push(
        l2,
        c
      )), c = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea$1.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b.updateQueue = l2) b.flags |= 4;
  }
};
Cj = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Dj(a, b) {
  if (!I$2) switch (a.tailMode) {
    case "hidden":
      b = a.tail;
      for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
      null === c ? a.tail = null : c.sibling = null;
      break;
    case "collapsed":
      c = a.tail;
      for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}
function S$2(a) {
  var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
  if (b) for (var e2 = a.child; null !== e2; ) c |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags & 14680064, d |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else for (e2 = a.child; null !== e2; ) c |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags, d |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}
function Ej(a, b, c) {
  var d = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b), null;
    case 1:
      return Zf(b.type) && $f(), S$2(b), null;
    case 3:
      d = b.stateNode;
      zh();
      E$2(Wf);
      E$2(H$2);
      Eh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b);
      S$2(b);
      return null;
    case 5:
      Bh(b);
      var e2 = xh(wh.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Bj(a, b, c, d, e2), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      else {
        if (!d) {
          if (null === b.stateNode) throw Error(p$4(166));
          S$2(b);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f2;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D$1("cancel", d);
              D$1("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D$1(lf[e2], d);
              break;
            case "source":
              D$1("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d
              );
              D$1("load", d);
              break;
            case "details":
              D$1("toggle", d);
              break;
            case "input":
              Za$2(d, f2);
              D$1("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d);
              break;
            case "textarea":
              hb$2(d, f2), D$1("invalid", d);
          }
          ub$2(c, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d.textContent,
              h2,
              a
            ), e2 = ["children", "" + h2]) : ea$1.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d);
          }
          switch (c) {
            case "input":
              Va$2(d);
              db$2(d, f2, true);
              break;
            case "textarea":
              Va$2(d);
              jb$2(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = Bf);
          }
          d = e2;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb$2(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g2.createElement(c, { is: d.is }) : (a = g2.createElement(c), "select" === c && (g2 = a, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          zj(a, b, false, false);
          b.stateNode = a;
          a: {
            g2 = vb$2(c, d);
            switch (c) {
              case "dialog":
                D$1("cancel", a);
                D$1("close", a);
                e2 = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a);
                e2 = d;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D$1(lf[e2], a);
                e2 = d;
                break;
              case "source":
                D$1("error", a);
                e2 = d;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a
                );
                D$1("load", a);
                e2 = d;
                break;
              case "details":
                D$1("toggle", a);
                e2 = d;
                break;
              case "input":
                Za$2(a, d);
                e2 = Ya$2(a, d);
                D$1("invalid", a);
                break;
              case "option":
                e2 = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e2 = A$1({}, d, { value: void 0 });
                D$1("invalid", a);
                break;
              case "textarea":
                hb$2(a, d);
                e2 = gb$2(a, d);
                D$1("invalid", a);
                break;
              default:
                e2 = d;
            }
            ub$2(c, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb$2(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb$1(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob$2(a, k2) : "number" === typeof k2 && ob$2(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea$1.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a) : null != k2 && ta$2(a, f2, k2, g2));
            }
            switch (c) {
              case "input":
                Va$2(a);
                db$2(a, d, false);
                break;
              case "textarea":
                Va$2(a);
                jb$2(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa$2(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                null != f2 ? fb$2(a, !!d.multiple, f2, false) : null != d.defaultValue && fb$2(
                  a,
                  !!d.multiple,
                  d.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S$2(b);
      return null;
    case 6:
      if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(p$4(166));
        c = xh(wh.current);
        xh(uh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f2 = d.nodeValue !== c) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d.nodeValue, c, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
            }
          }
          f2 && (b.flags |= 4);
        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S$2(b);
      return null;
    case 13:
      E$2(L$4);
      d = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f2 = false;
        else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p$4(318));
            f2 = b.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$4(317));
            f2[Of] = b;
          } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S$2(b);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128)) return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L$4.current & 1) ? 0 === T$2 && (T$2 = 3) : tj()));
      null !== b.updateQueue && (b.flags |= 4);
      S$2(b);
      return null;
    case 4:
      return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S$2(b), null;
    case 10:
      return ah(b.type._context), S$2(b), null;
    case 17:
      return Zf(b.type) && $f(), S$2(b), null;
    case 19:
      E$2(L$4);
      f2 = b.memoizedState;
      if (null === f2) return S$2(b), null;
      d = 0 !== (b.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d) Dj(f2, false);
      else {
        if (0 !== T$2 || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
          g2 = Ch(a);
          if (null !== g2) {
            b.flags |= 128;
            Dj(f2, false);
            d = g2.updateQueue;
            null !== d && (b.updateQueue = d, b.flags |= 4);
            b.subtreeFlags = 0;
            d = c;
            for (c = b.child; null !== c; ) f2 = c, a = d, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
            G$1(L$4, L$4.current & 1 | 2);
            return b.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B$2() > Gj && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
      }
      else {
        if (!d) if (a = Ch(g2), null !== a) {
          if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2) return S$2(b), null;
        } else 2 * B$2() - f2.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c = f2.last, null !== c ? c.sibling = g2 : b.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B$2(), b.sibling = null, c = L$4.current, G$1(L$4, d ? c & 1 | 2 : c & 1), b;
      S$2(b);
      return null;
    case 22:
    case 23:
      return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S$2(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S$2(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$4(156, b.tag));
}
function Ij(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return zh(), E$2(Wf), E$2(H$2), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Bh(b), null;
    case 13:
      E$2(L$4);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate) throw Error(p$4(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E$2(L$4), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$2 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$2 = null;
function Lj(a, b) {
  var c = a.ref;
  if (null !== c) if ("function" === typeof c) try {
    c(null);
  } catch (d) {
    W$2(a, b, d);
  }
  else c.current = null;
}
function Mj(a, b, c) {
  try {
    c();
  } catch (d) {
    W$2(a, b, d);
  }
}
var Nj = false;
function Oj(a, b) {
  Cf = dd$1;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c = (c = a.ownerDocument) && c.defaultView || window;
      var d = c.getSelection && c.getSelection();
      if (d && 0 !== d.rangeCount) {
        c = d.anchorNode;
        var e2 = d.anchorOffset, f2 = d.focusNode;
        d = d.focusOffset;
        try {
          c.nodeType, f2.nodeType;
        } catch (F2) {
          c = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g2 + d);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c = null;
    }
    c = c || { start: 0, end: 0 };
  } else c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd$1 = false;
  for (V$2 = b; null !== V$2; ) if (b = V$2, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V$2 = a;
  else for (; null !== V$2; ) {
    b = V$2;
    try {
      var n2 = b.alternate;
      if (0 !== (b.flags & 1024)) switch (b.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$4(163));
      }
    } catch (F2) {
      W$2(b, b.return, F2);
    }
    a = b.sibling;
    if (null !== a) {
      a.return = b.return;
      V$2 = a;
      break;
    }
    V$2 = b.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e2 = d = d.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b, c, f2);
      }
      e2 = e2.next;
    } while (e2 !== d);
  }
}
function Qj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Rj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Sj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Sj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Tj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Vj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
  else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
}
function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
}
var X$2 = null, Xj = false;
function Yj(a, b, c) {
  for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
}
function Zj(a, b, c) {
  if (lc$1 && "function" === typeof lc$1.onCommitFiberUnmount) try {
    lc$1.onCommitFiberUnmount(kc$1, c);
  } catch (h2) {
  }
  switch (c.tag) {
    case 5:
      U$2 || Lj(c, b);
    case 6:
      var d = X$2, e2 = Xj;
      X$2 = null;
      Yj(a, b, c);
      X$2 = d;
      Xj = e2;
      null !== X$2 && (Xj ? (a = X$2, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X$2.removeChild(c.stateNode));
      break;
    case 18:
      null !== X$2 && (Xj ? (a = X$2, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd$1(a)) : Kf(X$2, c.stateNode));
      break;
    case 4:
      d = X$2;
      e2 = Xj;
      X$2 = c.stateNode.containerInfo;
      Xj = true;
      Yj(a, b, c);
      X$2 = d;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e2 = d = d.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c, b, g2) : 0 !== (f2 & 4) && Mj(c, b, g2));
          e2 = e2.next;
        } while (e2 !== d);
      }
      Yj(a, b, c);
      break;
    case 1:
      if (!U$2 && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
      } catch (h2) {
        W$2(c, b, h2);
      }
      Yj(a, b, c);
      break;
    case 21:
      Yj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U$2 = (d = U$2) || null !== c.memoizedState, Yj(a, b, c), U$2 = d) : Yj(a, b, c);
      break;
    default:
      Yj(a, b, c);
  }
}
function ak(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Kj());
    b.forEach(function(b2) {
      var d = bk.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function ck(a, b) {
  var c = b.deletions;
  if (null !== c) for (var d = 0; d < c.length; d++) {
    var e2 = c[d];
    try {
      var f2 = a, g2 = b, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X$2 = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X$2 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$2 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X$2) throw Error(p$4(160));
      Zj(f2, g2, e2);
      X$2 = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W$2(e2, b, l2);
    }
  }
  if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
}
function dk(a, b) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b, a);
      ek(a);
      if (d & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W$2(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      break;
    case 5:
      ck(b, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob$2(e2, "");
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      if (d & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab$2(e2, f2);
          vb$2(h2, g2);
          var l2 = vb$2(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb$2(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb$1(e2, q2) : "children" === m2 ? ob$2(e2, q2) : ta$2(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb$2(e2, f2);
              break;
            case "textarea":
              ib$2(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb$2(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb$2(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb$2(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      break;
    case 6:
      ck(b, a);
      ek(a);
      if (d & 4) {
        if (null === a.stateNode) throw Error(p$4(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b, a);
      ek(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
        bd$1(b.containerInfo);
      } catch (t2) {
        W$2(a, a.return, t2);
      }
      break;
    case 4:
      ck(b, a);
      ek(a);
      break;
    case 13:
      ck(b, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B$2()));
      d & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U$2 = (l2 = U$2) || m2, ck(b, a), U$2 = l2) : ck(b, a);
      ek(a);
      if (d & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V$2 = a, m2 = a.child; null !== m2; ) {
          for (q2 = V$2 = m2; null !== V$2; ) {
            r2 = V$2;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d = r2;
                  c = r2.return;
                  try {
                    b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W$2(d, c, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V$2 = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb$2("display", g2));
              } catch (t2) {
                W$2(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W$2(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b, a);
      ek(a);
      d & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Tj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p$4(160));
      }
      switch (d.tag) {
        case 5:
          var e2 = d.stateNode;
          d.flags & 32 && (ob$2(e2, ""), d.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g2);
          break;
        default:
          throw Error(p$4(161));
      }
    } catch (k2) {
      W$2(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function hk(a, b, c) {
  V$2 = a;
  ik(a);
}
function ik(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V$2; ) {
    var e2 = V$2, f2 = e2.child;
    if (22 === e2.tag && d) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$2;
        h2 = Jj;
        var l2 = U$2;
        Jj = g2;
        if ((U$2 = k2) && !l2) for (V$2 = e2; null !== V$2; ) g2 = V$2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V$2 = k2) : jk(e2);
        for (; null !== f2; ) V$2 = f2, ik(f2), f2 = f2.sibling;
        V$2 = e2;
        Jj = h2;
        U$2 = l2;
      }
      kk(a);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$2 = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V$2; ) {
    var b = V$2;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            U$2 || Qj(5, b);
            break;
          case 1:
            var d = b.stateNode;
            if (b.flags & 4 && !U$2) if (null === c) d.componentDidMount();
            else {
              var e2 = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
              d.componentDidUpdate(e2, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b.updateQueue;
            null !== f2 && sh(b, f2, d);
            break;
          case 3:
            var g2 = b.updateQueue;
            if (null !== g2) {
              c = null;
              if (null !== b.child) switch (b.child.tag) {
                case 5:
                  c = b.child.stateNode;
                  break;
                case 1:
                  c = b.child.stateNode;
              }
              sh(b, g2, c);
            }
            break;
          case 5:
            var h2 = b.stateNode;
            if (null === c && b.flags & 4) {
              c = h2;
              var k2 = b.memoizedProps;
              switch (b.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c.focus();
                  break;
                case "img":
                  k2.src && (c.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b.memoizedState) {
              var l2 = b.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd$1(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$4(163));
        }
        U$2 || b.flags & 512 && Rj(b);
      } catch (r2) {
        W$2(b, b.return, r2);
      }
    }
    if (b === a) {
      V$2 = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V$2 = c;
      break;
    }
    V$2 = b.return;
  }
}
function gk(a) {
  for (; null !== V$2; ) {
    var b = V$2;
    if (b === a) {
      V$2 = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V$2 = c;
      break;
    }
    V$2 = b.return;
  }
}
function jk(a) {
  for (; null !== V$2; ) {
    var b = V$2;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Qj(4, b);
          } catch (k2) {
            W$2(b, c, k2);
          }
          break;
        case 1:
          var d = b.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e2 = b.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              W$2(b, e2, k2);
            }
          }
          var f2 = b.return;
          try {
            Rj(b);
          } catch (k2) {
            W$2(b, f2, k2);
          }
          break;
        case 5:
          var g2 = b.return;
          try {
            Rj(b);
          } catch (k2) {
            W$2(b, g2, k2);
          }
      }
    } catch (k2) {
      W$2(b, b.return, k2);
    }
    if (b === a) {
      V$2 = null;
      break;
    }
    var h2 = b.sibling;
    if (null !== h2) {
      h2.return = b.return;
      V$2 = h2;
      break;
    }
    V$2 = b.return;
  }
}
var lk = Math.ceil, mk = ua$2.ReactCurrentDispatcher, nk = ua$2.ReactCurrentOwner, ok = ua$2.ReactCurrentBatchConfig, K$2 = 0, Q$2 = null, Y$2 = null, Z$2 = 0, fj = 0, ej = Uf(0), T$2 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R$2() {
  return 0 !== (K$2 & 6) ? B$2() : -1 !== Ak ? Ak : Ak = B$2();
}
function yi(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K$2 & 2) && 0 !== Z$2) return Z$2 & -Z$2;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc$1()), Bk;
  a = C$1;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd$1(a.type);
  return a;
}
function gi(a, b, c, d) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$4(185));
  Ac$1(a, c, d);
  if (0 === (K$2 & 2) || a !== Q$2) a === Q$2 && (0 === (K$2 & 2) && (qk |= c), 4 === T$2 && Ck(a, Z$2)), Dk(a, d), 1 === c && 0 === K$2 && 0 === (b.mode & 1) && (Gj = B$2() + 500, fg && jg());
}
function Dk(a, b) {
  var c = a.callbackNode;
  wc$1(a, b);
  var d = uc$1(a, a === Q$2 ? Z$2 : 0);
  if (0 === d) null !== c && bc$1(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc$1(c);
    if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
      0 === (K$2 & 6) && jg();
    }), c = null;
    else {
      switch (Dc$1(d)) {
        case 1:
          c = fc$1;
          break;
        case 4:
          c = gc$1;
          break;
        case 16:
          c = hc$1;
          break;
        case 536870912:
          c = jc$1;
          break;
        default:
          c = hc$1;
      }
      c = Fk(c, Gk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Gk(a, b) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K$2 & 6)) throw Error(p$4(327));
  var c = a.callbackNode;
  if (Hk() && a.callbackNode !== c) return null;
  var d = uc$1(a, a === Q$2 ? Z$2 : 0);
  if (0 === d) return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
  else {
    b = d;
    var e2 = K$2;
    K$2 |= 2;
    var f2 = Jk();
    if (Q$2 !== a || Z$2 !== b) uk = null, Gj = B$2() + 500, Kk(a, b);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K$2 = e2;
    null !== Y$2 ? b = 0 : (Q$2 = null, Z$2 = 0, b = T$2);
  }
  if (0 !== b) {
    2 === b && (e2 = xc$1(a), 0 !== e2 && (d = e2, b = Nk(a, e2)));
    if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B$2()), c;
    if (6 === b) Ck(a, d);
    else {
      e2 = a.current.alternate;
      if (0 === (d & 30) && !Ok(e2) && (b = Ik(a, d), 2 === b && (f2 = xc$1(a), 0 !== f2 && (d = f2, b = Nk(a, f2))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B$2()), c;
      a.finishedWork = e2;
      a.finishedLanes = d;
      switch (b) {
        case 0:
        case 1:
          throw Error(p$4(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d);
          if ((d & 130023424) === d && (b = fk + 500 - B$2(), 10 < b)) {
            if (0 !== uc$1(a, 0)) break;
            e2 = a.suspendedLanes;
            if ((e2 & d) !== d) {
              R$2();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d);
          if ((d & 4194240) === d) break;
          b = a.eventTimes;
          for (e2 = -1; 0 < d; ) {
            var g2 = 31 - oc$1(d);
            f2 = 1 << g2;
            g2 = b[g2];
            g2 > e2 && (e2 = g2);
            d &= ~f2;
          }
          d = e2;
          d = B$2() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$4(329));
      }
    }
  }
  Dk(a, B$2());
  return a.callbackNode === c ? Gk.bind(null, a) : null;
}
function Nk(a, b) {
  var c = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
  a = Ik(a, b);
  2 !== a && (b = tk, tk = c, null !== b && Fj(b));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b = a; ; ) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
        var e2 = c[d], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
    else {
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return true;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return true;
}
function Ck(a, b) {
  b &= ~rk;
  b &= ~qk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - oc$1(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Ek(a) {
  if (0 !== (K$2 & 6)) throw Error(p$4(327));
  Hk();
  var b = uc$1(a, 0);
  if (0 === (b & 1)) return Dk(a, B$2()), null;
  var c = Ik(a, b);
  if (0 !== a.tag && 2 === c) {
    var d = xc$1(a);
    0 !== d && (b = d, c = Nk(a, d));
  }
  if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B$2()), c;
  if (6 === c) throw Error(p$4(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Pk(a, tk, uk);
  Dk(a, B$2());
  return null;
}
function Qk(a, b) {
  var c = K$2;
  K$2 |= 1;
  try {
    return a(b);
  } finally {
    K$2 = c, 0 === K$2 && (Gj = B$2() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K$2 & 6) && Hk();
  var b = K$2;
  K$2 |= 1;
  var c = ok.transition, d = C$1;
  try {
    if (ok.transition = null, C$1 = 1, a) return a();
  } finally {
    C$1 = d, ok.transition = c, K$2 = b, 0 === (K$2 & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E$2(ej);
}
function Kk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y$2) for (c = Y$2.return; null !== c; ) {
    var d = c;
    wg(d);
    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && $f();
        break;
      case 3:
        zh();
        E$2(Wf);
        E$2(H$2);
        Eh();
        break;
      case 5:
        Bh(d);
        break;
      case 4:
        zh();
        break;
      case 13:
        E$2(L$4);
        break;
      case 19:
        E$2(L$4);
        break;
      case 10:
        ah(d.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c = c.return;
  }
  Q$2 = a;
  Y$2 = a = Pg(a.current, null);
  Z$2 = fj = b;
  T$2 = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
      c.interleaved = null;
      var e2 = d.next, f2 = c.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d.next = g2;
      }
      c.pending = d;
    }
    fh = null;
  }
  return a;
}
function Mk(a, b) {
  do {
    var c = Y$2;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d = M$2.memoizedState; null !== d; ) {
          var e2 = d.queue;
          null !== e2 && (e2.pending = null);
          d = d.next;
        }
        Ih = false;
      }
      Hh = 0;
      O$2 = N$2 = M$2 = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c || null === c.return) {
        T$2 = 1;
        pk = b;
        Y$2 = null;
        break;
      }
      a: {
        var f2 = a, g2 = c.return, h2 = c, k2 = b;
        b = Z$2;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b);
            y2.mode & 1 && Si(f2, l2, b);
            b = y2;
            k2 = l2;
            var n2 = b.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b & 1)) {
              Si(f2, l2, b);
              tj();
              break a;
            }
            k2 = Error(p$4(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T$2 && (T$2 = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b &= -b;
              f2.lanes |= b;
              var x2 = Ni(f2, k2, b);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var F2 = Qi(f2, h2, b);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c);
    } catch (na2) {
      b = na2;
      Y$2 === c && null !== c && (Y$2 = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T$2 || 3 === T$2 || 2 === T$2) T$2 = 4;
  null === Q$2 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q$2, Z$2);
}
function Ik(a, b) {
  var c = K$2;
  K$2 |= 2;
  var d = Jk();
  if (Q$2 !== a || Z$2 !== b) uk = null, Kk(a, b);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K$2 = c;
  mk.current = d;
  if (null !== Y$2) throw Error(p$4(261));
  Q$2 = null;
  Z$2 = 0;
  return T$2;
}
function Tk() {
  for (; null !== Y$2; ) Uk(Y$2);
}
function Lk() {
  for (; null !== Y$2 && !cc$1(); ) Uk(Y$2);
}
function Uk(a) {
  var b = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b ? Sk(a) : Y$2 = b;
  nk.current = null;
}
function Sk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Ej(c, b, fj), null !== c) {
        Y$2 = c;
        return;
      }
    } else {
      c = Ij(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y$2 = c;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T$2 = 6;
        Y$2 = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y$2 = b;
      return;
    }
    Y$2 = b = a;
  } while (null !== b);
  0 === T$2 && (T$2 = 5);
}
function Pk(a, b, c) {
  var d = C$1, e2 = ok.transition;
  try {
    ok.transition = null, C$1 = 1, Wk(a, b, c, d);
  } finally {
    ok.transition = e2, C$1 = d;
  }
  return null;
}
function Wk(a, b, c, d) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K$2 & 6)) throw Error(p$4(327));
  c = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(p$4(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc$1(a, f2);
  a === Q$2 && (Y$2 = Q$2 = null, Z$2 = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc$1, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$2;
    K$2 |= 4;
    nk.current = null;
    Oj(a, c);
    dk(c, a);
    Oe(Df);
    dd$1 = !!Cf;
    Df = Cf = null;
    a.current = c;
    hk(c);
    dc$1();
    K$2 = h2;
    C$1 = g2;
    ok.transition = f2;
  } else a.current = c;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc$1(c.stateNode);
  Dk(a, B$2());
  if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e2 = b[c], d(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc$1(xk), b = ok.transition, c = C$1;
    try {
      ok.transition = null;
      C$1 = 16 > a ? 16 : a;
      if (null === wk) var d = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K$2 & 6)) throw Error(p$4(331));
        var e2 = K$2;
        K$2 |= 4;
        for (V$2 = a.current; null !== V$2; ) {
          var f2 = V$2, g2 = f2.child;
          if (0 !== (V$2.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; null !== V$2; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V$2 = q2;
                  else for (; null !== V$2; ) {
                    m2 = V$2;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V$2 = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V$2 = r2;
                      break;
                    }
                    V$2 = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$2 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V$2 = g2;
          else b: for (; null !== V$2; ) {
            f2 = V$2;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V$2 = x2;
              break b;
            }
            V$2 = f2.return;
          }
        }
        var w2 = a.current;
        for (V$2 = w2; null !== V$2; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V$2 = u2;
          else b: for (g2 = w2; null !== V$2; ) {
            h2 = V$2;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na2) {
              W$2(h2, h2.return, na2);
            }
            if (h2 === g2) {
              V$2 = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V$2 = F2;
              break b;
            }
            V$2 = h2.return;
          }
        }
        K$2 = e2;
        jg();
        if (lc$1 && "function" === typeof lc$1.onPostCommitFiberRoot) try {
          lc$1.onPostCommitFiberRoot(kc$1, a);
        } catch (na2) {
        }
        d = true;
      }
      return d;
    } finally {
      C$1 = c, ok.transition = b;
    }
  }
  return false;
}
function Xk(a, b, c) {
  b = Ji(c, b);
  b = Ni(a, b, 1);
  a = nh(a, b, 1);
  b = R$2();
  null !== a && (Ac$1(a, 1, b), Dk(a, b));
}
function W$2(a, b, c) {
  if (3 === a.tag) Xk(a, a, c);
  else for (; null !== b; ) {
    if (3 === b.tag) {
      Xk(b, a, c);
      break;
    } else if (1 === b.tag) {
      var d = b.stateNode;
      if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
        a = Ji(c, a);
        a = Qi(b, a, 1);
        b = nh(b, a, 1);
        a = R$2();
        null !== b && (Ac$1(b, 1, a), Dk(b, a));
        break;
      }
    }
    b = b.return;
  }
}
function Ti(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = R$2();
  a.pingedLanes |= a.suspendedLanes & c;
  Q$2 === a && (Z$2 & c) === c && (4 === T$2 || 3 === T$2 && (Z$2 & 130023424) === Z$2 && 500 > B$2() - fk ? Kk(a, 0) : rk |= c);
  Dk(a, b);
}
function Yk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc$1, sc$1 <<= 1, 0 === (sc$1 & 130023424) && (sc$1 = 4194304)));
  var c = R$2();
  a = ih(a, b);
  null !== a && (Ac$1(a, b, c), Dk(a, c));
}
function uj(a) {
  var b = a.memoizedState, c = 0;
  null !== b && (c = b.retryLane);
  Yk(a, c);
}
function bk(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c = e2.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p$4(314));
  }
  null !== d && d.delete(b);
  Yk(a, c);
}
var Vk;
Vk = function(a, b, c) {
  if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
    dh = 0 !== (a.flags & 131072) ? true : false;
  }
  else dh = false, I$2 && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d = b.type;
      ij(a, b);
      a = b.pendingProps;
      var e2 = Yf(b, H$2.current);
      ch(b, c);
      e2 = Nh(null, b, d, a, e2, c);
      var f2 = Sh();
      b.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b), e2.updater = Ei, b.stateNode = e2, e2._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f2, c)) : (b.tag = 0, I$2 && f2 && vg(b), Xi(null, b, e2, c), b = b.child);
      return b;
    case 16:
      d = b.elementType;
      a: {
        ij(a, b);
        a = b.pendingProps;
        e2 = d._init;
        d = e2(d._payload);
        b.type = d;
        e2 = b.tag = Zk(d);
        a = Ci(d, a);
        switch (e2) {
          case 0:
            b = cj(null, b, d, a, c);
            break a;
          case 1:
            b = hj(null, b, d, a, c);
            break a;
          case 11:
            b = Yi(null, b, d, a, c);
            break a;
          case 14:
            b = $i(null, b, d, Ci(d.type, a), c);
            break a;
        }
        throw Error(p$4(
          306,
          d,
          ""
        ));
      }
      return b;
    case 0:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), cj(a, b, d, e2, c);
    case 1:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), hj(a, b, d, e2, c);
    case 3:
      a: {
        kj(b);
        if (null === a) throw Error(p$4(387));
        d = b.pendingProps;
        f2 = b.memoizedState;
        e2 = f2.element;
        lh(a, b);
        qh(b, d, null, c);
        var g2 = b.memoizedState;
        d = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
          e2 = Ji(Error(p$4(423)), b);
          b = lj(a, b, d, c, e2);
          break a;
        } else if (d !== e2) {
          e2 = Ji(Error(p$4(424)), b);
          b = lj(a, b, d, c, e2);
          break a;
        } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I$2 = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d === e2) {
            b = Zi(a, b, c);
            break a;
          }
          Xi(a, b, d, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Ah(b), null === a && Eg(b), d = b.type, e2 = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d, e2) ? g2 = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), gj(a, b), Xi(a, b, g2, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return oj(a, b, c);
    case 4:
      return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), Yi(a, b, d, e2, c);
    case 7:
      return Xi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Xi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Xi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e2 = b.pendingProps;
        f2 = b.memoizedProps;
        g2 = e2.value;
        G$1(Wg, d._currentValue);
        d._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b = Zi(a, b, c);
            break a;
          }
        } else for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c & -c);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c);
                bh(
                  f2.return,
                  c,
                  b
                );
                h2.lanes |= c;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$4(341));
            g2.lanes |= c;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c);
            bh(g2, c, b);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a, b, e2.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e2 = b.type, d = b.pendingProps.children, ch(b, c), e2 = eh(e2), d = d(e2), b.flags |= 1, Xi(a, b, d, c), b.child;
    case 14:
      return d = b.type, e2 = Ci(d, b.pendingProps), e2 = Ci(d.type, e2), $i(a, b, d, e2, c);
    case 15:
      return bj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e2), Ii(b, d, e2, c), jj(null, b, d, true, a, c);
    case 19:
      return xj(a, b, c);
    case 22:
      return dj(a, b, c);
  }
  throw Error(p$4(156, b.tag));
};
function Fk(a, b) {
  return ac$1(a, b);
}
function $k(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d) {
  return new $k(a, b, c, d);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a) return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da$2) return 11;
    if (a === Ga$2) return 14;
  }
  return 2;
}
function Pg(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Rg(a, b, c, d, e2, f2) {
  var g2 = 2;
  d = a;
  if ("function" === typeof a) aj(a) && (g2 = 1);
  else if ("string" === typeof a) g2 = 5;
  else a: switch (a) {
    case ya$2:
      return Tg(c.children, e2, f2, b);
    case za$2:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa$2:
      return a = Bg(12, c, b, e2 | 2), a.elementType = Aa$2, a.lanes = f2, a;
    case Ea$2:
      return a = Bg(13, c, b, e2), a.elementType = Ea$2, a.lanes = f2, a;
    case Fa$2:
      return a = Bg(19, c, b, e2), a.elementType = Fa$2, a.lanes = f2, a;
    case Ia$2:
      return pj(c, e2, f2, b);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba$2:
          g2 = 10;
          break a;
        case Ca$2:
          g2 = 9;
          break a;
        case Da$2:
          g2 = 11;
          break a;
        case Ga$2:
          g2 = 14;
          break a;
        case Ha$2:
          g2 = 16;
          d = null;
          break a;
      }
      throw Error(p$4(130, null == a ? a : typeof a, ""));
  }
  b = Bg(g2, c, b, e2);
  b.elementType = a;
  b.type = d;
  b.lanes = f2;
  return b;
}
function Tg(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}
function pj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia$2;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function Sg(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function al(a, b, c, d, e2) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc$1(0);
  this.expirationTimes = zc$1(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc$1(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b, c, d, e2, f2, g2, h2, k2) {
  a = new al(a, b, c, h2, k2);
  1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
  f2 = Bg(3, null, null, b);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa$2, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function dl(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb$1(a) !== a || 1 !== a.tag) throw Error(p$4(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p$4(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c)) return bg(a, c, b);
  }
  return b;
}
function el(a, b, c, d, e2, f2, g2, h2, k2) {
  a = bl(c, d, true, a, e2, f2, g2, h2, k2);
  a.context = dl(null);
  c = a.current;
  d = R$2();
  e2 = yi(c);
  f2 = mh(d, e2);
  f2.callback = void 0 !== b && null !== b ? b : null;
  nh(c, f2, e2);
  a.current.lanes = e2;
  Ac$1(a, e2, d);
  Dk(a, d);
  return a;
}
function fl(a, b, c, d) {
  var e2 = b.current, f2 = R$2(), g2 = yi(e2);
  c = dl(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = mh(f2, g2);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = nh(e2, b, g2);
  null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
  return g2;
}
function gl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function il(a, b) {
  hl(a, b);
  (a = a.alternate) && hl(a, b);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b = this._internalRoot;
  if (null === b) throw Error(p$4(409));
  fl(a, b, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b = Hc$1();
    a = { blockedOn: null, target: a, priority: b };
    for (var c = 0; c < Qc$1.length && 0 !== b && b < Qc$1[c].priority; c++) ;
    Qc$1.splice(c, 0, a);
    0 === c && Vc$1(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b, c, d, e2) {
  if (e2) {
    if ("function" === typeof d) {
      var f2 = d;
      d = function() {
        var a2 = gl(g2);
        f2.call(a2);
      };
    }
    var g2 = el(b, d, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g2;
  }
  for (; e2 = a.lastChild; ) a.removeChild(e2);
  if ("function" === typeof d) {
    var h2 = d;
    d = function() {
      var a2 = gl(k2);
      h2.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b, k2, c, d);
  });
  return k2;
}
function rl(a, b, c, d, e2) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = gl(g2);
        h2.call(a2);
      };
    }
    fl(b, g2, a, e2);
  } else g2 = ql(c, b, a, e2, d);
  return gl(g2);
}
Ec$1 = function(a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc$1(b.pendingLanes);
        0 !== c && (Cc$1(b, c | 1), Dk(b, B$2()), 0 === (K$2 & 6) && (Gj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b2 = ih(a, 1);
        if (null !== b2) {
          var c2 = R$2();
          gi(b2, a, 1, c2);
        }
      }), il(a, 1);
  }
};
Fc$1 = function(a) {
  if (13 === a.tag) {
    var b = ih(a, 134217728);
    if (null !== b) {
      var c = R$2();
      gi(b, a, 134217728, c);
    }
    il(a, 134217728);
  }
};
Gc$1 = function(a) {
  if (13 === a.tag) {
    var b = yi(a), c = ih(a, b);
    if (null !== c) {
      var d = R$2();
      gi(c, a, b, d);
    }
    il(a, b);
  }
};
Hc$1 = function() {
  return C$1;
};
Ic$1 = function(a, b) {
  var c = C$1;
  try {
    return C$1 = a, b();
  } finally {
    C$1 = c;
  }
};
yb$2 = function(a, b, c) {
  switch (b) {
    case "input":
      bb$2(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; ) c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e2 = Db$2(d);
            if (!e2) throw Error(p$4(90));
            Wa$2(d);
            bb$2(d, e2);
          }
        }
      }
      break;
    case "textarea":
      ib$2(a, c);
      break;
    case "select":
      b = c.value, null != b && fb$2(a, !!c.multiple, b, false);
  }
};
Gb$2 = Qk;
Hb$2 = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb$2, ue, Db$2, Eb$2, Fb$1, Qk] }, tl = { findFiberByHostInstance: Wc$1, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$2.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb$1(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc$1 = vl.inject(ul), lc$1 = vl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b)) throw Error(p$4(200));
  return cl(a, b, null, c);
};
reactDom_production_min.createRoot = function(a, b) {
  if (!nl(a)) throw Error(p$4(299));
  var c = false, d = "", e2 = kl;
  null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e2 = b.onRecoverableError));
  b = bl(a, 1, false, null, null, c, false, d, e2);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(p$4(188));
    a = Object.keys(a).join(",");
    throw Error(p$4(268, a));
  }
  a = Zb$1(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!ol(b)) throw Error(p$4(200));
  return rl(null, a, b, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b, c) {
  if (!nl(a)) throw Error(p$4(405));
  var d = null != c && c.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e2 = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g2 = c.onRecoverableError));
  b = el(b, null, a, 1, null != c ? c : null, e2, false, f2, g2);
  a[uf] = b.current;
  sf(a);
  if (d) for (a = 0; a < d.length; a++) c = d[a], e2 = c._getVersion, e2 = e2(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e2] : b.mutableSourceEagerHydrationData.push(
    c,
    e2
  );
  return new ml(b);
};
reactDom_production_min.render = function(a, b, c) {
  if (!ol(b)) throw Error(p$4(200));
  return rl(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a)) throw Error(p$4(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!ol(c)) throw Error(p$4(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p$4(38));
  return rl(a, b, c, false, d);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$12;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result2[resIndex++] = value;
        }
      }
      return result2;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
      while (++index < length) {
        result2[index] = iteratee(array[index], index, array);
      }
      return result2;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result2;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result2 = key;
          return false;
        }
      });
      return result2;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$12 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$12 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result2, index = -1, length = array.length;
      while (++index < length) {
        var current2 = iteratee(array[index]);
        if (current2 !== undefined$12) {
          result2 = result2 === undefined$12 ? current2 : result2 + current2;
        }
      }
      return result2;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result2 = Array(n2);
      while (++index < n2) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result2 = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result2;
        }
      }
      return result2;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$12 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result2 = [];
      while (!(data = iterator.next()).done) {
        result2.push(data.value);
      }
      return result2;
    }
    function mapToArray(map) {
      var index = -1, result2 = Array(map.size);
      map.forEach(function(value, key) {
        result2[++index] = [key, value];
      });
      return result2;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result2[resIndex++] = index;
        }
      }
      return result2;
    }
    function setToArray(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    function setToPairs(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value) {
        result2[++index] = [value, value];
      });
      return result2;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result2 = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result2;
      }
      return result2;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString2 = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$12, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$12, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$12;
      var defineProperty2 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$12, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$12, symbolToString = symbolProto ? symbolProto.toString : undefined$12;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result3 = new object();
          object.prototype = undefined$12;
          return result3;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$12;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result3 = new LazyWrapper(this.__wrapped__);
        result3.__actions__ = copyArray(this.__actions__);
        result3.__dir__ = this.__dir__;
        result3.__filtered__ = this.__filtered__;
        result3.__iteratees__ = copyArray(this.__iteratees__);
        result3.__takeCount__ = this.__takeCount__;
        result3.__views__ = copyArray(this.__views__);
        return result3;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result3 = new LazyWrapper(this);
          result3.__dir__ = -1;
          result3.__filtered__ = true;
        } else {
          result3 = this.clone();
          result3.__dir__ *= -1;
        }
        return result3;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result3 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result3[resIndex++] = value;
          }
        return result3;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result3 = this.has(key) && delete this.__data__[key];
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result3 = data[key];
          return result3 === HASH_UNDEFINED ? undefined$12 : result3;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$12;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$12 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$12 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined$12 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result3 = getMapData(this, key)["delete"](key);
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result3 = data["delete"](key);
        this.size = data.size;
        return result3;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments5(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value.length, String2) : [], length = result3.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$12;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$12 && !eq(object[key], value) || value === undefined$12 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$12 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys3(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result3 = Array2(length), skip = object == null;
        while (++index < length) {
          result3[index] = skip ? undefined$12 : get(object, paths[index]);
        }
        return result3;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$12) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$12) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result3, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result3 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result3 !== undefined$12) {
          return result3;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result3 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result3);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result3 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result3, value)) : copySymbols(value, baseAssign(result3, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result3 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result3);
        if (isSet3(value)) {
          value.forEach(function(subValue) {
            result3.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap3(value)) {
          value.forEach(function(subValue, key2) {
            result3.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys3;
        var props = isArr ? undefined$12 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result3, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result3;
      }
      function baseConforms(source) {
        var props = keys3(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$12 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$12, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result3 = [], valuesLength = values2.length;
        if (!length) {
          return result3;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result3.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result3.push(value);
            }
          }
        return result3;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result3 = true;
        baseEach(collection, function(value, index, collection2) {
          result3 = !!predicate(value, index, collection2);
          return result3;
        });
        return result3;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current2 = iteratee2(value);
          if (current2 != null && (computed === undefined$12 ? current2 === current2 && !isSymbol2(current2) : comparator(current2, computed))) {
            var computed = current2, result3 = value;
          }
        }
        return result3;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$12 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result3 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result3.push(value);
          }
        });
        return result3;
      }
      function baseFlatten(array, depth, predicate, isStrict, result3) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result3 || (result3 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result3);
            } else {
              arrayPush(result3, value);
            }
          } else if (!isStrict) {
            result3[result3.length] = value;
          }
        }
        return result3;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys3);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys3);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined$12;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result3 = keysFunc(object);
        return isArray2(object) ? result3 : arrayPush(result3, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$12 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result3 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$12;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result3.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result3, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result3.push(value);
            }
          }
        return result3;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$12 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$12 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result3 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result3 === undefined$12 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result3 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result3 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result3 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result3[++index] = iteratee2(value, key, collection2);
        });
        return result3;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$12 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$12;
            if (newValue === undefined$12) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$12;
        var isCommon = newValue === undefined$12;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments5(srcValue)) {
            newValue = objValue;
            if (isArguments5(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined$12;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result3 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result3, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result3 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result3, castPath(path, object), value);
          }
        }
        return result3;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf4 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf4(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result3 = Array2(length);
        while (length--) {
          result3[fromRight ? length : ++index] = start;
          start += step;
        }
        return result3;
      }
      function baseRepeat(string, n2) {
        var result3 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result3;
        }
        do {
          if (n2 % 2) {
            result3 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result3;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$12;
            if (newValue === undefined$12) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty2 ? identity2 : function(func, string) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result3 = Array2(length);
        while (++index < length) {
          result3[index] = array[index + start];
        }
        return result3;
      }
      function baseSome(collection, predicate) {
        var result3;
        baseEach(collection, function(value, index, collection2) {
          result3 = predicate(value, index, collection2);
          return !result3;
        });
        return !!result3;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$12;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$12, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result3 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result3[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result3;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result3 = value + "";
        return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result3 = [], seen = result3;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result3;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result3.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result3) {
                seen.push(computed);
              }
              result3.push(value);
            }
          }
        return result3;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions2) {
        var result3 = value;
        if (result3 instanceof LazyWrapper) {
          result3 = result3.value();
        }
        return arrayReduce(actions2, function(result4, action) {
          return action.func.apply(action.thisArg, arrayPush([result4], action.args));
        }, result3);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result3 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result3[index] = baseDifference(result3[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result3, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result3 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined$12;
          assignFunc(result3, props[index], value);
        }
        return result3;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath3(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$12 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result3);
        return result3;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result3).set(new Uint8Array2(arrayBuffer));
        return result3;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result3 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result3.lastIndex = regexp.lastIndex;
        return result3;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result3 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result3) {
            if (index >= ordersLength) {
              return result3;
            }
            var order = orders[index];
            return result3 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result3[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result3[leftIndex++] = args[argsIndex++];
        }
        return result3;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result3[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result3[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result3;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$12;
          if (newValue === undefined$12) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$12 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$12;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
          return isObject2(result3) ? result3 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$12,
              args,
              holders,
              undefined$12,
              undefined$12,
              arity - length
            );
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys3(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$12;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$12;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result3 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result3 = funcs[index2].call(this, result3);
            }
            return result3;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result3;
          if (value === undefined$12 && other === undefined$12) {
            return defaultValue;
          }
          if (value !== undefined$12) {
            result3 = value;
          }
          if (other !== undefined$12) {
            if (result3 === undefined$12) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result3 = operator(value, other);
          }
          return result3;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$12 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result3 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$12;
          }
          start = toFinite(start);
          if (end === undefined$12) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$12 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result3 = wrapFunc.apply(undefined$12, newData);
        if (isLaziable(func)) {
          setData(result3, newData);
        }
        result3.placeholder = placeholder;
        return setWrapToString(result3, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$12;
        }
        ary2 = ary2 === undefined$12 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$12 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$12;
        }
        var data = isBindKey ? undefined$12 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result3 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result3 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result3 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result3 = createHybrid.apply(undefined$12, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result3, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$12 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$12, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$12 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$12;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$12) {
            if (compared) {
              continue;
            }
            result3 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result3 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result3 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result3;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result3 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result3;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result3 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result3 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result3 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result3 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result3;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$12, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys3, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result3 = func.name + "", array = realNames[result3], length = hasOwnProperty2.call(realNames, result3) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result3;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result3 = lodash2.iteratee || iteratee;
        result3 = result3 === iteratee ? baseIteratee : result3;
        return arguments.length ? result3(arguments[0], arguments[1]) : result3;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result3 = keys3(object), length = result3.length;
        while (length--) {
          var key = result3[length], value = object[key];
          result3[length] = [key, value, isStrictComparable(value)];
        }
        return result3;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$12;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$12;
          var unmasked = true;
        } catch (e2) {
        }
        var result3 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result3;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result3 = [];
        while (object) {
          arrayPush(result3, getSymbols(object));
          object = getPrototype(object);
        }
        return result3;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result3 = baseGetTag(value), Ctor = result3 == objectTag ? value.constructor : undefined$12, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result3;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result3 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result3 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result3 || ++index != length) {
          return result3;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments5(object));
      }
      function initCloneArray(array) {
        var length = array.length, result3 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result3.index = array.index;
          result3.input = array.input;
        }
        return result3;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments5(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$12 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result3 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result3.cache;
        return result3;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result3 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result3.push(key);
          }
        }
        return result3;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$12 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$12;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference2, bitmask) {
        var source = reference2 + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$12, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$12 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath3 = memoizeCapped(function(string) {
        var result3 = [];
        if (string.charCodeAt(0) === 46) {
          result3.push("");
        }
        string.replace(rePropName2, function(match, number, quote2, subString) {
          result3.push(quote2 ? subString.replace(reEscapeChar2, "$1") : number || match);
        });
        return result3;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result3 = value + "";
        return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result3.__actions__ = copyArray(wrapper.__actions__);
        result3.__index__ = wrapper.__index__;
        result3.__values__ = wrapper.__values__;
        return result3;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$12) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result3 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result3[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result3;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result3 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result3[resIndex++] = value;
          }
        }
        return result3;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$12, comparator) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$12) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$12 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
        while (++index < length) {
          var pair = pairs[index];
          result3[pair[0]] = pair[1];
        }
        return result3;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$12;
      }
      function indexOf3(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$12;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$12, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$12;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$12) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger(n2)) : undefined$12;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$12, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result3 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result3;
      });
      function remove(array, predicate) {
        var result3 = [];
        if (!(array && array.length)) {
          return result3;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result3.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result3;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice2(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$12 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$12, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return array && array.length ? baseUniq(array, undefined$12, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result3 = unzip(array);
        if (iteratee2 == null) {
          return result3;
        }
        return arrayMap(result3, function(group) {
          return apply(iteratee2, undefined$12, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$12, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result3 = lodash2(value);
        result3.__chain__ = true;
        return result3;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$12
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$12);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$12) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$12 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result3, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$12;
          if (result3) {
            previous.__wrapped__ = clone3;
          } else {
            result3 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result3;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$12
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result3, value, key) {
        if (hasOwnProperty2.call(result3, key)) {
          ++result3[key];
        } else {
          baseAssignValue(result3, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$12 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result3, value, key) {
        if (hasOwnProperty2.call(result3, key)) {
          result3[key].push(value);
        } else {
          baseAssignValue(result3, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result3 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result3[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result3;
      });
      var keyBy = createAggregator(function(result3, value, key) {
        baseAssignValue(result3, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$12 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result3, value, key) {
        result3[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$12) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString3(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$12 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n2);
      }
      function before(n2, func) {
        var result3;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result3 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$12;
          }
          return result3;
        };
      }
      var bind3 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result3.placeholder = curry.placeholder;
        return result3;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result3.placeholder = curryRight.placeholder;
        return result3;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$12;
          lastInvokeTime = time;
          result3 = func.apply(thisArg, args);
          return result3;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result3;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$12;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$12;
          return result3;
        }
        function cancel() {
          if (timerId !== undefined$12) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$12;
        }
        function flush() {
          return timerId === undefined$12 ? result3 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$12) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$12) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result3;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result3 = func.apply(this, args);
          memoized.cache = cache2.set(key, result3) || cache2;
          return result3;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$12 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys3(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments5 = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer5 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean3(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments5(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        var result3 = customizer ? customizer(value, other) : undefined$12;
        return result3 === undefined$12 ? baseIsEqual(value, other, undefined$12, customizer) : !!result3;
      }
      function isError2(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap3 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString2;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet3 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString3(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$12;
      }
      function isWeakMap3(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet2(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString3(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result3 = toFinite(value), remainder = result3 % 1;
        return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign4 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys3(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys3(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result3 = baseCreate(prototype);
        return properties == null ? result3 : baseAssign(result3, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$12;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$12 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$12, customDefaultsMerge);
        return apply(mergeWith, undefined$12, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys3(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result3 = object == null ? undefined$12 : baseGet(object, path);
        return result3 === undefined$12 ? defaultValue : result3;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result3, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result3[value] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result3, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result3, value)) {
          result3[value].push(key);
        } else {
          result3[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys3(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result3, iteratee2(value, key, object2), value);
        });
        return result3;
      }
      function mapValues(object, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result3, key, iteratee2(value, key, object2));
        });
        return result3;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result3 = {};
        if (object == null) {
          return result3;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result3);
        if (isDeep) {
          result3 = baseClone(result3, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result3, paths[length]);
        }
        return result3;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result2(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$12;
        }
        while (++index < length) {
          var value = object == null ? undefined$12 : object[toKey(path[index])];
          if (value === undefined$12) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys3);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys3(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$12) {
          upper = lower;
          lower = undefined$12;
        }
        if (upper !== undefined$12) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$12) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$12) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$12;
        }
        if (floating === undefined$12) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$12;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$12;
          }
        }
        if (lower === undefined$12 && upper === undefined$12) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$12) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result3, word, index) {
        word = word.toLowerCase();
        return result3 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$12 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$12) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString2(string), n2);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$12;
        }
        limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$12;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys3(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result3 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$12, importsValues);
        });
        result3.source = source;
        if (isError2(result3)) {
          throw result3;
        }
        return result3;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$12)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$12)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$12)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$12) {
          return result3 + omission;
        }
        if (strSymbols) {
          end += result3.length - end;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result3;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result3 = result3.slice(0, newEnd === undefined$12 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result3.lastIndexOf(separator);
          if (index > -1) {
            result3 = result3.slice(0, index);
          }
        }
        return result3 + omission;
      }
      function unescape(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$12 : pattern;
        if (pattern === undefined$12) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$12, args);
        } catch (e2) {
          return isError2(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind3(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys3(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys3(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result3 = object(this.__wrapped__), actions2 = result3.__actions__ = copyArray(this.__actions__);
                actions2.push({ "func": func, "args": arguments, "thisArg": object });
                result3.__chain__ = chainAll;
                return result3;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$12 : baseGet(object, path);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result3 = baseTimes(length, iteratee2);
        while (++index < n2) {
          iteratee2(index);
        }
        return result3;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath3(toString2(value)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter;
        return toString2(prefix) + id2;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$12;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$12;
      }
      function mean(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$12;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$12;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign4;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat2;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys3;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach3;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf3;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments5;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer5;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean3;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError2;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap3;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet3;
      lodash2.isString = isString3;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap3;
      lodash2.isWeakSet = isWeakSet2;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result2;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach3;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$12 ? 1 : nativeMax(toInteger(n2), 0);
          var result3 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result3.__filtered__) {
            result3.__takeCount__ = nativeMin(n2, result3.__takeCount__);
          } else {
            result3.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result3.__dir__ < 0 ? "Right" : "")
            });
          }
          return result3;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result3 = this.clone();
          result3.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type2
          });
          result3.__filtered__ = result3.__filtered__ || isFilter;
          return result3;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result3 = this;
        if (result3.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result3);
        }
        if (start < 0) {
          result3 = result3.takeRight(-start);
        } else if (start) {
          result3 = result3.drop(start);
        }
        if (end !== undefined$12) {
          end = toInteger(end);
          result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
        }
        return result3;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result4 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result4[0] : result4;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result3 = func.apply(value, args);
            result3.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
            return new LodashWrapper(result3, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result3 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$12
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
function useAttribution(map, attribution) {
  const attributionRef = reactExports.useRef(attribution);
  reactExports.useEffect(function updateAttribution() {
    if (attribution !== attributionRef.current && map.attributionControl != null) {
      if (attributionRef.current != null) {
        map.attributionControl.removeAttribution(attributionRef.current);
      }
      if (attribution != null) {
        map.attributionControl.addAttribution(attribution);
      }
    }
    attributionRef.current = attribution;
  }, [
    map,
    attribution
  ]);
}
const CONTEXT_VERSION = 1;
function createLeafletContext(map) {
  return Object.freeze({
    __version: CONTEXT_VERSION,
    map
  });
}
function extendContext(source, extra) {
  return Object.freeze({
    ...source,
    ...extra
  });
}
const LeafletContext = reactExports.createContext(null);
const LeafletProvider = LeafletContext.Provider;
function useLeafletContext() {
  const context = reactExports.useContext(LeafletContext);
  if (context == null) {
    throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");
  }
  return context;
}
function createContainerComponent(useElement) {
  function ContainerComponent(props, forwardedRef) {
    const { instance, context } = useElement(props).current;
    reactExports.useImperativeHandle(forwardedRef, () => instance);
    return props.children == null ? null : /* @__PURE__ */ ReactExports.createElement(LeafletProvider, {
      value: context
    }, props.children);
  }
  return /* @__PURE__ */ reactExports.forwardRef(ContainerComponent);
}
function createLeafComponent(useElement) {
  function LeafComponent(props, forwardedRef) {
    const { instance } = useElement(props).current;
    reactExports.useImperativeHandle(forwardedRef, () => instance);
    return null;
  }
  return /* @__PURE__ */ reactExports.forwardRef(LeafComponent);
}
function createControlHook(useElement) {
  return function useLeafletControl(props) {
    const context = useLeafletContext();
    const elementRef = useElement(props, context);
    const { instance } = elementRef.current;
    const positionRef = reactExports.useRef(props.position);
    const { position } = props;
    reactExports.useEffect(function addControl() {
      instance.addTo(context.map);
      return function removeControl() {
        instance.remove();
      };
    }, [
      context.map,
      instance
    ]);
    reactExports.useEffect(function updateControl() {
      if (position != null && position !== positionRef.current) {
        instance.setPosition(position);
        positionRef.current = position;
      }
    }, [
      instance,
      position
    ]);
    return elementRef;
  };
}
function useEventHandlers(element, eventHandlers) {
  const eventHandlersRef = reactExports.useRef();
  reactExports.useEffect(function addEventHandlers() {
    if (eventHandlers != null) {
      element.instance.on(eventHandlers);
    }
    eventHandlersRef.current = eventHandlers;
    return function removeEventHandlers() {
      if (eventHandlersRef.current != null) {
        element.instance.off(eventHandlersRef.current);
      }
      eventHandlersRef.current = null;
    };
  }, [
    element,
    eventHandlers
  ]);
}
function withPane(props, context) {
  const pane = props.pane ?? context.pane;
  return pane ? {
    ...props,
    pane
  } : props;
}
var leafletSrc = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    var version = "1.9.4";
    function extend(dest) {
      var i, j, len, src;
      for (j = 1, len = arguments.length; j < len; j++) {
        src = arguments[j];
        for (i in src) {
          dest[i] = src[i];
        }
      }
      return dest;
    }
    var create$2 = Object.create || /* @__PURE__ */ function() {
      function F2() {
      }
      return function(proto) {
        F2.prototype = proto;
        return new F2();
      };
    }();
    function bind3(fn, obj) {
      var slice2 = Array.prototype.slice;
      if (fn.bind) {
        return fn.bind.apply(fn, slice2.call(arguments, 1));
      }
      var args = slice2.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.length ? args.concat(slice2.call(arguments)) : arguments);
      };
    }
    var lastId = 0;
    function stamp(obj) {
      if (!("_leaflet_id" in obj)) {
        obj["_leaflet_id"] = ++lastId;
      }
      return obj._leaflet_id;
    }
    function throttle(fn, time, context) {
      var lock, args, wrapperFn, later;
      later = function() {
        lock = false;
        if (args) {
          wrapperFn.apply(context, args);
          args = false;
        }
      };
      wrapperFn = function() {
        if (lock) {
          args = arguments;
        } else {
          fn.apply(context, arguments);
          setTimeout(later, time);
          lock = true;
        }
      };
      return wrapperFn;
    }
    function wrapNum(x2, range2, includeMax) {
      var max2 = range2[1], min = range2[0], d = max2 - min;
      return x2 === max2 && includeMax ? x2 : ((x2 - min) % d + d) % d + min;
    }
    function falseFn() {
      return false;
    }
    function formatNum(num, precision) {
      if (precision === false) {
        return num;
      }
      var pow = Math.pow(10, precision === void 0 ? 6 : precision);
      return Math.round(num * pow) / pow;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function splitWords(str) {
      return trim(str).split(/\s+/);
    }
    function setOptions(obj, options) {
      if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
        obj.options = obj.options ? create$2(obj.options) : {};
      }
      for (var i in options) {
        obj.options[i] = options[i];
      }
      return obj.options;
    }
    function getParamString(obj, existingUrl, uppercase) {
      var params = [];
      for (var i in obj) {
        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
      }
      return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
    }
    var templateRe = /\{ *([\w_ -]+) *\}/g;
    function template(str, data) {
      return str.replace(templateRe, function(str2, key) {
        var value = data[key];
        if (value === void 0) {
          throw new Error("No value provided for variable " + str2);
        } else if (typeof value === "function") {
          value = value(data);
        }
        return value;
      });
    }
    var isArray2 = Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    function indexOf3(array, el2) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === el2) {
          return i;
        }
      }
      return -1;
    }
    var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    function getPrefixed(name) {
      return window["webkit" + name] || window["moz" + name] || window["ms" + name];
    }
    var lastTime = 0;
    function timeoutDefer(fn) {
      var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
      lastTime = time + timeToCall;
      return window.setTimeout(fn, timeToCall);
    }
    var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
    var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id2) {
      window.clearTimeout(id2);
    };
    function requestAnimFrame(fn, context, immediate) {
      if (immediate && requestFn === timeoutDefer) {
        fn.call(context);
      } else {
        return requestFn.call(window, bind3(fn, context));
      }
    }
    function cancelAnimFrame(id2) {
      if (id2) {
        cancelFn.call(window, id2);
      }
    }
    var Util = {
      __proto__: null,
      extend,
      create: create$2,
      bind: bind3,
      get lastId() {
        return lastId;
      },
      stamp,
      throttle,
      wrapNum,
      falseFn,
      formatNum,
      trim,
      splitWords,
      setOptions,
      getParamString,
      template,
      isArray: isArray2,
      indexOf: indexOf3,
      emptyImageUrl,
      requestFn,
      cancelFn,
      requestAnimFrame,
      cancelAnimFrame
    };
    function Class() {
    }
    Class.extend = function(props) {
      var NewClass = function() {
        setOptions(this);
        if (this.initialize) {
          this.initialize.apply(this, arguments);
        }
        this.callInitHooks();
      };
      var parentProto = NewClass.__super__ = this.prototype;
      var proto = create$2(parentProto);
      proto.constructor = NewClass;
      NewClass.prototype = proto;
      for (var i in this) {
        if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
          NewClass[i] = this[i];
        }
      }
      if (props.statics) {
        extend(NewClass, props.statics);
      }
      if (props.includes) {
        checkDeprecatedMixinEvents(props.includes);
        extend.apply(null, [proto].concat(props.includes));
      }
      extend(proto, props);
      delete proto.statics;
      delete proto.includes;
      if (proto.options) {
        proto.options = parentProto.options ? create$2(parentProto.options) : {};
        extend(proto.options, props.options);
      }
      proto._initHooks = [];
      proto.callInitHooks = function() {
        if (this._initHooksCalled) {
          return;
        }
        if (parentProto.callInitHooks) {
          parentProto.callInitHooks.call(this);
        }
        this._initHooksCalled = true;
        for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
          proto._initHooks[i2].call(this);
        }
      };
      return NewClass;
    };
    Class.include = function(props) {
      var parentOptions = this.prototype.options;
      extend(this.prototype, props);
      if (props.options) {
        this.prototype.options = parentOptions;
        this.mergeOptions(props.options);
      }
      return this;
    };
    Class.mergeOptions = function(options) {
      extend(this.prototype.options, options);
      return this;
    };
    Class.addInitHook = function(fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      var init = typeof fn === "function" ? fn : function() {
        this[fn].apply(this, args);
      };
      this.prototype._initHooks = this.prototype._initHooks || [];
      this.prototype._initHooks.push(init);
      return this;
    };
    function checkDeprecatedMixinEvents(includes) {
      if (typeof L === "undefined" || !L || !L.Mixin) {
        return;
      }
      includes = isArray2(includes) ? includes : [includes];
      for (var i = 0; i < includes.length; i++) {
        if (includes[i] === L.Mixin.Events) {
          console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
    }
    var Events = {
      /* @method on(type: String, fn: Function, context?: Object): this
       * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
       *
       * @alternative
       * @method on(eventMap: Object): this
       * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
       */
      on: function(types, fn, context) {
        if (typeof types === "object") {
          for (var type2 in types) {
            this._on(type2, types[type2], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            this._on(types[i], fn, context);
          }
        }
        return this;
      },
      /* @method off(type: String, fn?: Function, context?: Object): this
       * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
       *
       * @alternative
       * @method off(eventMap: Object): this
       * Removes a set of type/listener pairs.
       *
       * @alternative
       * @method off: this
       * Removes all listeners to all events on the object. This includes implicitly attached events.
       */
      off: function(types, fn, context) {
        if (!arguments.length) {
          delete this._events;
        } else if (typeof types === "object") {
          for (var type2 in types) {
            this._off(type2, types[type2], fn);
          }
        } else {
          types = splitWords(types);
          var removeAll = arguments.length === 1;
          for (var i = 0, len = types.length; i < len; i++) {
            if (removeAll) {
              this._off(types[i]);
            } else {
              this._off(types[i], fn, context);
            }
          }
        }
        return this;
      },
      // attach listener (without syntactic sugar now)
      _on: function(type2, fn, context, _once) {
        if (typeof fn !== "function") {
          console.warn("wrong listener type: " + typeof fn);
          return;
        }
        if (this._listens(type2, fn, context) !== false) {
          return;
        }
        if (context === this) {
          context = void 0;
        }
        var newListener = { fn, ctx: context };
        if (_once) {
          newListener.once = true;
        }
        this._events = this._events || {};
        this._events[type2] = this._events[type2] || [];
        this._events[type2].push(newListener);
      },
      _off: function(type2, fn, context) {
        var listeners, i, len;
        if (!this._events) {
          return;
        }
        listeners = this._events[type2];
        if (!listeners) {
          return;
        }
        if (arguments.length === 1) {
          if (this._firingCount) {
            for (i = 0, len = listeners.length; i < len; i++) {
              listeners[i].fn = falseFn;
            }
          }
          delete this._events[type2];
          return;
        }
        if (typeof fn !== "function") {
          console.warn("wrong listener type: " + typeof fn);
          return;
        }
        var index2 = this._listens(type2, fn, context);
        if (index2 !== false) {
          var listener = listeners[index2];
          if (this._firingCount) {
            listener.fn = falseFn;
            this._events[type2] = listeners = listeners.slice();
          }
          listeners.splice(index2, 1);
        }
      },
      // @method fire(type: String, data?: Object, propagate?: Boolean): this
      // Fires an event of the specified type. You can optionally provide a data
      // object — the first argument of the listener function will contain its
      // properties. The event can optionally be propagated to event parents.
      fire: function(type2, data, propagate) {
        if (!this.listens(type2, propagate)) {
          return this;
        }
        var event = extend({}, data, {
          type: type2,
          target: this,
          sourceTarget: data && data.sourceTarget || this
        });
        if (this._events) {
          var listeners = this._events[type2];
          if (listeners) {
            this._firingCount = this._firingCount + 1 || 1;
            for (var i = 0, len = listeners.length; i < len; i++) {
              var l2 = listeners[i];
              var fn = l2.fn;
              if (l2.once) {
                this.off(type2, fn, l2.ctx);
              }
              fn.call(l2.ctx || this, event);
            }
            this._firingCount--;
          }
        }
        if (propagate) {
          this._propagateEvent(event);
        }
        return this;
      },
      // @method listens(type: String, propagate?: Boolean): Boolean
      // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
      // Returns `true` if a particular event type has any listeners attached to it.
      // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
      listens: function(type2, fn, context, propagate) {
        if (typeof type2 !== "string") {
          console.warn('"string" type argument expected');
        }
        var _fn = fn;
        if (typeof fn !== "function") {
          propagate = !!fn;
          _fn = void 0;
          context = void 0;
        }
        var listeners = this._events && this._events[type2];
        if (listeners && listeners.length) {
          if (this._listens(type2, _fn, context) !== false) {
            return true;
          }
        }
        if (propagate) {
          for (var id2 in this._eventParents) {
            if (this._eventParents[id2].listens(type2, fn, context, propagate)) {
              return true;
            }
          }
        }
        return false;
      },
      // returns the index (number) or false
      _listens: function(type2, fn, context) {
        if (!this._events) {
          return false;
        }
        var listeners = this._events[type2] || [];
        if (!fn) {
          return !!listeners.length;
        }
        if (context === this) {
          context = void 0;
        }
        for (var i = 0, len = listeners.length; i < len; i++) {
          if (listeners[i].fn === fn && listeners[i].ctx === context) {
            return i;
          }
        }
        return false;
      },
      // @method once(…): this
      // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
      once: function(types, fn, context) {
        if (typeof types === "object") {
          for (var type2 in types) {
            this._on(type2, types[type2], fn, true);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            this._on(types[i], fn, context, true);
          }
        }
        return this;
      },
      // @method addEventParent(obj: Evented): this
      // Adds an event parent - an `Evented` that will receive propagated events
      addEventParent: function(obj) {
        this._eventParents = this._eventParents || {};
        this._eventParents[stamp(obj)] = obj;
        return this;
      },
      // @method removeEventParent(obj: Evented): this
      // Removes an event parent, so it will stop receiving propagated events
      removeEventParent: function(obj) {
        if (this._eventParents) {
          delete this._eventParents[stamp(obj)];
        }
        return this;
      },
      _propagateEvent: function(e2) {
        for (var id2 in this._eventParents) {
          this._eventParents[id2].fire(e2.type, extend({
            layer: e2.target,
            propagatedFrom: e2.target
          }, e2), true);
        }
      }
    };
    Events.addEventListener = Events.on;
    Events.removeEventListener = Events.clearAllEventListeners = Events.off;
    Events.addOneTimeEventListener = Events.once;
    Events.fireEvent = Events.fire;
    Events.hasEventListeners = Events.listens;
    var Evented = Class.extend(Events);
    function Point(x2, y2, round2) {
      this.x = round2 ? Math.round(x2) : x2;
      this.y = round2 ? Math.round(y2) : y2;
    }
    var trunc = Math.trunc || function(v2) {
      return v2 > 0 ? Math.floor(v2) : Math.ceil(v2);
    };
    Point.prototype = {
      // @method clone(): Point
      // Returns a copy of the current point.
      clone: function() {
        return new Point(this.x, this.y);
      },
      // @method add(otherPoint: Point): Point
      // Returns the result of addition of the current and the given points.
      add: function(point2) {
        return this.clone()._add(toPoint(point2));
      },
      _add: function(point2) {
        this.x += point2.x;
        this.y += point2.y;
        return this;
      },
      // @method subtract(otherPoint: Point): Point
      // Returns the result of subtraction of the given point from the current.
      subtract: function(point2) {
        return this.clone()._subtract(toPoint(point2));
      },
      _subtract: function(point2) {
        this.x -= point2.x;
        this.y -= point2.y;
        return this;
      },
      // @method divideBy(num: Number): Point
      // Returns the result of division of the current point by the given number.
      divideBy: function(num) {
        return this.clone()._divideBy(num);
      },
      _divideBy: function(num) {
        this.x /= num;
        this.y /= num;
        return this;
      },
      // @method multiplyBy(num: Number): Point
      // Returns the result of multiplication of the current point by the given number.
      multiplyBy: function(num) {
        return this.clone()._multiplyBy(num);
      },
      _multiplyBy: function(num) {
        this.x *= num;
        this.y *= num;
        return this;
      },
      // @method scaleBy(scale: Point): Point
      // Multiply each coordinate of the current point by each coordinate of
      // `scale`. In linear algebra terms, multiply the point by the
      // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
      // defined by `scale`.
      scaleBy: function(point2) {
        return new Point(this.x * point2.x, this.y * point2.y);
      },
      // @method unscaleBy(scale: Point): Point
      // Inverse of `scaleBy`. Divide each coordinate of the current point by
      // each coordinate of `scale`.
      unscaleBy: function(point2) {
        return new Point(this.x / point2.x, this.y / point2.y);
      },
      // @method round(): Point
      // Returns a copy of the current point with rounded coordinates.
      round: function() {
        return this.clone()._round();
      },
      _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      // @method floor(): Point
      // Returns a copy of the current point with floored coordinates (rounded down).
      floor: function() {
        return this.clone()._floor();
      },
      _floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      // @method ceil(): Point
      // Returns a copy of the current point with ceiled coordinates (rounded up).
      ceil: function() {
        return this.clone()._ceil();
      },
      _ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      // @method trunc(): Point
      // Returns a copy of the current point with truncated coordinates (rounded towards zero).
      trunc: function() {
        return this.clone()._trunc();
      },
      _trunc: function() {
        this.x = trunc(this.x);
        this.y = trunc(this.y);
        return this;
      },
      // @method distanceTo(otherPoint: Point): Number
      // Returns the cartesian distance between the current and the given points.
      distanceTo: function(point2) {
        point2 = toPoint(point2);
        var x2 = point2.x - this.x, y2 = point2.y - this.y;
        return Math.sqrt(x2 * x2 + y2 * y2);
      },
      // @method equals(otherPoint: Point): Boolean
      // Returns `true` if the given point has the same coordinates.
      equals: function(point2) {
        point2 = toPoint(point2);
        return point2.x === this.x && point2.y === this.y;
      },
      // @method contains(otherPoint: Point): Boolean
      // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
      contains: function(point2) {
        point2 = toPoint(point2);
        return Math.abs(point2.x) <= Math.abs(this.x) && Math.abs(point2.y) <= Math.abs(this.y);
      },
      // @method toString(): String
      // Returns a string representation of the point for debugging purposes.
      toString: function() {
        return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
      }
    };
    function toPoint(x2, y2, round2) {
      if (x2 instanceof Point) {
        return x2;
      }
      if (isArray2(x2)) {
        return new Point(x2[0], x2[1]);
      }
      if (x2 === void 0 || x2 === null) {
        return x2;
      }
      if (typeof x2 === "object" && "x" in x2 && "y" in x2) {
        return new Point(x2.x, x2.y);
      }
      return new Point(x2, y2, round2);
    }
    function Bounds(a, b) {
      if (!a) {
        return;
      }
      var points2 = b ? [a, b] : a;
      for (var i = 0, len = points2.length; i < len; i++) {
        this.extend(points2[i]);
      }
    }
    Bounds.prototype = {
      // @method extend(point: Point): this
      // Extends the bounds to contain the given point.
      // @alternative
      // @method extend(otherBounds: Bounds): this
      // Extend the bounds to contain the given bounds
      extend: function(obj) {
        var min2, max2;
        if (!obj) {
          return this;
        }
        if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
          min2 = max2 = toPoint(obj);
        } else {
          obj = toBounds2(obj);
          min2 = obj.min;
          max2 = obj.max;
          if (!min2 || !max2) {
            return this;
          }
        }
        if (!this.min && !this.max) {
          this.min = min2.clone();
          this.max = max2.clone();
        } else {
          this.min.x = Math.min(min2.x, this.min.x);
          this.max.x = Math.max(max2.x, this.max.x);
          this.min.y = Math.min(min2.y, this.min.y);
          this.max.y = Math.max(max2.y, this.max.y);
        }
        return this;
      },
      // @method getCenter(round?: Boolean): Point
      // Returns the center point of the bounds.
      getCenter: function(round2) {
        return toPoint(
          (this.min.x + this.max.x) / 2,
          (this.min.y + this.max.y) / 2,
          round2
        );
      },
      // @method getBottomLeft(): Point
      // Returns the bottom-left point of the bounds.
      getBottomLeft: function() {
        return toPoint(this.min.x, this.max.y);
      },
      // @method getTopRight(): Point
      // Returns the top-right point of the bounds.
      getTopRight: function() {
        return toPoint(this.max.x, this.min.y);
      },
      // @method getTopLeft(): Point
      // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
      getTopLeft: function() {
        return this.min;
      },
      // @method getBottomRight(): Point
      // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
      getBottomRight: function() {
        return this.max;
      },
      // @method getSize(): Point
      // Returns the size of the given bounds
      getSize: function() {
        return this.max.subtract(this.min);
      },
      // @method contains(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains(point: Point): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(obj) {
        var min, max2;
        if (typeof obj[0] === "number" || obj instanceof Point) {
          obj = toPoint(obj);
        } else {
          obj = toBounds2(obj);
        }
        if (obj instanceof Bounds) {
          min = obj.min;
          max2 = obj.max;
        } else {
          min = max2 = obj;
        }
        return min.x >= this.min.x && max2.x <= this.max.x && min.y >= this.min.y && max2.y <= this.max.y;
      },
      // @method intersects(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds
      // intersect if they have at least one point in common.
      intersects: function(bounds) {
        bounds = toBounds2(bounds);
        var min = this.min, max2 = this.max, min2 = bounds.min, max22 = bounds.max, xIntersects = max22.x >= min.x && min2.x <= max2.x, yIntersects = max22.y >= min.y && min2.y <= max2.y;
        return xIntersects && yIntersects;
      },
      // @method overlaps(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds
      // overlap if their intersection is an area.
      overlaps: function(bounds) {
        bounds = toBounds2(bounds);
        var min = this.min, max2 = this.max, min2 = bounds.min, max22 = bounds.max, xOverlaps = max22.x > min.x && min2.x < max2.x, yOverlaps = max22.y > min.y && min2.y < max2.y;
        return xOverlaps && yOverlaps;
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this.min && this.max);
      },
      // @method pad(bufferRatio: Number): Bounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(bufferRatio) {
        var min = this.min, max2 = this.max, heightBuffer = Math.abs(min.x - max2.x) * bufferRatio, widthBuffer = Math.abs(min.y - max2.y) * bufferRatio;
        return toBounds2(
          toPoint(min.x - heightBuffer, min.y - widthBuffer),
          toPoint(max2.x + heightBuffer, max2.y + widthBuffer)
        );
      },
      // @method equals(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle is equivalent to the given bounds.
      equals: function(bounds) {
        if (!bounds) {
          return false;
        }
        bounds = toBounds2(bounds);
        return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
      }
    };
    function toBounds2(a, b) {
      if (!a || a instanceof Bounds) {
        return a;
      }
      return new Bounds(a, b);
    }
    function LatLngBounds(corner1, corner2) {
      if (!corner1) {
        return;
      }
      var latlngs = corner2 ? [corner1, corner2] : corner1;
      for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
      }
    }
    LatLngBounds.prototype = {
      // @method extend(latlng: LatLng): this
      // Extend the bounds to contain the given point
      // @alternative
      // @method extend(otherBounds: LatLngBounds): this
      // Extend the bounds to contain the given bounds
      extend: function(obj) {
        var sw = this._southWest, ne2 = this._northEast, sw2, ne22;
        if (obj instanceof LatLng) {
          sw2 = obj;
          ne22 = obj;
        } else if (obj instanceof LatLngBounds) {
          sw2 = obj._southWest;
          ne22 = obj._northEast;
          if (!sw2 || !ne22) {
            return this;
          }
        } else {
          return obj ? this.extend(toLatLng2(obj) || toLatLngBounds(obj)) : this;
        }
        if (!sw && !ne2) {
          this._southWest = new LatLng(sw2.lat, sw2.lng);
          this._northEast = new LatLng(ne22.lat, ne22.lng);
        } else {
          sw.lat = Math.min(sw2.lat, sw.lat);
          sw.lng = Math.min(sw2.lng, sw.lng);
          ne2.lat = Math.max(ne22.lat, ne2.lat);
          ne2.lng = Math.max(ne22.lng, ne2.lng);
        }
        return this;
      },
      // @method pad(bufferRatio: Number): LatLngBounds
      // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
      // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
      // Negative values will retract the bounds.
      pad: function(bufferRatio) {
        var sw = this._southWest, ne2 = this._northEast, heightBuffer = Math.abs(sw.lat - ne2.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne2.lng) * bufferRatio;
        return new LatLngBounds(
          new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
          new LatLng(ne2.lat + heightBuffer, ne2.lng + widthBuffer)
        );
      },
      // @method getCenter(): LatLng
      // Returns the center point of the bounds.
      getCenter: function() {
        return new LatLng(
          (this._southWest.lat + this._northEast.lat) / 2,
          (this._southWest.lng + this._northEast.lng) / 2
        );
      },
      // @method getSouthWest(): LatLng
      // Returns the south-west point of the bounds.
      getSouthWest: function() {
        return this._southWest;
      },
      // @method getNorthEast(): LatLng
      // Returns the north-east point of the bounds.
      getNorthEast: function() {
        return this._northEast;
      },
      // @method getNorthWest(): LatLng
      // Returns the north-west point of the bounds.
      getNorthWest: function() {
        return new LatLng(this.getNorth(), this.getWest());
      },
      // @method getSouthEast(): LatLng
      // Returns the south-east point of the bounds.
      getSouthEast: function() {
        return new LatLng(this.getSouth(), this.getEast());
      },
      // @method getWest(): Number
      // Returns the west longitude of the bounds
      getWest: function() {
        return this._southWest.lng;
      },
      // @method getSouth(): Number
      // Returns the south latitude of the bounds
      getSouth: function() {
        return this._southWest.lat;
      },
      // @method getEast(): Number
      // Returns the east longitude of the bounds
      getEast: function() {
        return this._northEast.lng;
      },
      // @method getNorth(): Number
      // Returns the north latitude of the bounds
      getNorth: function() {
        return this._northEast.lat;
      },
      // @method contains(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains (latlng: LatLng): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function(obj) {
        if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
          obj = toLatLng2(obj);
        } else {
          obj = toLatLngBounds(obj);
        }
        var sw = this._southWest, ne2 = this._northEast, sw2, ne22;
        if (obj instanceof LatLngBounds) {
          sw2 = obj.getSouthWest();
          ne22 = obj.getNorthEast();
        } else {
          sw2 = ne22 = obj;
        }
        return sw2.lat >= sw.lat && ne22.lat <= ne2.lat && sw2.lng >= sw.lng && ne22.lng <= ne2.lng;
      },
      // @method intersects(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
      intersects: function(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest, ne2 = this._northEast, sw2 = bounds.getSouthWest(), ne22 = bounds.getNorthEast(), latIntersects = ne22.lat >= sw.lat && sw2.lat <= ne2.lat, lngIntersects = ne22.lng >= sw.lng && sw2.lng <= ne2.lng;
        return latIntersects && lngIntersects;
      },
      // @method overlaps(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
      overlaps: function(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest, ne2 = this._northEast, sw2 = bounds.getSouthWest(), ne22 = bounds.getNorthEast(), latOverlaps = ne22.lat > sw.lat && sw2.lat < ne2.lat, lngOverlaps = ne22.lng > sw.lng && sw2.lng < ne2.lng;
        return latOverlaps && lngOverlaps;
      },
      // @method toBBoxString(): String
      // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
      toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      },
      // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
      // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(bounds, maxMargin) {
        if (!bounds) {
          return false;
        }
        bounds = toLatLngBounds(bounds);
        return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function() {
        return !!(this._southWest && this._northEast);
      }
    };
    function toLatLngBounds(a, b) {
      if (a instanceof LatLngBounds) {
        return a;
      }
      return new LatLngBounds(a, b);
    }
    function LatLng(lat, lng, alt) {
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
      }
      this.lat = +lat;
      this.lng = +lng;
      if (alt !== void 0) {
        this.alt = +alt;
      }
    }
    LatLng.prototype = {
      // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
      // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
      equals: function(obj, maxMargin) {
        if (!obj) {
          return false;
        }
        obj = toLatLng2(obj);
        var margin = Math.max(
          Math.abs(this.lat - obj.lat),
          Math.abs(this.lng - obj.lng)
        );
        return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
      },
      // @method toString(): String
      // Returns a string representation of the point (for debugging purposes).
      toString: function(precision) {
        return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
      },
      // @method distanceTo(otherLatLng: LatLng): Number
      // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
      distanceTo: function(other) {
        return Earth.distance(this, toLatLng2(other));
      },
      // @method wrap(): LatLng
      // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
      wrap: function() {
        return Earth.wrapLatLng(this);
      },
      // @method toBounds(sizeInMeters: Number): LatLngBounds
      // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
      toBounds: function(sizeInMeters) {
        var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
        return toLatLngBounds(
          [this.lat - latAccuracy, this.lng - lngAccuracy],
          [this.lat + latAccuracy, this.lng + lngAccuracy]
        );
      },
      clone: function() {
        return new LatLng(this.lat, this.lng, this.alt);
      }
    };
    function toLatLng2(a, b, c) {
      if (a instanceof LatLng) {
        return a;
      }
      if (isArray2(a) && typeof a[0] !== "object") {
        if (a.length === 3) {
          return new LatLng(a[0], a[1], a[2]);
        }
        if (a.length === 2) {
          return new LatLng(a[0], a[1]);
        }
        return null;
      }
      if (a === void 0 || a === null) {
        return a;
      }
      if (typeof a === "object" && "lat" in a) {
        return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
      }
      if (b === void 0) {
        return null;
      }
      return new LatLng(a, b, c);
    }
    var CRS = {
      // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
      // Projects geographical coordinates into pixel coordinates for a given zoom.
      latLngToPoint: function(latlng, zoom2) {
        var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
        return this.transformation._transform(projectedPoint, scale2);
      },
      // @method pointToLatLng(point: Point, zoom: Number): LatLng
      // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
      // zoom into geographical coordinates.
      pointToLatLng: function(point2, zoom2) {
        var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point2, scale2);
        return this.projection.unproject(untransformedPoint);
      },
      // @method project(latlng: LatLng): Point
      // Projects geographical coordinates into coordinates in units accepted for
      // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
      project: function(latlng) {
        return this.projection.project(latlng);
      },
      // @method unproject(point: Point): LatLng
      // Given a projected coordinate returns the corresponding LatLng.
      // The inverse of `project`.
      unproject: function(point2) {
        return this.projection.unproject(point2);
      },
      // @method scale(zoom: Number): Number
      // Returns the scale used when transforming projected coordinates into
      // pixel coordinates for a particular zoom. For example, it returns
      // `256 * 2^zoom` for Mercator-based CRS.
      scale: function(zoom2) {
        return 256 * Math.pow(2, zoom2);
      },
      // @method zoom(scale: Number): Number
      // Inverse of `scale()`, returns the zoom level corresponding to a scale
      // factor of `scale`.
      zoom: function(scale2) {
        return Math.log(scale2 / 256) / Math.LN2;
      },
      // @method getProjectedBounds(zoom: Number): Bounds
      // Returns the projection's bounds scaled and transformed for the provided `zoom`.
      getProjectedBounds: function(zoom2) {
        if (this.infinite) {
          return null;
        }
        var b = this.projection.bounds, s2 = this.scale(zoom2), min = this.transformation.transform(b.min, s2), max2 = this.transformation.transform(b.max, s2);
        return new Bounds(min, max2);
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates.
      // @property code: String
      // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
      //
      // @property wrapLng: Number[]
      // An array of two numbers defining whether the longitude (horizontal) coordinate
      // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
      // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
      //
      // @property wrapLat: Number[]
      // Like `wrapLng`, but for the latitude (vertical) axis.
      // wrapLng: [min, max],
      // wrapLat: [min, max],
      // @property infinite: Boolean
      // If true, the coordinate space will be unbounded (infinite in both axes)
      infinite: false,
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where lat and lng has been wrapped according to the
      // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
      wrapLatLng: function(latlng) {
        var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
        return new LatLng(lat, lng, alt);
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring
      // that its center is within the CRS's bounds.
      // Only accepts actual `L.LatLngBounds` instances, not arrays.
      wrapLatLngBounds: function(bounds) {
        var center2 = bounds.getCenter(), newCenter = this.wrapLatLng(center2), latShift = center2.lat - newCenter.lat, lngShift = center2.lng - newCenter.lng;
        if (latShift === 0 && lngShift === 0) {
          return bounds;
        }
        var sw = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne2.lat - latShift, ne2.lng - lngShift);
        return new LatLngBounds(newSw, newNe);
      }
    };
    var Earth = extend({}, CRS, {
      wrapLng: [-180, 180],
      // Mean Earth Radius, as recommended for use by
      // the International Union of Geodesy and Geophysics,
      // see https://rosettacode.org/wiki/Haversine_formula
      R: 6371e3,
      // distance between two geographical points using spherical law of cosines approximation
      distance: function(latlng1, latlng2) {
        var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return this.R * c;
      }
    });
    var earthRadius2 = 6378137;
    var SphericalMercator = {
      R: earthRadius2,
      MAX_LATITUDE: 85.0511287798,
      project: function(latlng) {
        var d = Math.PI / 180, max2 = this.MAX_LATITUDE, lat = Math.max(Math.min(max2, latlng.lat), -max2), sin = Math.sin(lat * d);
        return new Point(
          this.R * latlng.lng * d,
          this.R * Math.log((1 + sin) / (1 - sin)) / 2
        );
      },
      unproject: function(point2) {
        var d = 180 / Math.PI;
        return new LatLng(
          (2 * Math.atan(Math.exp(point2.y / this.R)) - Math.PI / 2) * d,
          point2.x * d / this.R
        );
      },
      bounds: function() {
        var d = earthRadius2 * Math.PI;
        return new Bounds([-d, -d], [d, d]);
      }()
    };
    function Transformation(a, b, c, d) {
      if (isArray2(a)) {
        this._a = a[0];
        this._b = a[1];
        this._c = a[2];
        this._d = a[3];
        return;
      }
      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
    }
    Transformation.prototype = {
      // @method transform(point: Point, scale?: Number): Point
      // Returns a transformed point, optionally multiplied by the given scale.
      // Only accepts actual `L.Point` instances, not arrays.
      transform: function(point2, scale2) {
        return this._transform(point2.clone(), scale2);
      },
      // destructive transform (faster)
      _transform: function(point2, scale2) {
        scale2 = scale2 || 1;
        point2.x = scale2 * (this._a * point2.x + this._b);
        point2.y = scale2 * (this._c * point2.y + this._d);
        return point2;
      },
      // @method untransform(point: Point, scale?: Number): Point
      // Returns the reverse transformation of the given point, optionally divided
      // by the given scale. Only accepts actual `L.Point` instances, not arrays.
      untransform: function(point2, scale2) {
        scale2 = scale2 || 1;
        return new Point(
          (point2.x / scale2 - this._b) / this._a,
          (point2.y / scale2 - this._d) / this._c
        );
      }
    };
    function toTransformation(a, b, c, d) {
      return new Transformation(a, b, c, d);
    }
    var EPSG3857 = extend({}, Earth, {
      code: "EPSG:3857",
      projection: SphericalMercator,
      transformation: function() {
        var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
        return toTransformation(scale2, 0.5, -scale2, 0.5);
      }()
    });
    var EPSG900913 = extend({}, EPSG3857, {
      code: "EPSG:900913"
    });
    function svgCreate(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function pointsToPath(rings, closed) {
      var str = "", i, j, len, len2, points2, p2;
      for (i = 0, len = rings.length; i < len; i++) {
        points2 = rings[i];
        for (j = 0, len2 = points2.length; j < len2; j++) {
          p2 = points2[j];
          str += (j ? "L" : "M") + p2.x + " " + p2.y;
        }
        str += closed ? Browser.svg ? "z" : "x" : "";
      }
      return str || "M0 0";
    }
    var style = document.documentElement.style;
    var ie2 = "ActiveXObject" in window;
    var ielt9 = ie2 && !document.addEventListener;
    var edge = "msLaunchUri" in navigator && !("documentMode" in document);
    var webkit = userAgentContains("webkit");
    var android = userAgentContains("android");
    var android23 = userAgentContains("android 2") || userAgentContains("android 3");
    var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
    var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
    var opera = !!window.opera;
    var chrome = !edge && userAgentContains("chrome");
    var gecko = userAgentContains("gecko") && !webkit && !opera && !ie2;
    var safari = !chrome && userAgentContains("safari");
    var phantom = userAgentContains("phantom");
    var opera12 = "OTransition" in style;
    var win = navigator.platform.indexOf("Win") === 0;
    var ie3d = ie2 && "transition" in style;
    var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
    var gecko3d = "MozPerspective" in style;
    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
    var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
    var mobileWebkit = mobile && webkit;
    var mobileWebkit3d = mobile && webkit3d;
    var msPointer = !window.PointerEvent && window.MSPointerEvent;
    var pointer = !!(window.PointerEvent || msPointer);
    var touchNative = "ontouchstart" in window || !!window.TouchEvent;
    var touch = !window.L_NO_TOUCH && (touchNative || pointer);
    var mobileOpera = mobile && opera;
    var mobileGecko = mobile && gecko;
    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
    var passiveEvents = function() {
      var supportsPassiveOption = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function() {
            supportsPassiveOption = true;
          }
        });
        window.addEventListener("testPassiveEventSupport", falseFn, opts);
        window.removeEventListener("testPassiveEventSupport", falseFn, opts);
      } catch (e2) {
      }
      return supportsPassiveOption;
    }();
    var canvas$1 = function() {
      return !!document.createElement("canvas").getContext;
    }();
    var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
    var inlineSvg = !!svg$1 && function() {
      var div = document.createElement("div");
      div.innerHTML = "<svg/>";
      return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
    }();
    var vml = !svg$1 && function() {
      try {
        var div = document.createElement("div");
        div.innerHTML = '<v:shape adj="1"/>';
        var shape = div.firstChild;
        shape.style.behavior = "url(#default#VML)";
        return shape && typeof shape.adj === "object";
      } catch (e2) {
        return false;
      }
    }();
    var mac = navigator.platform.indexOf("Mac") === 0;
    var linux = navigator.platform.indexOf("Linux") === 0;
    function userAgentContains(str) {
      return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
    }
    var Browser = {
      ie: ie2,
      ielt9,
      edge,
      webkit,
      android,
      android23,
      androidStock,
      opera,
      chrome,
      gecko,
      safari,
      phantom,
      opera12,
      win,
      ie3d,
      webkit3d,
      gecko3d,
      any3d,
      mobile,
      mobileWebkit,
      mobileWebkit3d,
      msPointer,
      pointer,
      touch,
      touchNative,
      mobileOpera,
      mobileGecko,
      retina,
      passiveEvents,
      canvas: canvas$1,
      svg: svg$1,
      vml,
      inlineSvg,
      mac,
      linux
    };
    var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
    var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
    var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
    var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
    var pEvent = {
      touchstart: POINTER_DOWN,
      touchmove: POINTER_MOVE,
      touchend: POINTER_UP,
      touchcancel: POINTER_CANCEL
    };
    var handle = {
      touchstart: _onPointerStart,
      touchmove: _handlePointer,
      touchend: _handlePointer,
      touchcancel: _handlePointer
    };
    var _pointers = {};
    var _pointerDocListener = false;
    function addPointerListener(obj, type2, handler) {
      if (type2 === "touchstart") {
        _addPointerDocListener();
      }
      if (!handle[type2]) {
        console.warn("wrong event specified:", type2);
        return falseFn;
      }
      handler = handle[type2].bind(this, handler);
      obj.addEventListener(pEvent[type2], handler, false);
      return handler;
    }
    function removePointerListener(obj, type2, handler) {
      if (!pEvent[type2]) {
        console.warn("wrong event specified:", type2);
        return;
      }
      obj.removeEventListener(pEvent[type2], handler, false);
    }
    function _globalPointerDown(e2) {
      _pointers[e2.pointerId] = e2;
    }
    function _globalPointerMove(e2) {
      if (_pointers[e2.pointerId]) {
        _pointers[e2.pointerId] = e2;
      }
    }
    function _globalPointerUp(e2) {
      delete _pointers[e2.pointerId];
    }
    function _addPointerDocListener() {
      if (!_pointerDocListener) {
        document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
        document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
        document.addEventListener(POINTER_UP, _globalPointerUp, true);
        document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
        _pointerDocListener = true;
      }
    }
    function _handlePointer(handler, e2) {
      if (e2.pointerType === (e2.MSPOINTER_TYPE_MOUSE || "mouse")) {
        return;
      }
      e2.touches = [];
      for (var i in _pointers) {
        e2.touches.push(_pointers[i]);
      }
      e2.changedTouches = [e2];
      handler(e2);
    }
    function _onPointerStart(handler, e2) {
      if (e2.MSPOINTER_TYPE_TOUCH && e2.pointerType === e2.MSPOINTER_TYPE_TOUCH) {
        preventDefault(e2);
      }
      _handlePointer(handler, e2);
    }
    function makeDblclick(event) {
      var newEvent = {}, prop, i;
      for (i in event) {
        prop = event[i];
        newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
      }
      event = newEvent;
      newEvent.type = "dblclick";
      newEvent.detail = 2;
      newEvent.isTrusted = false;
      newEvent._simulated = true;
      return newEvent;
    }
    var delay = 200;
    function addDoubleTapListener(obj, handler) {
      obj.addEventListener("dblclick", handler);
      var last = 0, detail;
      function simDblclick(e2) {
        if (e2.detail !== 1) {
          detail = e2.detail;
          return;
        }
        if (e2.pointerType === "mouse" || e2.sourceCapabilities && !e2.sourceCapabilities.firesTouchEvents) {
          return;
        }
        var path = getPropagationPath(e2);
        if (path.some(function(el2) {
          return el2 instanceof HTMLLabelElement && el2.attributes.for;
        }) && !path.some(function(el2) {
          return el2 instanceof HTMLInputElement || el2 instanceof HTMLSelectElement;
        })) {
          return;
        }
        var now = Date.now();
        if (now - last <= delay) {
          detail++;
          if (detail === 2) {
            handler(makeDblclick(e2));
          }
        } else {
          detail = 1;
        }
        last = now;
      }
      obj.addEventListener("click", simDblclick);
      return {
        dblclick: handler,
        simDblclick
      };
    }
    function removeDoubleTapListener(obj, handlers) {
      obj.removeEventListener("dblclick", handlers.dblclick);
      obj.removeEventListener("click", handlers.simDblclick);
    }
    var TRANSFORM = testProp(
      ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
    );
    var TRANSITION = testProp(
      ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
    );
    var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
    function get(id2) {
      return typeof id2 === "string" ? document.getElementById(id2) : id2;
    }
    function getStyle(el2, style2) {
      var value = el2.style[style2] || el2.currentStyle && el2.currentStyle[style2];
      if ((!value || value === "auto") && document.defaultView) {
        var css = document.defaultView.getComputedStyle(el2, null);
        value = css ? css[style2] : null;
      }
      return value === "auto" ? null : value;
    }
    function create$1(tagName, className, container) {
      var el2 = document.createElement(tagName);
      el2.className = className || "";
      if (container) {
        container.appendChild(el2);
      }
      return el2;
    }
    function remove(el2) {
      var parent = el2.parentNode;
      if (parent) {
        parent.removeChild(el2);
      }
    }
    function empty(el2) {
      while (el2.firstChild) {
        el2.removeChild(el2.firstChild);
      }
    }
    function toFront(el2) {
      var parent = el2.parentNode;
      if (parent && parent.lastChild !== el2) {
        parent.appendChild(el2);
      }
    }
    function toBack(el2) {
      var parent = el2.parentNode;
      if (parent && parent.firstChild !== el2) {
        parent.insertBefore(el2, parent.firstChild);
      }
    }
    function hasClass(el2, name) {
      if (el2.classList !== void 0) {
        return el2.classList.contains(name);
      }
      var className = getClass(el2);
      return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
    }
    function addClass(el2, name) {
      if (el2.classList !== void 0) {
        var classes = splitWords(name);
        for (var i = 0, len = classes.length; i < len; i++) {
          el2.classList.add(classes[i]);
        }
      } else if (!hasClass(el2, name)) {
        var className = getClass(el2);
        setClass(el2, (className ? className + " " : "") + name);
      }
    }
    function removeClass(el2, name) {
      if (el2.classList !== void 0) {
        el2.classList.remove(name);
      } else {
        setClass(el2, trim((" " + getClass(el2) + " ").replace(" " + name + " ", " ")));
      }
    }
    function setClass(el2, name) {
      if (el2.className.baseVal === void 0) {
        el2.className = name;
      } else {
        el2.className.baseVal = name;
      }
    }
    function getClass(el2) {
      if (el2.correspondingElement) {
        el2 = el2.correspondingElement;
      }
      return el2.className.baseVal === void 0 ? el2.className : el2.className.baseVal;
    }
    function setOpacity(el2, value) {
      if ("opacity" in el2.style) {
        el2.style.opacity = value;
      } else if ("filter" in el2.style) {
        _setOpacityIE(el2, value);
      }
    }
    function _setOpacityIE(el2, value) {
      var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
      try {
        filter = el2.filters.item(filterName);
      } catch (e2) {
        if (value === 1) {
          return;
        }
      }
      value = Math.round(value * 100);
      if (filter) {
        filter.Enabled = value !== 100;
        filter.Opacity = value;
      } else {
        el2.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
      }
    }
    function testProp(props) {
      var style2 = document.documentElement.style;
      for (var i = 0; i < props.length; i++) {
        if (props[i] in style2) {
          return props[i];
        }
      }
      return false;
    }
    function setTransform(el2, offset, scale2) {
      var pos = offset || new Point(0, 0);
      el2.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
    }
    function setPosition(el2, point2) {
      el2._leaflet_pos = point2;
      if (Browser.any3d) {
        setTransform(el2, point2);
      } else {
        el2.style.left = point2.x + "px";
        el2.style.top = point2.y + "px";
      }
    }
    function getPosition(el2) {
      return el2._leaflet_pos || new Point(0, 0);
    }
    var disableTextSelection;
    var enableTextSelection;
    var _userSelect;
    if ("onselectstart" in document) {
      disableTextSelection = function() {
        on(window, "selectstart", preventDefault);
      };
      enableTextSelection = function() {
        off(window, "selectstart", preventDefault);
      };
    } else {
      var userSelectProperty = testProp(
        ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
      );
      disableTextSelection = function() {
        if (userSelectProperty) {
          var style2 = document.documentElement.style;
          _userSelect = style2[userSelectProperty];
          style2[userSelectProperty] = "none";
        }
      };
      enableTextSelection = function() {
        if (userSelectProperty) {
          document.documentElement.style[userSelectProperty] = _userSelect;
          _userSelect = void 0;
        }
      };
    }
    function disableImageDrag() {
      on(window, "dragstart", preventDefault);
    }
    function enableImageDrag() {
      off(window, "dragstart", preventDefault);
    }
    var _outlineElement, _outlineStyle;
    function preventOutline(element) {
      while (element.tabIndex === -1) {
        element = element.parentNode;
      }
      if (!element.style) {
        return;
      }
      restoreOutline();
      _outlineElement = element;
      _outlineStyle = element.style.outlineStyle;
      element.style.outlineStyle = "none";
      on(window, "keydown", restoreOutline);
    }
    function restoreOutline() {
      if (!_outlineElement) {
        return;
      }
      _outlineElement.style.outlineStyle = _outlineStyle;
      _outlineElement = void 0;
      _outlineStyle = void 0;
      off(window, "keydown", restoreOutline);
    }
    function getSizedParentNode(element) {
      do {
        element = element.parentNode;
      } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
      return element;
    }
    function getScale(element) {
      var rect = element.getBoundingClientRect();
      return {
        x: rect.width / element.offsetWidth || 1,
        y: rect.height / element.offsetHeight || 1,
        boundingClientRect: rect
      };
    }
    var DomUtil = {
      __proto__: null,
      TRANSFORM,
      TRANSITION,
      TRANSITION_END,
      get,
      getStyle,
      create: create$1,
      remove,
      empty,
      toFront,
      toBack,
      hasClass,
      addClass,
      removeClass,
      setClass,
      getClass,
      setOpacity,
      testProp,
      setTransform,
      setPosition,
      getPosition,
      get disableTextSelection() {
        return disableTextSelection;
      },
      get enableTextSelection() {
        return enableTextSelection;
      },
      disableImageDrag,
      enableImageDrag,
      preventOutline,
      restoreOutline,
      getSizedParentNode,
      getScale
    };
    function on(obj, types, fn, context) {
      if (types && typeof types === "object") {
        for (var type2 in types) {
          addOne(obj, type2, types[type2], fn);
        }
      } else {
        types = splitWords(types);
        for (var i = 0, len = types.length; i < len; i++) {
          addOne(obj, types[i], fn, context);
        }
      }
      return this;
    }
    var eventsKey = "_leaflet_events";
    function off(obj, types, fn, context) {
      if (arguments.length === 1) {
        batchRemove(obj);
        delete obj[eventsKey];
      } else if (types && typeof types === "object") {
        for (var type2 in types) {
          removeOne(obj, type2, types[type2], fn);
        }
      } else {
        types = splitWords(types);
        if (arguments.length === 2) {
          batchRemove(obj, function(type3) {
            return indexOf3(types, type3) !== -1;
          });
        } else {
          for (var i = 0, len = types.length; i < len; i++) {
            removeOne(obj, types[i], fn, context);
          }
        }
      }
      return this;
    }
    function batchRemove(obj, filterFn) {
      for (var id2 in obj[eventsKey]) {
        var type2 = id2.split(/\d/)[0];
        if (!filterFn || filterFn(type2)) {
          removeOne(obj, type2, null, null, id2);
        }
      }
    }
    var mouseSubst = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel" in window) && "mousewheel"
    };
    function addOne(obj, type2, fn, context) {
      var id2 = type2 + stamp(fn) + (context ? "_" + stamp(context) : "");
      if (obj[eventsKey] && obj[eventsKey][id2]) {
        return this;
      }
      var handler = function(e2) {
        return fn.call(context || obj, e2 || window.event);
      };
      var originalHandler = handler;
      if (!Browser.touchNative && Browser.pointer && type2.indexOf("touch") === 0) {
        handler = addPointerListener(obj, type2, handler);
      } else if (Browser.touch && type2 === "dblclick") {
        handler = addDoubleTapListener(obj, handler);
      } else if ("addEventListener" in obj) {
        if (type2 === "touchstart" || type2 === "touchmove" || type2 === "wheel" || type2 === "mousewheel") {
          obj.addEventListener(mouseSubst[type2] || type2, handler, Browser.passiveEvents ? { passive: false } : false);
        } else if (type2 === "mouseenter" || type2 === "mouseleave") {
          handler = function(e2) {
            e2 = e2 || window.event;
            if (isExternalTarget(obj, e2)) {
              originalHandler(e2);
            }
          };
          obj.addEventListener(mouseSubst[type2], handler, false);
        } else {
          obj.addEventListener(type2, originalHandler, false);
        }
      } else {
        obj.attachEvent("on" + type2, handler);
      }
      obj[eventsKey] = obj[eventsKey] || {};
      obj[eventsKey][id2] = handler;
    }
    function removeOne(obj, type2, fn, context, id2) {
      id2 = id2 || type2 + stamp(fn) + (context ? "_" + stamp(context) : "");
      var handler = obj[eventsKey] && obj[eventsKey][id2];
      if (!handler) {
        return this;
      }
      if (!Browser.touchNative && Browser.pointer && type2.indexOf("touch") === 0) {
        removePointerListener(obj, type2, handler);
      } else if (Browser.touch && type2 === "dblclick") {
        removeDoubleTapListener(obj, handler);
      } else if ("removeEventListener" in obj) {
        obj.removeEventListener(mouseSubst[type2] || type2, handler, false);
      } else {
        obj.detachEvent("on" + type2, handler);
      }
      obj[eventsKey][id2] = null;
    }
    function stopPropagation(e2) {
      if (e2.stopPropagation) {
        e2.stopPropagation();
      } else if (e2.originalEvent) {
        e2.originalEvent._stopped = true;
      } else {
        e2.cancelBubble = true;
      }
      return this;
    }
    function disableScrollPropagation(el2) {
      addOne(el2, "wheel", stopPropagation);
      return this;
    }
    function disableClickPropagation(el2) {
      on(el2, "mousedown touchstart dblclick contextmenu", stopPropagation);
      el2["_leaflet_disable_click"] = true;
      return this;
    }
    function preventDefault(e2) {
      if (e2.preventDefault) {
        e2.preventDefault();
      } else {
        e2.returnValue = false;
      }
      return this;
    }
    function stop(e2) {
      preventDefault(e2);
      stopPropagation(e2);
      return this;
    }
    function getPropagationPath(ev) {
      if (ev.composedPath) {
        return ev.composedPath();
      }
      var path = [];
      var el2 = ev.target;
      while (el2) {
        path.push(el2);
        el2 = el2.parentNode;
      }
      return path;
    }
    function getMousePosition(e2, container) {
      if (!container) {
        return new Point(e2.clientX, e2.clientY);
      }
      var scale2 = getScale(container), offset = scale2.boundingClientRect;
      return new Point(
        // offset.left/top values are in page scale (like clientX/Y),
        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
        (e2.clientX - offset.left) / scale2.x - container.clientLeft,
        (e2.clientY - offset.top) / scale2.y - container.clientTop
      );
    }
    var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
    function getWheelDelta(e2) {
      return Browser.edge ? e2.wheelDeltaY / 2 : (
        // Don't trust window-geometry-based delta
        e2.deltaY && e2.deltaMode === 0 ? -e2.deltaY / wheelPxFactor : (
          // Pixels
          e2.deltaY && e2.deltaMode === 1 ? -e2.deltaY * 20 : (
            // Lines
            e2.deltaY && e2.deltaMode === 2 ? -e2.deltaY * 60 : (
              // Pages
              e2.deltaX || e2.deltaZ ? 0 : (
                // Skip horizontal/depth wheel events
                e2.wheelDelta ? (e2.wheelDeltaY || e2.wheelDelta) / 2 : (
                  // Legacy IE pixels
                  e2.detail && Math.abs(e2.detail) < 32765 ? -e2.detail * 20 : (
                    // Legacy Moz lines
                    e2.detail ? e2.detail / -32765 * 60 : (
                      // Legacy Moz pages
                      0
                    )
                  )
                )
              )
            )
          )
        )
      );
    }
    function isExternalTarget(el2, e2) {
      var related = e2.relatedTarget;
      if (!related) {
        return true;
      }
      try {
        while (related && related !== el2) {
          related = related.parentNode;
        }
      } catch (err) {
        return false;
      }
      return related !== el2;
    }
    var DomEvent = {
      __proto__: null,
      on,
      off,
      stopPropagation,
      disableScrollPropagation,
      disableClickPropagation,
      preventDefault,
      stop,
      getPropagationPath,
      getMousePosition,
      getWheelDelta,
      isExternalTarget,
      addListener: on,
      removeListener: off
    };
    var PosAnimation = Evented.extend({
      // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
      // Run an animation of a given element to a new position, optionally setting
      // duration in seconds (`0.25` by default) and easing linearity factor (3rd
      // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
      // `0.5` by default).
      run: function(el2, newPos, duration, easeLinearity) {
        this.stop();
        this._el = el2;
        this._inProgress = true;
        this._duration = duration || 0.25;
        this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
        this._startPos = getPosition(el2);
        this._offset = newPos.subtract(this._startPos);
        this._startTime = +/* @__PURE__ */ new Date();
        this.fire("start");
        this._animate();
      },
      // @method stop()
      // Stops the animation (if currently running).
      stop: function() {
        if (!this._inProgress) {
          return;
        }
        this._step(true);
        this._complete();
      },
      _animate: function() {
        this._animId = requestAnimFrame(this._animate, this);
        this._step();
      },
      _step: function(round2) {
        var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
        if (elapsed < duration) {
          this._runFrame(this._easeOut(elapsed / duration), round2);
        } else {
          this._runFrame(1);
          this._complete();
        }
      },
      _runFrame: function(progress, round2) {
        var pos = this._startPos.add(this._offset.multiplyBy(progress));
        if (round2) {
          pos._round();
        }
        setPosition(this._el, pos);
        this.fire("step");
      },
      _complete: function() {
        cancelAnimFrame(this._animId);
        this._inProgress = false;
        this.fire("end");
      },
      _easeOut: function(t2) {
        return 1 - Math.pow(1 - t2, this._easeOutPower);
      }
    });
    var Map2 = Evented.extend({
      options: {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: EPSG3857,
        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: void 0,
        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: void 0,
        // @option minZoom: Number = *
        // Minimum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the lowest of their `minZoom` options will be used instead.
        minZoom: void 0,
        // @option maxZoom: Number = *
        // Maximum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the highest of their `maxZoom` options will be used instead.
        maxZoom: void 0,
        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],
        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back if the user tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: void 0,
        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: void 0,
        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: true,
        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,
        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: true,
        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: true,
        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608,
        // Precision limit of a 32-bit float
        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 1,
        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 1,
        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: true
      },
      initialize: function(id2, options) {
        options = setOptions(this, options);
        this._handlers = [];
        this._layers = {};
        this._zoomBoundLayers = {};
        this._sizeChanged = true;
        this._initContainer(id2);
        this._initLayout();
        this._onResize = bind3(this._onResize, this);
        this._initEvents();
        if (options.maxBounds) {
          this.setMaxBounds(options.maxBounds);
        }
        if (options.zoom !== void 0) {
          this._zoom = this._limitZoom(options.zoom);
        }
        if (options.center && options.zoom !== void 0) {
          this.setView(toLatLng2(options.center), options.zoom, { reset: true });
        }
        this.callInitHooks();
        this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
        if (this._zoomAnimated) {
          this._createAnimProxy();
          on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
        }
        this._addLayers(this.options.layers);
      },
      // @section Methods for modifying map state
      // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) with the given
      // animation options.
      setView: function(center2, zoom2, options) {
        zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
        center2 = this._limitCenter(toLatLng2(center2), zoom2, this.options.maxBounds);
        options = options || {};
        this._stop();
        if (this._loaded && !options.reset && options !== true) {
          if (options.animate !== void 0) {
            options.zoom = extend({ animate: options.animate }, options.zoom);
            options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
          }
          var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center2, zoom2, options.zoom) : this._tryAnimatedPan(center2, options.pan);
          if (moved) {
            clearTimeout(this._sizeTimer);
            return this;
          }
        }
        this._resetView(center2, zoom2, options.pan && options.pan.noMoveStart);
        return this;
      },
      // @method setZoom(zoom: Number, options?: Zoom/pan options): this
      // Sets the zoom of the map.
      setZoom: function(zoom2, options) {
        if (!this._loaded) {
          this._zoom = zoom2;
          return this;
        }
        return this.setView(this.getCenter(), zoom2, { zoom: options });
      },
      // @method zoomIn(delta?: Number, options?: Zoom options): this
      // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomIn: function(delta, options) {
        delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom + delta, options);
      },
      // @method zoomOut(delta?: Number, options?: Zoom options): this
      // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomOut: function(delta, options) {
        delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom - delta, options);
      },
      // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified geographical point on the map
      // stationary (e.g. used internally for scroll zoom and double-click zoom).
      // @alternative
      // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
      setZoomAround: function(latlng, zoom2, options) {
        var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
        return this.setView(newCenter, zoom2, { zoom: options });
      },
      _getBoundsCenterZoom: function(bounds, options) {
        options = options || {};
        bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
        zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
        if (zoom2 === Infinity) {
          return {
            center: bounds.getCenter(),
            zoom: zoom2
          };
        }
        var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center2 = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
        return {
          center: center2,
          zoom: zoom2
        };
      },
      // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets a map view that contains the given geographical bounds with the
      // maximum zoom level possible.
      fitBounds: function(bounds, options) {
        bounds = toLatLngBounds(bounds);
        if (!bounds.isValid()) {
          throw new Error("Bounds are not valid.");
        }
        var target = this._getBoundsCenterZoom(bounds, options);
        return this.setView(target.center, target.zoom, options);
      },
      // @method fitWorld(options?: fitBounds options): this
      // Sets a map view that mostly contains the whole world with the maximum
      // zoom level possible.
      fitWorld: function(options) {
        return this.fitBounds([[-90, -180], [90, 180]], options);
      },
      // @method panTo(latlng: LatLng, options?: Pan options): this
      // Pans the map to a given center.
      panTo: function(center2, options) {
        return this.setView(center2, this._zoom, { pan: options });
      },
      // @method panBy(offset: Point, options?: Pan options): this
      // Pans the map by a given number of pixels (animated).
      panBy: function(offset, options) {
        offset = toPoint(offset).round();
        options = options || {};
        if (!offset.x && !offset.y) {
          return this.fire("moveend");
        }
        if (options.animate !== true && !this.getSize().contains(offset)) {
          this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
          return this;
        }
        if (!this._panAnim) {
          this._panAnim = new PosAnimation();
          this._panAnim.on({
            "step": this._onPanTransitionStep,
            "end": this._onPanTransitionEnd
          }, this);
        }
        if (!options.noMoveStart) {
          this.fire("movestart");
        }
        if (options.animate !== false) {
          addClass(this._mapPane, "leaflet-pan-anim");
          var newPos = this._getMapPanePos().subtract(offset).round();
          this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
        } else {
          this._rawPanBy(offset);
          this.fire("move").fire("moveend");
        }
        return this;
      },
      // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) performing a smooth
      // pan-zoom animation.
      flyTo: function(targetCenter, targetZoom, options) {
        options = options || {};
        if (options.animate === false || !Browser.any3d) {
          return this.setView(targetCenter, targetZoom, options);
        }
        this._stop();
        var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
        targetCenter = toLatLng2(targetCenter);
        targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
        var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
        function r2(i) {
          var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
          var log = sq < 1e-9 ? -18 : Math.log(sq);
          return log;
        }
        function sinh(n2) {
          return (Math.exp(n2) - Math.exp(-n2)) / 2;
        }
        function cosh(n2) {
          return (Math.exp(n2) + Math.exp(-n2)) / 2;
        }
        function tanh(n2) {
          return sinh(n2) / cosh(n2);
        }
        var r0 = r2(0);
        function w2(s2) {
          return w0 * (cosh(r0) / cosh(r0 + rho * s2));
        }
        function u2(s2) {
          return w0 * (cosh(r0) * tanh(r0 + rho * s2) - sinh(r0)) / rho2;
        }
        function easeOut(t2) {
          return 1 - Math.pow(1 - t2, 1.5);
        }
        var start = Date.now(), S2 = (r2(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S2 * 0.8;
        function frame() {
          var t2 = (Date.now() - start) / duration, s2 = easeOut(t2) * S2;
          if (t2 <= 1) {
            this._flyToFrame = requestAnimFrame(frame, this);
            this._move(
              this.unproject(from.add(to.subtract(from).multiplyBy(u2(s2) / u1)), startZoom),
              this.getScaleZoom(w0 / w2(s2), startZoom),
              { flyTo: true }
            );
          } else {
            this._move(targetCenter, targetZoom)._moveEnd(true);
          }
        }
        this._moveStart(true, options.noMoveStart);
        frame.call(this);
        return this;
      },
      // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
      // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
      flyToBounds: function(bounds, options) {
        var target = this._getBoundsCenterZoom(bounds, options);
        return this.flyTo(target.center, target.zoom, options);
      },
      // @method setMaxBounds(bounds: LatLngBounds): this
      // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
      setMaxBounds: function(bounds) {
        bounds = toLatLngBounds(bounds);
        if (this.listens("moveend", this._panInsideMaxBounds)) {
          this.off("moveend", this._panInsideMaxBounds);
        }
        if (!bounds.isValid()) {
          this.options.maxBounds = null;
          return this;
        }
        this.options.maxBounds = bounds;
        if (this._loaded) {
          this._panInsideMaxBounds();
        }
        return this.on("moveend", this._panInsideMaxBounds);
      },
      // @method setMinZoom(zoom: Number): this
      // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
      setMinZoom: function(zoom2) {
        var oldZoom = this.options.minZoom;
        this.options.minZoom = zoom2;
        if (this._loaded && oldZoom !== zoom2) {
          this.fire("zoomlevelschange");
          if (this.getZoom() < this.options.minZoom) {
            return this.setZoom(zoom2);
          }
        }
        return this;
      },
      // @method setMaxZoom(zoom: Number): this
      // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
      setMaxZoom: function(zoom2) {
        var oldZoom = this.options.maxZoom;
        this.options.maxZoom = zoom2;
        if (this._loaded && oldZoom !== zoom2) {
          this.fire("zoomlevelschange");
          if (this.getZoom() > this.options.maxZoom) {
            return this.setZoom(zoom2);
          }
        }
        return this;
      },
      // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
      // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
      panInsideBounds: function(bounds, options) {
        this._enforcingBounds = true;
        var center2 = this.getCenter(), newCenter = this._limitCenter(center2, this._zoom, toLatLngBounds(bounds));
        if (!center2.equals(newCenter)) {
          this.panTo(newCenter, options);
        }
        this._enforcingBounds = false;
        return this;
      },
      // @method panInside(latlng: LatLng, options?: padding options): this
      // Pans the map the minimum amount to make the `latlng` visible. Use
      // padding options to fit the display to more restricted bounds.
      // If `latlng` is already within the (optionally padded) display bounds,
      // the map will not be panned.
      panInside: function(latlng, options) {
        options = options || {};
        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds2([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
        if (!paddedBounds.contains(pixelPoint)) {
          this._enforcingBounds = true;
          var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
          var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
          pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
          pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
          this.panTo(this.unproject(pixelCenter), options);
          this._enforcingBounds = false;
        }
        return this;
      },
      // @method invalidateSize(options: Zoom/pan options): this
      // Checks if the map container size changed and updates the map if so —
      // call it after you've changed the map size dynamically, also animating
      // pan by default. If `options.pan` is `false`, panning will not occur.
      // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
      // that it doesn't happen often even if the method is called many
      // times in a row.
      // @alternative
      // @method invalidateSize(animate: Boolean): this
      // Checks if the map container size changed and updates the map if so —
      // call it after you've changed the map size dynamically, also animating
      // pan by default.
      invalidateSize: function(options) {
        if (!this._loaded) {
          return this;
        }
        options = extend({
          animate: false,
          pan: true
        }, options === true ? { animate: true } : options);
        var oldSize = this.getSize();
        this._sizeChanged = true;
        this._lastCenter = null;
        var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
        if (!offset.x && !offset.y) {
          return this;
        }
        if (options.animate && options.pan) {
          this.panBy(offset);
        } else {
          if (options.pan) {
            this._rawPanBy(offset);
          }
          this.fire("move");
          if (options.debounceMoveend) {
            clearTimeout(this._sizeTimer);
            this._sizeTimer = setTimeout(bind3(this.fire, this, "moveend"), 200);
          } else {
            this.fire("moveend");
          }
        }
        return this.fire("resize", {
          oldSize,
          newSize
        });
      },
      // @section Methods for modifying map state
      // @method stop(): this
      // Stops the currently running `panTo` or `flyTo` animation, if any.
      stop: function() {
        this.setZoom(this._limitZoom(this._zoom));
        if (!this.options.zoomSnap) {
          this.fire("viewreset");
        }
        return this._stop();
      },
      // @section Geolocation methods
      // @method locate(options?: Locate options): this
      // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
      // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
      // and optionally sets the map view to the user's location with respect to
      // detection accuracy (or to the world view if geolocation failed).
      // Note that, if your page doesn't use HTTPS, this method will fail in
      // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
      // See `Locate options` for more details.
      locate: function(options) {
        options = this._locateOptions = extend({
          timeout: 1e4,
          watch: false
          // setView: false
          // maxZoom: <Number>
          // maximumAge: 0
          // enableHighAccuracy: false
        }, options);
        if (!("geolocation" in navigator)) {
          this._handleGeolocationError({
            code: 0,
            message: "Geolocation not supported."
          });
          return this;
        }
        var onResponse = bind3(this._handleGeolocationResponse, this), onError = bind3(this._handleGeolocationError, this);
        if (options.watch) {
          this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
        } else {
          navigator.geolocation.getCurrentPosition(onResponse, onError, options);
        }
        return this;
      },
      // @method stopLocate(): this
      // Stops watching location previously initiated by `map.locate({watch: true})`
      // and aborts resetting the map view if map.locate was called with
      // `{setView: true}`.
      stopLocate: function() {
        if (navigator.geolocation && navigator.geolocation.clearWatch) {
          navigator.geolocation.clearWatch(this._locationWatchId);
        }
        if (this._locateOptions) {
          this._locateOptions.setView = false;
        }
        return this;
      },
      _handleGeolocationError: function(error) {
        if (!this._container._leaflet_id) {
          return;
        }
        var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
        if (this._locateOptions.setView && !this._loaded) {
          this.fitWorld();
        }
        this.fire("locationerror", {
          code: c,
          message: "Geolocation error: " + message + "."
        });
      },
      _handleGeolocationResponse: function(pos) {
        if (!this._container._leaflet_id) {
          return;
        }
        var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
        if (options.setView) {
          var zoom2 = this.getBoundsZoom(bounds);
          this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
        }
        var data = {
          latlng,
          bounds,
          timestamp: pos.timestamp
        };
        for (var i in pos.coords) {
          if (typeof pos.coords[i] === "number") {
            data[i] = pos.coords[i];
          }
        }
        this.fire("locationfound", data);
      },
      // TODO Appropriate docs section?
      // @section Other Methods
      // @method addHandler(name: String, HandlerClass: Function): this
      // Adds a new `Handler` to the map, given its name and constructor function.
      addHandler: function(name, HandlerClass) {
        if (!HandlerClass) {
          return this;
        }
        var handler = this[name] = new HandlerClass(this);
        this._handlers.push(handler);
        if (this.options[name]) {
          handler.enable();
        }
        return this;
      },
      // @method remove(): this
      // Destroys the map and clears all related event listeners.
      remove: function() {
        this._initEvents(true);
        if (this.options.maxBounds) {
          this.off("moveend", this._panInsideMaxBounds);
        }
        if (this._containerId !== this._container._leaflet_id) {
          throw new Error("Map container is being reused by another instance");
        }
        try {
          delete this._container._leaflet_id;
          delete this._containerId;
        } catch (e2) {
          this._container._leaflet_id = void 0;
          this._containerId = void 0;
        }
        if (this._locationWatchId !== void 0) {
          this.stopLocate();
        }
        this._stop();
        remove(this._mapPane);
        if (this._clearControlPos) {
          this._clearControlPos();
        }
        if (this._resizeRequest) {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = null;
        }
        this._clearHandlers();
        if (this._loaded) {
          this.fire("unload");
        }
        var i;
        for (i in this._layers) {
          this._layers[i].remove();
        }
        for (i in this._panes) {
          remove(this._panes[i]);
        }
        this._layers = [];
        this._panes = [];
        delete this._mapPane;
        delete this._renderer;
        return this;
      },
      // @section Other Methods
      // @method createPane(name: String, container?: HTMLElement): HTMLElement
      // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
      // then returns it. The pane is created as a child of `container`, or
      // as a child of the main map pane if not set.
      createPane: function(name, container) {
        var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
        if (name) {
          this._panes[name] = pane;
        }
        return pane;
      },
      // @section Methods for Getting Map State
      // @method getCenter(): LatLng
      // Returns the geographical center of the map view
      getCenter: function() {
        this._checkIfLoaded();
        if (this._lastCenter && !this._moved()) {
          return this._lastCenter.clone();
        }
        return this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      // @method getZoom(): Number
      // Returns the current zoom level of the map view
      getZoom: function() {
        return this._zoom;
      },
      // @method getBounds(): LatLngBounds
      // Returns the geographical bounds visible in the current map view
      getBounds: function() {
        var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne2 = this.unproject(bounds.getTopRight());
        return new LatLngBounds(sw, ne2);
      },
      // @method getMinZoom(): Number
      // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
      getMinZoom: function() {
        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      // @method getMaxZoom(): Number
      // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
      getMaxZoom: function() {
        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
      },
      // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
      // Returns the maximum zoom level on which the given bounds fit to the map
      // view in its entirety. If `inside` (optional) is set to `true`, the method
      // instead returns the minimum zoom level on which the map view fits into
      // the given bounds in its entirety.
      getBoundsZoom: function(bounds, inside, padding) {
        bounds = toLatLngBounds(bounds);
        padding = toPoint(padding || [0, 0]);
        var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max2 = this.getMaxZoom(), nw = bounds.getNorthWest(), se2 = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds2(this.project(se2, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
        zoom2 = this.getScaleZoom(scale2, zoom2);
        if (snap) {
          zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
          zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
        }
        return Math.max(min, Math.min(max2, zoom2));
      },
      // @method getSize(): Point
      // Returns the current size of the map container (in pixels).
      getSize: function() {
        if (!this._size || this._sizeChanged) {
          this._size = new Point(
            this._container.clientWidth || 0,
            this._container.clientHeight || 0
          );
          this._sizeChanged = false;
        }
        return this._size.clone();
      },
      // @method getPixelBounds(): Bounds
      // Returns the bounds of the current map view in projected pixel
      // coordinates (sometimes useful in layer and overlay implementations).
      getPixelBounds: function(center2, zoom2) {
        var topLeftPoint = this._getTopLeftPoint(center2, zoom2);
        return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
      },
      // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
      // the map pane? "left point of the map layer" can be confusing, specially
      // since there can be negative offsets.
      // @method getPixelOrigin(): Point
      // Returns the projected pixel coordinates of the top left point of
      // the map layer (useful in custom layer and overlay implementations).
      getPixelOrigin: function() {
        this._checkIfLoaded();
        return this._pixelOrigin;
      },
      // @method getPixelWorldBounds(zoom?: Number): Bounds
      // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
      // If `zoom` is omitted, the map's current zoom level is used.
      getPixelWorldBounds: function(zoom2) {
        return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
      },
      // @section Other Methods
      // @method getPane(pane: String|HTMLElement): HTMLElement
      // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
      getPane: function(pane) {
        return typeof pane === "string" ? this._panes[pane] : pane;
      },
      // @method getPanes(): Object
      // Returns a plain object containing the names of all [panes](#map-pane) as keys and
      // the panes as values.
      getPanes: function() {
        return this._panes;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the map.
      getContainer: function() {
        return this._container;
      },
      // @section Conversion Methods
      // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
      // Returns the scale factor to be applied to a map transition from zoom level
      // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
      getZoomScale: function(toZoom, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
        return crs.scale(toZoom) / crs.scale(fromZoom);
      },
      // @method getScaleZoom(scale: Number, fromZoom: Number): Number
      // Returns the zoom level that the map would end up at, if it is at `fromZoom`
      // level and everything is scaled by a factor of `scale`. Inverse of
      // [`getZoomScale`](#map-getZoomScale).
      getScaleZoom: function(scale2, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
        var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
        return isNaN(zoom2) ? Infinity : zoom2;
      },
      // @method project(latlng: LatLng, zoom: Number): Point
      // Projects a geographical coordinate `LatLng` according to the projection
      // of the map's CRS, then scales it according to `zoom` and the CRS's
      // `Transformation`. The result is pixel coordinate relative to
      // the CRS origin.
      project: function(latlng, zoom2) {
        zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
        return this.options.crs.latLngToPoint(toLatLng2(latlng), zoom2);
      },
      // @method unproject(point: Point, zoom: Number): LatLng
      // Inverse of [`project`](#map-project).
      unproject: function(point2, zoom2) {
        zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
        return this.options.crs.pointToLatLng(toPoint(point2), zoom2);
      },
      // @method layerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding geographical coordinate (for the current zoom level).
      layerPointToLatLng: function(point2) {
        var projectedPoint = toPoint(point2).add(this.getPixelOrigin());
        return this.unproject(projectedPoint);
      },
      // @method latLngToLayerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the [origin pixel](#map-getpixelorigin).
      latLngToLayerPoint: function(latlng) {
        var projectedPoint = this.project(toLatLng2(latlng))._round();
        return projectedPoint._subtract(this.getPixelOrigin());
      },
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
      // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
      // CRS's bounds.
      // By default this means longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees.
      wrapLatLng: function(latlng) {
        return this.options.crs.wrapLatLng(toLatLng2(latlng));
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring that
      // its center is within the CRS's bounds.
      // By default this means the center longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees, and the majority of the bounds
      // overlaps the CRS's bounds.
      wrapLatLngBounds: function(latlng) {
        return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates according to
      // the map's CRS. By default this measures distance in meters.
      distance: function(latlng1, latlng2) {
        return this.options.crs.distance(toLatLng2(latlng1), toLatLng2(latlng2));
      },
      // @method containerPointToLayerPoint(point: Point): Point
      // Given a pixel coordinate relative to the map container, returns the corresponding
      // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
      containerPointToLayerPoint: function(point2) {
        return toPoint(point2).subtract(this._getMapPanePos());
      },
      // @method layerPointToContainerPoint(point: Point): Point
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding pixel coordinate relative to the map container.
      layerPointToContainerPoint: function(point2) {
        return toPoint(point2).add(this._getMapPanePos());
      },
      // @method containerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the map container, returns
      // the corresponding geographical coordinate (for the current zoom level).
      containerPointToLatLng: function(point2) {
        var layerPoint = this.containerPointToLayerPoint(toPoint(point2));
        return this.layerPointToLatLng(layerPoint);
      },
      // @method latLngToContainerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the map container.
      latLngToContainerPoint: function(latlng) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng2(latlng)));
      },
      // @method mouseEventToContainerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to the
      // map container where the event took place.
      mouseEventToContainerPoint: function(e2) {
        return getMousePosition(e2, this._container);
      },
      // @method mouseEventToLayerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to
      // the [origin pixel](#map-getpixelorigin) where the event took place.
      mouseEventToLayerPoint: function(e2) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e2));
      },
      // @method mouseEventToLatLng(ev: MouseEvent): LatLng
      // Given a MouseEvent object, returns geographical coordinate where the
      // event took place.
      mouseEventToLatLng: function(e2) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(e2));
      },
      // map initialization methods
      _initContainer: function(id2) {
        var container = this._container = get(id2);
        if (!container) {
          throw new Error("Map container not found.");
        } else if (container._leaflet_id) {
          throw new Error("Map container is already initialized.");
        }
        on(container, "scroll", this._onScroll, this);
        this._containerId = stamp(container);
      },
      _initLayout: function() {
        var container = this._container;
        this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
        addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var position = getStyle(container, "position");
        if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
          container.style.position = "relative";
        }
        this._initPanes();
        if (this._initControlPos) {
          this._initControlPos();
        }
      },
      _initPanes: function() {
        var panes = this._panes = {};
        this._paneRenderers = {};
        this._mapPane = this.createPane("mapPane", this._container);
        setPosition(this._mapPane, new Point(0, 0));
        this.createPane("tilePane");
        this.createPane("overlayPane");
        this.createPane("shadowPane");
        this.createPane("markerPane");
        this.createPane("tooltipPane");
        this.createPane("popupPane");
        if (!this.options.markerZoomAnimation) {
          addClass(panes.markerPane, "leaflet-zoom-hide");
          addClass(panes.shadowPane, "leaflet-zoom-hide");
        }
      },
      // private methods that modify map state
      // @section Map state change events
      _resetView: function(center2, zoom2, noMoveStart) {
        setPosition(this._mapPane, new Point(0, 0));
        var loading = !this._loaded;
        this._loaded = true;
        zoom2 = this._limitZoom(zoom2);
        this.fire("viewprereset");
        var zoomChanged = this._zoom !== zoom2;
        this._moveStart(zoomChanged, noMoveStart)._move(center2, zoom2)._moveEnd(zoomChanged);
        this.fire("viewreset");
        if (loading) {
          this.fire("load");
        }
      },
      _moveStart: function(zoomChanged, noMoveStart) {
        if (zoomChanged) {
          this.fire("zoomstart");
        }
        if (!noMoveStart) {
          this.fire("movestart");
        }
        return this;
      },
      _move: function(center2, zoom2, data, supressEvent) {
        if (zoom2 === void 0) {
          zoom2 = this._zoom;
        }
        var zoomChanged = this._zoom !== zoom2;
        this._zoom = zoom2;
        this._lastCenter = center2;
        this._pixelOrigin = this._getNewPixelOrigin(center2);
        if (!supressEvent) {
          if (zoomChanged || data && data.pinch) {
            this.fire("zoom", data);
          }
          this.fire("move", data);
        } else if (data && data.pinch) {
          this.fire("zoom", data);
        }
        return this;
      },
      _moveEnd: function(zoomChanged) {
        if (zoomChanged) {
          this.fire("zoomend");
        }
        return this.fire("moveend");
      },
      _stop: function() {
        cancelAnimFrame(this._flyToFrame);
        if (this._panAnim) {
          this._panAnim.stop();
        }
        return this;
      },
      _rawPanBy: function(offset) {
        setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function() {
        if (!this._enforcingBounds) {
          this.panInsideBounds(this.options.maxBounds);
        }
      },
      _checkIfLoaded: function() {
        if (!this._loaded) {
          throw new Error("Set map center and zoom first.");
        }
      },
      // DOM event handling
      // @section Interaction events
      _initEvents: function(remove2) {
        this._targets = {};
        this._targets[stamp(this._container)] = this;
        var onOff = remove2 ? off : on;
        onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
        if (this.options.trackResize) {
          onOff(window, "resize", this._onResize, this);
        }
        if (Browser.any3d && this.options.transform3DLimit) {
          (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        }
      },
      _onResize: function() {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = requestAnimFrame(
          function() {
            this.invalidateSize({ debounceMoveend: true });
          },
          this
        );
      },
      _onScroll: function() {
        this._container.scrollTop = 0;
        this._container.scrollLeft = 0;
      },
      _onMoveEnd: function() {
        var pos = this._getMapPanePos();
        if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
          this._resetView(this.getCenter(), this.getZoom());
        }
      },
      _findEventTargets: function(e2, type2) {
        var targets = [], target, isHover = type2 === "mouseout" || type2 === "mouseover", src = e2.target || e2.srcElement, dragging = false;
        while (src) {
          target = this._targets[stamp(src)];
          if (target && (type2 === "click" || type2 === "preclick") && this._draggableMoved(target)) {
            dragging = true;
            break;
          }
          if (target && target.listens(type2, true)) {
            if (isHover && !isExternalTarget(src, e2)) {
              break;
            }
            targets.push(target);
            if (isHover) {
              break;
            }
          }
          if (src === this._container) {
            break;
          }
          src = src.parentNode;
        }
        if (!targets.length && !dragging && !isHover && this.listens(type2, true)) {
          targets = [this];
        }
        return targets;
      },
      _isClickDisabled: function(el2) {
        while (el2 && el2 !== this._container) {
          if (el2["_leaflet_disable_click"]) {
            return true;
          }
          el2 = el2.parentNode;
        }
      },
      _handleDOMEvent: function(e2) {
        var el2 = e2.target || e2.srcElement;
        if (!this._loaded || el2["_leaflet_disable_events"] || e2.type === "click" && this._isClickDisabled(el2)) {
          return;
        }
        var type2 = e2.type;
        if (type2 === "mousedown") {
          preventOutline(el2);
        }
        this._fireDOMEvent(e2, type2);
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(e2, type2, canvasTargets) {
        if (e2.type === "click") {
          var synth = extend({}, e2);
          synth.type = "preclick";
          this._fireDOMEvent(synth, synth.type, canvasTargets);
        }
        var targets = this._findEventTargets(e2, type2);
        if (canvasTargets) {
          var filtered = [];
          for (var i = 0; i < canvasTargets.length; i++) {
            if (canvasTargets[i].listens(type2, true)) {
              filtered.push(canvasTargets[i]);
            }
          }
          targets = filtered.concat(targets);
        }
        if (!targets.length) {
          return;
        }
        if (type2 === "contextmenu") {
          preventDefault(e2);
        }
        var target = targets[0];
        var data = {
          originalEvent: e2
        };
        if (e2.type !== "keypress" && e2.type !== "keydown" && e2.type !== "keyup") {
          var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
          data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e2);
          data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
          data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
        }
        for (i = 0; i < targets.length; i++) {
          targets[i].fire(type2, data, true);
          if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf3(this._mouseEvents, type2) !== -1) {
            return;
          }
        }
      },
      _draggableMoved: function(obj) {
        obj = obj.dragging && obj.dragging.enabled() ? obj : this;
        return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function() {
        for (var i = 0, len = this._handlers.length; i < len; i++) {
          this._handlers[i].disable();
        }
      },
      // @section Other Methods
      // @method whenReady(fn: Function, context?: Object): this
      // Runs the given function `fn` when the map gets initialized with
      // a view (center and zoom) and at least one layer, or immediately
      // if it's already initialized, optionally passing a function context.
      whenReady: function(callback, context) {
        if (this._loaded) {
          callback.call(context || this, { target: this });
        } else {
          this.on("load", callback, context);
        }
        return this;
      },
      // private methods for getting map state
      _getMapPanePos: function() {
        return getPosition(this._mapPane) || new Point(0, 0);
      },
      _moved: function() {
        var pos = this._getMapPanePos();
        return pos && !pos.equals([0, 0]);
      },
      _getTopLeftPoint: function(center2, zoom2) {
        var pixelOrigin = center2 && zoom2 !== void 0 ? this._getNewPixelOrigin(center2, zoom2) : this.getPixelOrigin();
        return pixelOrigin.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function(center2, zoom2) {
        var viewHalf = this.getSize()._divideBy(2);
        return this.project(center2, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function(latlng, zoom2, center2) {
        var topLeft = this._getNewPixelOrigin(center2, zoom2);
        return this.project(latlng, zoom2)._subtract(topLeft);
      },
      _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center2) {
        var topLeft = this._getNewPixelOrigin(center2, zoom2);
        return toBounds2([
          this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
        ]);
      },
      // layer point of the current center
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      // offset of the specified place to the current center in pixels
      _getCenterOffset: function(latlng) {
        return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
      },
      // adjust center for view to get inside bounds
      _limitCenter: function(center2, zoom2, bounds) {
        if (!bounds) {
          return center2;
        }
        var centerPoint = this.project(center2, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
        if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
          return center2;
        }
        return this.unproject(centerPoint.add(offset), zoom2);
      },
      // adjust offset for view to get inside bounds
      _limitOffset: function(offset, bounds) {
        if (!bounds) {
          return offset;
        }
        var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
        return offset.add(this._getBoundsOffset(newBounds, bounds));
      },
      // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
      _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
        var projectedMaxBounds = toBounds2(
          this.project(maxBounds.getNorthEast(), zoom2),
          this.project(maxBounds.getSouthWest(), zoom2)
        ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
        return new Point(dx, dy);
      },
      _rebound: function(left, right) {
        return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
      },
      _limitZoom: function(zoom2) {
        var min = this.getMinZoom(), max2 = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
        if (snap) {
          zoom2 = Math.round(zoom2 / snap) * snap;
        }
        return Math.max(min, Math.min(max2, zoom2));
      },
      _onPanTransitionStep: function() {
        this.fire("move");
      },
      _onPanTransitionEnd: function() {
        removeClass(this._mapPane, "leaflet-pan-anim");
        this.fire("moveend");
      },
      _tryAnimatedPan: function(center2, options) {
        var offset = this._getCenterOffset(center2)._trunc();
        if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
          return false;
        }
        this.panBy(offset, options);
        return true;
      },
      _createAnimProxy: function() {
        var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(proxy);
        this.on("zoomanim", function(e2) {
          var prop = TRANSFORM, transform = this._proxy.style[prop];
          setTransform(this._proxy, this.project(e2.center, e2.zoom), this.getZoomScale(e2.zoom, 1));
          if (transform === this._proxy.style[prop] && this._animatingZoom) {
            this._onZoomTransitionEnd();
          }
        }, this);
        this.on("load moveend", this._animMoveEnd, this);
        this._on("unload", this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function() {
        remove(this._proxy);
        this.off("load moveend", this._animMoveEnd, this);
        delete this._proxy;
      },
      _animMoveEnd: function() {
        var c = this.getCenter(), z2 = this.getZoom();
        setTransform(this._proxy, this.project(c, z2), this.getZoomScale(z2, 1));
      },
      _catchTransitionEnd: function(e2) {
        if (this._animatingZoom && e2.propertyName.indexOf("transform") >= 0) {
          this._onZoomTransitionEnd();
        }
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      },
      _tryAnimatedZoom: function(center2, zoom2, options) {
        if (this._animatingZoom) {
          return true;
        }
        options = options || {};
        if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
          return false;
        }
        var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center2)._divideBy(1 - 1 / scale2);
        if (options.animate !== true && !this.getSize().contains(offset)) {
          return false;
        }
        requestAnimFrame(function() {
          this._moveStart(true, options.noMoveStart || false)._animateZoom(center2, zoom2, true);
        }, this);
        return true;
      },
      _animateZoom: function(center2, zoom2, startAnim, noUpdate) {
        if (!this._mapPane) {
          return;
        }
        if (startAnim) {
          this._animatingZoom = true;
          this._animateToCenter = center2;
          this._animateToZoom = zoom2;
          addClass(this._mapPane, "leaflet-zoom-anim");
        }
        this.fire("zoomanim", {
          center: center2,
          zoom: zoom2,
          noUpdate
        });
        if (!this._tempFireZoomEvent) {
          this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
        }
        this._move(this._animateToCenter, this._animateToZoom, void 0, true);
        setTimeout(bind3(this._onZoomTransitionEnd, this), 250);
      },
      _onZoomTransitionEnd: function() {
        if (!this._animatingZoom) {
          return;
        }
        if (this._mapPane) {
          removeClass(this._mapPane, "leaflet-zoom-anim");
        }
        this._animatingZoom = false;
        this._move(this._animateToCenter, this._animateToZoom, void 0, true);
        if (this._tempFireZoomEvent) {
          this.fire("zoom");
        }
        delete this._tempFireZoomEvent;
        this.fire("move");
        this._moveEnd(true);
      }
    });
    function createMap(id2, options) {
      return new Map2(id2, options);
    }
    var Control = Class.extend({
      // @section
      // @aka Control Options
      options: {
        // @option position: String = 'topright'
        // The position of the control (one of the map corners). Possible values are `'topleft'`,
        // `'topright'`, `'bottomleft'` or `'bottomright'`
        position: "topright"
      },
      initialize: function(options) {
        setOptions(this, options);
      },
      /* @section
       * Classes extending L.Control will inherit the following methods:
       *
       * @method getPosition: string
       * Returns the position of the control.
       */
      getPosition: function() {
        return this.options.position;
      },
      // @method setPosition(position: string): this
      // Sets the position of the control.
      setPosition: function(position) {
        var map = this._map;
        if (map) {
          map.removeControl(this);
        }
        this.options.position = position;
        if (map) {
          map.addControl(this);
        }
        return this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTMLElement that contains the control.
      getContainer: function() {
        return this._container;
      },
      // @method addTo(map: Map): this
      // Adds the control to the given map.
      addTo: function(map) {
        this.remove();
        this._map = map;
        var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
        addClass(container, "leaflet-control");
        if (pos.indexOf("bottom") !== -1) {
          corner.insertBefore(container, corner.firstChild);
        } else {
          corner.appendChild(container);
        }
        this._map.on("unload", this.remove, this);
        return this;
      },
      // @method remove: this
      // Removes the control from the map it is currently active on.
      remove: function() {
        if (!this._map) {
          return this;
        }
        remove(this._container);
        if (this.onRemove) {
          this.onRemove(this._map);
        }
        this._map.off("unload", this.remove, this);
        this._map = null;
        return this;
      },
      _refocusOnMap: function(e2) {
        if (this._map && e2 && e2.screenX > 0 && e2.screenY > 0) {
          this._map.getContainer().focus();
        }
      }
    });
    var control = function(options) {
      return new Control(options);
    };
    Map2.include({
      // @method addControl(control: Control): this
      // Adds the given control to the map
      addControl: function(control2) {
        control2.addTo(this);
        return this;
      },
      // @method removeControl(control: Control): this
      // Removes the given control from the map
      removeControl: function(control2) {
        control2.remove();
        return this;
      },
      _initControlPos: function() {
        var corners = this._controlCorners = {}, l2 = "leaflet-", container = this._controlContainer = create$1("div", l2 + "control-container", this._container);
        function createCorner(vSide, hSide) {
          var className = l2 + vSide + " " + l2 + hSide;
          corners[vSide + hSide] = create$1("div", className, container);
        }
        createCorner("top", "left");
        createCorner("top", "right");
        createCorner("bottom", "left");
        createCorner("bottom", "right");
      },
      _clearControlPos: function() {
        for (var i in this._controlCorners) {
          remove(this._controlCorners[i]);
        }
        remove(this._controlContainer);
        delete this._controlCorners;
        delete this._controlContainer;
      }
    });
    var Layers = Control.extend({
      // @section
      // @aka Control.Layers options
      options: {
        // @option collapsed: Boolean = true
        // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
        collapsed: true,
        position: "topright",
        // @option autoZIndex: Boolean = true
        // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
        autoZIndex: true,
        // @option hideSingleBase: Boolean = false
        // If `true`, the base layers in the control will be hidden when there is only one.
        hideSingleBase: false,
        // @option sortLayers: Boolean = false
        // Whether to sort the layers. When `false`, layers will keep the order
        // in which they were added to the control.
        sortLayers: false,
        // @option sortFunction: Function = *
        // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
        // that will be used for sorting the layers, when `sortLayers` is `true`.
        // The function receives both the `L.Layer` instances and their names, as in
        // `sortFunction(layerA, layerB, nameA, nameB)`.
        // By default, it sorts layers alphabetically by their name.
        sortFunction: function(layerA, layerB, nameA, nameB) {
          return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
        }
      },
      initialize: function(baseLayers, overlays, options) {
        setOptions(this, options);
        this._layerControlInputs = [];
        this._layers = [];
        this._lastZIndex = 0;
        this._handlingClick = false;
        this._preventClick = false;
        for (var i in baseLayers) {
          this._addLayer(baseLayers[i], i);
        }
        for (i in overlays) {
          this._addLayer(overlays[i], i, true);
        }
      },
      onAdd: function(map) {
        this._initLayout();
        this._update();
        this._map = map;
        map.on("zoomend", this._checkDisabledLayers, this);
        for (var i = 0; i < this._layers.length; i++) {
          this._layers[i].layer.on("add remove", this._onLayerChange, this);
        }
        return this._container;
      },
      addTo: function(map) {
        Control.prototype.addTo.call(this, map);
        return this._expandIfNotCollapsed();
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var i = 0; i < this._layers.length; i++) {
          this._layers[i].layer.off("add remove", this._onLayerChange, this);
        }
      },
      // @method addBaseLayer(layer: Layer, name: String): this
      // Adds a base layer (radio button entry) with the given name to the control.
      addBaseLayer: function(layer, name) {
        this._addLayer(layer, name);
        return this._map ? this._update() : this;
      },
      // @method addOverlay(layer: Layer, name: String): this
      // Adds an overlay (checkbox entry) with the given name to the control.
      addOverlay: function(layer, name) {
        this._addLayer(layer, name, true);
        return this._map ? this._update() : this;
      },
      // @method removeLayer(layer: Layer): this
      // Remove the given layer from the control.
      removeLayer: function(layer) {
        layer.off("add remove", this._onLayerChange, this);
        var obj = this._getLayer(stamp(layer));
        if (obj) {
          this._layers.splice(this._layers.indexOf(obj), 1);
        }
        return this._map ? this._update() : this;
      },
      // @method expand(): this
      // Expand the control container if collapsed.
      expand: function() {
        addClass(this._container, "leaflet-control-layers-expanded");
        this._section.style.height = null;
        var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
        if (acceptableHeight < this._section.clientHeight) {
          addClass(this._section, "leaflet-control-layers-scrollbar");
          this._section.style.height = acceptableHeight + "px";
        } else {
          removeClass(this._section, "leaflet-control-layers-scrollbar");
        }
        this._checkDisabledLayers();
        return this;
      },
      // @method collapse(): this
      // Collapse the control container if expanded.
      collapse: function() {
        removeClass(this._container, "leaflet-control-layers-expanded");
        return this;
      },
      _initLayout: function() {
        var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
        container.setAttribute("aria-haspopup", true);
        disableClickPropagation(container);
        disableScrollPropagation(container);
        var section = this._section = create$1("section", className + "-list");
        if (collapsed) {
          this._map.on("click", this.collapse, this);
          on(container, {
            mouseenter: this._expandSafely,
            mouseleave: this.collapse
          }, this);
        }
        var link = this._layersLink = create$1("a", className + "-toggle", container);
        link.href = "#";
        link.title = "Layers";
        link.setAttribute("role", "button");
        on(link, {
          keydown: function(e2) {
            if (e2.keyCode === 13) {
              this._expandSafely();
            }
          },
          // Certain screen readers intercept the key event and instead send a click event
          click: function(e2) {
            preventDefault(e2);
            this._expandSafely();
          }
        }, this);
        if (!collapsed) {
          this.expand();
        }
        this._baseLayersList = create$1("div", className + "-base", section);
        this._separator = create$1("div", className + "-separator", section);
        this._overlaysList = create$1("div", className + "-overlays", section);
        container.appendChild(section);
      },
      _getLayer: function(id2) {
        for (var i = 0; i < this._layers.length; i++) {
          if (this._layers[i] && stamp(this._layers[i].layer) === id2) {
            return this._layers[i];
          }
        }
      },
      _addLayer: function(layer, name, overlay) {
        if (this._map) {
          layer.on("add remove", this._onLayerChange, this);
        }
        this._layers.push({
          layer,
          name,
          overlay
        });
        if (this.options.sortLayers) {
          this._layers.sort(bind3(function(a, b) {
            return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
          }, this));
        }
        if (this.options.autoZIndex && layer.setZIndex) {
          this._lastZIndex++;
          layer.setZIndex(this._lastZIndex);
        }
        this._expandIfNotCollapsed();
      },
      _update: function() {
        if (!this._container) {
          return this;
        }
        empty(this._baseLayersList);
        empty(this._overlaysList);
        this._layerControlInputs = [];
        var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
        for (i = 0; i < this._layers.length; i++) {
          obj = this._layers[i];
          this._addItem(obj);
          overlaysPresent = overlaysPresent || obj.overlay;
          baseLayersPresent = baseLayersPresent || !obj.overlay;
          baseLayersCount += !obj.overlay ? 1 : 0;
        }
        if (this.options.hideSingleBase) {
          baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
          this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
        }
        this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
        return this;
      },
      _onLayerChange: function(e2) {
        if (!this._handlingClick) {
          this._update();
        }
        var obj = this._getLayer(stamp(e2.target));
        var type2 = obj.overlay ? e2.type === "add" ? "overlayadd" : "overlayremove" : e2.type === "add" ? "baselayerchange" : null;
        if (type2) {
          this._map.fire(type2, obj);
        }
      },
      // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
      _createRadioElement: function(name, checked) {
        var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
        var radioFragment = document.createElement("div");
        radioFragment.innerHTML = radioHtml;
        return radioFragment.firstChild;
      },
      _addItem: function(obj) {
        var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
        if (obj.overlay) {
          input = document.createElement("input");
          input.type = "checkbox";
          input.className = "leaflet-control-layers-selector";
          input.defaultChecked = checked;
        } else {
          input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
        }
        this._layerControlInputs.push(input);
        input.layerId = stamp(obj.layer);
        on(input, "click", this._onInputClick, this);
        var name = document.createElement("span");
        name.innerHTML = " " + obj.name;
        var holder = document.createElement("span");
        label.appendChild(holder);
        holder.appendChild(input);
        holder.appendChild(name);
        var container = obj.overlay ? this._overlaysList : this._baseLayersList;
        container.appendChild(label);
        this._checkDisabledLayers();
        return label;
      },
      _onInputClick: function() {
        if (this._preventClick) {
          return;
        }
        var inputs = this._layerControlInputs, input, layer;
        var addedLayers = [], removedLayers = [];
        this._handlingClick = true;
        for (var i = inputs.length - 1; i >= 0; i--) {
          input = inputs[i];
          layer = this._getLayer(input.layerId).layer;
          if (input.checked) {
            addedLayers.push(layer);
          } else if (!input.checked) {
            removedLayers.push(layer);
          }
        }
        for (i = 0; i < removedLayers.length; i++) {
          if (this._map.hasLayer(removedLayers[i])) {
            this._map.removeLayer(removedLayers[i]);
          }
        }
        for (i = 0; i < addedLayers.length; i++) {
          if (!this._map.hasLayer(addedLayers[i])) {
            this._map.addLayer(addedLayers[i]);
          }
        }
        this._handlingClick = false;
        this._refocusOnMap();
      },
      _checkDisabledLayers: function() {
        var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
        for (var i = inputs.length - 1; i >= 0; i--) {
          input = inputs[i];
          layer = this._getLayer(input.layerId).layer;
          input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
        }
      },
      _expandIfNotCollapsed: function() {
        if (this._map && !this.options.collapsed) {
          this.expand();
        }
        return this;
      },
      _expandSafely: function() {
        var section = this._section;
        this._preventClick = true;
        on(section, "click", preventDefault);
        this.expand();
        var that = this;
        setTimeout(function() {
          off(section, "click", preventDefault);
          that._preventClick = false;
        });
      }
    });
    var layers = function(baseLayers, overlays, options) {
      return new Layers(baseLayers, overlays, options);
    };
    var Zoom = Control.extend({
      // @section
      // @aka Control.Zoom options
      options: {
        position: "topleft",
        // @option zoomInText: String = '<span aria-hidden="true">+</span>'
        // The text set on the 'zoom in' button.
        zoomInText: '<span aria-hidden="true">+</span>',
        // @option zoomInTitle: String = 'Zoom in'
        // The title set on the 'zoom in' button.
        zoomInTitle: "Zoom in",
        // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
        // The text set on the 'zoom out' button.
        zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
        // @option zoomOutTitle: String = 'Zoom out'
        // The title set on the 'zoom out' button.
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(map) {
        var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
        this._zoomInButton = this._createButton(
          options.zoomInText,
          options.zoomInTitle,
          zoomName + "-in",
          container,
          this._zoomIn
        );
        this._zoomOutButton = this._createButton(
          options.zoomOutText,
          options.zoomOutTitle,
          zoomName + "-out",
          container,
          this._zoomOut
        );
        this._updateDisabled();
        map.on("zoomend zoomlevelschange", this._updateDisabled, this);
        return container;
      },
      onRemove: function(map) {
        map.off("zoomend zoomlevelschange", this._updateDisabled, this);
      },
      disable: function() {
        this._disabled = true;
        this._updateDisabled();
        return this;
      },
      enable: function() {
        this._disabled = false;
        this._updateDisabled();
        return this;
      },
      _zoomIn: function(e2) {
        if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
          this._map.zoomIn(this._map.options.zoomDelta * (e2.shiftKey ? 3 : 1));
        }
      },
      _zoomOut: function(e2) {
        if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
          this._map.zoomOut(this._map.options.zoomDelta * (e2.shiftKey ? 3 : 1));
        }
      },
      _createButton: function(html, title, className, container, fn) {
        var link = create$1("a", className, container);
        link.innerHTML = html;
        link.href = "#";
        link.title = title;
        link.setAttribute("role", "button");
        link.setAttribute("aria-label", title);
        disableClickPropagation(link);
        on(link, "click", stop);
        on(link, "click", fn, this);
        on(link, "click", this._refocusOnMap, this);
        return link;
      },
      _updateDisabled: function() {
        var map = this._map, className = "leaflet-disabled";
        removeClass(this._zoomInButton, className);
        removeClass(this._zoomOutButton, className);
        this._zoomInButton.setAttribute("aria-disabled", "false");
        this._zoomOutButton.setAttribute("aria-disabled", "false");
        if (this._disabled || map._zoom === map.getMinZoom()) {
          addClass(this._zoomOutButton, className);
          this._zoomOutButton.setAttribute("aria-disabled", "true");
        }
        if (this._disabled || map._zoom === map.getMaxZoom()) {
          addClass(this._zoomInButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "true");
        }
      }
    });
    Map2.mergeOptions({
      zoomControl: true
    });
    Map2.addInitHook(function() {
      if (this.options.zoomControl) {
        this.zoomControl = new Zoom();
        this.addControl(this.zoomControl);
      }
    });
    var zoom = function(options) {
      return new Zoom(options);
    };
    var Scale = Control.extend({
      // @section
      // @aka Control.Scale options
      options: {
        position: "bottomleft",
        // @option maxWidth: Number = 100
        // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
        maxWidth: 100,
        // @option metric: Boolean = True
        // Whether to show the metric scale line (m/km).
        metric: true,
        // @option imperial: Boolean = True
        // Whether to show the imperial scale line (mi/ft).
        imperial: true
        // @option updateWhenIdle: Boolean = false
        // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
      },
      onAdd: function(map) {
        var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
        this._addScales(options, className + "-line", container);
        map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
        map.whenReady(this._update, this);
        return container;
      },
      onRemove: function(map) {
        map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      },
      _addScales: function(options, className, container) {
        if (options.metric) {
          this._mScale = create$1("div", className, container);
        }
        if (options.imperial) {
          this._iScale = create$1("div", className, container);
        }
      },
      _update: function() {
        var map = this._map, y2 = map.getSize().y / 2;
        var maxMeters = map.distance(
          map.containerPointToLatLng([0, y2]),
          map.containerPointToLatLng([this.options.maxWidth, y2])
        );
        this._updateScales(maxMeters);
      },
      _updateScales: function(maxMeters) {
        if (this.options.metric && maxMeters) {
          this._updateMetric(maxMeters);
        }
        if (this.options.imperial && maxMeters) {
          this._updateImperial(maxMeters);
        }
      },
      _updateMetric: function(maxMeters) {
        var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
        this._updateScale(this._mScale, label, meters / maxMeters);
      },
      _updateImperial: function(maxMeters) {
        var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
        if (maxFeet > 5280) {
          maxMiles = maxFeet / 5280;
          miles = this._getRoundNum(maxMiles);
          this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
        } else {
          feet = this._getRoundNum(maxFeet);
          this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
        }
      },
      _updateScale: function(scale2, text, ratio) {
        scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
        scale2.innerHTML = text;
      },
      _getRoundNum: function(num) {
        var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
        d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
        return pow10 * d;
      }
    });
    var scale = function(options) {
      return new Scale(options);
    };
    var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
    var Attribution = Control.extend({
      // @section
      // @aka Control.Attribution options
      options: {
        position: "bottomright",
        // @option prefix: String|false = 'Leaflet'
        // The HTML text shown before the attributions. Pass `false` to disable.
        prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
      },
      initialize: function(options) {
        setOptions(this, options);
        this._attributions = {};
      },
      onAdd: function(map) {
        map.attributionControl = this;
        this._container = create$1("div", "leaflet-control-attribution");
        disableClickPropagation(this._container);
        for (var i in map._layers) {
          if (map._layers[i].getAttribution) {
            this.addAttribution(map._layers[i].getAttribution());
          }
        }
        this._update();
        map.on("layeradd", this._addAttribution, this);
        return this._container;
      },
      onRemove: function(map) {
        map.off("layeradd", this._addAttribution, this);
      },
      _addAttribution: function(ev) {
        if (ev.layer.getAttribution) {
          this.addAttribution(ev.layer.getAttribution());
          ev.layer.once("remove", function() {
            this.removeAttribution(ev.layer.getAttribution());
          }, this);
        }
      },
      // @method setPrefix(prefix: String|false): this
      // The HTML text shown before the attributions. Pass `false` to disable.
      setPrefix: function(prefix) {
        this.options.prefix = prefix;
        this._update();
        return this;
      },
      // @method addAttribution(text: String): this
      // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
      addAttribution: function(text) {
        if (!text) {
          return this;
        }
        if (!this._attributions[text]) {
          this._attributions[text] = 0;
        }
        this._attributions[text]++;
        this._update();
        return this;
      },
      // @method removeAttribution(text: String): this
      // Removes an attribution text.
      removeAttribution: function(text) {
        if (!text) {
          return this;
        }
        if (this._attributions[text]) {
          this._attributions[text]--;
          this._update();
        }
        return this;
      },
      _update: function() {
        if (!this._map) {
          return;
        }
        var attribs = [];
        for (var i in this._attributions) {
          if (this._attributions[i]) {
            attribs.push(i);
          }
        }
        var prefixAndAttribs = [];
        if (this.options.prefix) {
          prefixAndAttribs.push(this.options.prefix);
        }
        if (attribs.length) {
          prefixAndAttribs.push(attribs.join(", "));
        }
        this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
      }
    });
    Map2.mergeOptions({
      attributionControl: true
    });
    Map2.addInitHook(function() {
      if (this.options.attributionControl) {
        new Attribution().addTo(this);
      }
    });
    var attribution = function(options) {
      return new Attribution(options);
    };
    Control.Layers = Layers;
    Control.Zoom = Zoom;
    Control.Scale = Scale;
    Control.Attribution = Attribution;
    control.layers = layers;
    control.zoom = zoom;
    control.scale = scale;
    control.attribution = attribution;
    var Handler = Class.extend({
      initialize: function(map) {
        this._map = map;
      },
      // @method enable(): this
      // Enables the handler
      enable: function() {
        if (this._enabled) {
          return this;
        }
        this._enabled = true;
        this.addHooks();
        return this;
      },
      // @method disable(): this
      // Disables the handler
      disable: function() {
        if (!this._enabled) {
          return this;
        }
        this._enabled = false;
        this.removeHooks();
        return this;
      },
      // @method enabled(): Boolean
      // Returns `true` if the handler is enabled
      enabled: function() {
        return !!this._enabled;
      }
      // @section Extension methods
      // Classes inheriting from `Handler` must implement the two following methods:
      // @method addHooks()
      // Called when the handler is enabled, should add event hooks.
      // @method removeHooks()
      // Called when the handler is disabled, should remove the event hooks added previously.
    });
    Handler.addTo = function(map, name) {
      map.addHandler(name, this);
      return this;
    };
    var Mixin = { Events };
    var START = Browser.touch ? "touchstart mousedown" : "mousedown";
    var Draggable = Evented.extend({
      options: {
        // @section
        // @aka Draggable options
        // @option clickTolerance: Number = 3
        // The max number of pixels a user can shift the mouse pointer during a click
        // for it to be considered a valid click (as opposed to a mouse drag).
        clickTolerance: 3
      },
      // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
      // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
      initialize: function(element, dragStartTarget, preventOutline2, options) {
        setOptions(this, options);
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._preventOutline = preventOutline2;
      },
      // @method enable()
      // Enables the dragging ability
      enable: function() {
        if (this._enabled) {
          return;
        }
        on(this._dragStartTarget, START, this._onDown, this);
        this._enabled = true;
      },
      // @method disable()
      // Disables the dragging ability
      disable: function() {
        if (!this._enabled) {
          return;
        }
        if (Draggable._dragging === this) {
          this.finishDrag(true);
        }
        off(this._dragStartTarget, START, this._onDown, this);
        this._enabled = false;
        this._moved = false;
      },
      _onDown: function(e2) {
        if (!this._enabled) {
          return;
        }
        this._moved = false;
        if (hasClass(this._element, "leaflet-zoom-anim")) {
          return;
        }
        if (e2.touches && e2.touches.length !== 1) {
          if (Draggable._dragging === this) {
            this.finishDrag();
          }
          return;
        }
        if (Draggable._dragging || e2.shiftKey || e2.which !== 1 && e2.button !== 1 && !e2.touches) {
          return;
        }
        Draggable._dragging = this;
        if (this._preventOutline) {
          preventOutline(this._element);
        }
        disableImageDrag();
        disableTextSelection();
        if (this._moving) {
          return;
        }
        this.fire("down");
        var first = e2.touches ? e2.touches[0] : e2, sizedParent = getSizedParentNode(this._element);
        this._startPoint = new Point(first.clientX, first.clientY);
        this._startPos = getPosition(this._element);
        this._parentScale = getScale(sizedParent);
        var mouseevent = e2.type === "mousedown";
        on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
        on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
      },
      _onMove: function(e2) {
        if (!this._enabled) {
          return;
        }
        if (e2.touches && e2.touches.length > 1) {
          this._moved = true;
          return;
        }
        var first = e2.touches && e2.touches.length === 1 ? e2.touches[0] : e2, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
        if (!offset.x && !offset.y) {
          return;
        }
        if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
          return;
        }
        offset.x /= this._parentScale.x;
        offset.y /= this._parentScale.y;
        preventDefault(e2);
        if (!this._moved) {
          this.fire("dragstart");
          this._moved = true;
          addClass(document.body, "leaflet-dragging");
          this._lastTarget = e2.target || e2.srcElement;
          if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
            this._lastTarget = this._lastTarget.correspondingUseElement;
          }
          addClass(this._lastTarget, "leaflet-drag-target");
        }
        this._newPos = this._startPos.add(offset);
        this._moving = true;
        this._lastEvent = e2;
        this._updatePosition();
      },
      _updatePosition: function() {
        var e2 = { originalEvent: this._lastEvent };
        this.fire("predrag", e2);
        setPosition(this._element, this._newPos);
        this.fire("drag", e2);
      },
      _onUp: function() {
        if (!this._enabled) {
          return;
        }
        this.finishDrag();
      },
      finishDrag: function(noInertia) {
        removeClass(document.body, "leaflet-dragging");
        if (this._lastTarget) {
          removeClass(this._lastTarget, "leaflet-drag-target");
          this._lastTarget = null;
        }
        off(document, "mousemove touchmove", this._onMove, this);
        off(document, "mouseup touchend touchcancel", this._onUp, this);
        enableImageDrag();
        enableTextSelection();
        var fireDragend = this._moved && this._moving;
        this._moving = false;
        Draggable._dragging = false;
        if (fireDragend) {
          this.fire("dragend", {
            noInertia,
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
      }
    });
    function clipPolygon(points2, bounds, round2) {
      var clippedPoints, edges = [1, 4, 2, 8], i, j, k2, a, b, len, edge2, p2;
      for (i = 0, len = points2.length; i < len; i++) {
        points2[i]._code = _getBitCode(points2[i], bounds);
      }
      for (k2 = 0; k2 < 4; k2++) {
        edge2 = edges[k2];
        clippedPoints = [];
        for (i = 0, len = points2.length, j = len - 1; i < len; j = i++) {
          a = points2[i];
          b = points2[j];
          if (!(a._code & edge2)) {
            if (b._code & edge2) {
              p2 = _getEdgeIntersection(b, a, edge2, bounds, round2);
              p2._code = _getBitCode(p2, bounds);
              clippedPoints.push(p2);
            }
            clippedPoints.push(a);
          } else if (!(b._code & edge2)) {
            p2 = _getEdgeIntersection(b, a, edge2, bounds, round2);
            p2._code = _getBitCode(p2, bounds);
            clippedPoints.push(p2);
          }
        }
        points2 = clippedPoints;
      }
      return points2;
    }
    function polygonCenter(latlngs, crs) {
      var i, j, p1, p2, f2, area, x2, y2, center2;
      if (!latlngs || latlngs.length === 0) {
        throw new Error("latlngs not passed");
      }
      if (!isFlat(latlngs)) {
        console.warn("latlngs are not flat! Only the first ring will be used");
        latlngs = latlngs[0];
      }
      var centroidLatLng = toLatLng2([0, 0]);
      var bounds = toLatLngBounds(latlngs);
      var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
      if (areaBounds < 1700) {
        centroidLatLng = centroid(latlngs);
      }
      var len = latlngs.length;
      var points2 = [];
      for (i = 0; i < len; i++) {
        var latlng = toLatLng2(latlngs[i]);
        points2.push(crs.project(toLatLng2([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
      }
      area = x2 = y2 = 0;
      for (i = 0, j = len - 1; i < len; j = i++) {
        p1 = points2[i];
        p2 = points2[j];
        f2 = p1.y * p2.x - p2.y * p1.x;
        x2 += (p1.x + p2.x) * f2;
        y2 += (p1.y + p2.y) * f2;
        area += f2 * 3;
      }
      if (area === 0) {
        center2 = points2[0];
      } else {
        center2 = [x2 / area, y2 / area];
      }
      var latlngCenter = crs.unproject(toPoint(center2));
      return toLatLng2([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
    }
    function centroid(coords) {
      var latSum = 0;
      var lngSum = 0;
      var len = 0;
      for (var i = 0; i < coords.length; i++) {
        var latlng = toLatLng2(coords[i]);
        latSum += latlng.lat;
        lngSum += latlng.lng;
        len++;
      }
      return toLatLng2([latSum / len, lngSum / len]);
    }
    var PolyUtil = {
      __proto__: null,
      clipPolygon,
      polygonCenter,
      centroid
    };
    function simplify(points2, tolerance) {
      if (!tolerance || !points2.length) {
        return points2.slice();
      }
      var sqTolerance = tolerance * tolerance;
      points2 = _reducePoints(points2, sqTolerance);
      points2 = _simplifyDP(points2, sqTolerance);
      return points2;
    }
    function pointToSegmentDistance(p2, p1, p22) {
      return Math.sqrt(_sqClosestPointOnSegment(p2, p1, p22, true));
    }
    function closestPointOnSegment(p2, p1, p22) {
      return _sqClosestPointOnSegment(p2, p1, p22);
    }
    function _simplifyDP(points2, sqTolerance) {
      var len = points2.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
      markers[0] = markers[len - 1] = 1;
      _simplifyDPStep(points2, markers, sqTolerance, 0, len - 1);
      var i, newPoints = [];
      for (i = 0; i < len; i++) {
        if (markers[i]) {
          newPoints.push(points2[i]);
        }
      }
      return newPoints;
    }
    function _simplifyDPStep(points2, markers, sqTolerance, first, last) {
      var maxSqDist = 0, index2, i, sqDist;
      for (i = first + 1; i <= last - 1; i++) {
        sqDist = _sqClosestPointOnSegment(points2[i], points2[first], points2[last], true);
        if (sqDist > maxSqDist) {
          index2 = i;
          maxSqDist = sqDist;
        }
      }
      if (maxSqDist > sqTolerance) {
        markers[index2] = 1;
        _simplifyDPStep(points2, markers, sqTolerance, first, index2);
        _simplifyDPStep(points2, markers, sqTolerance, index2, last);
      }
    }
    function _reducePoints(points2, sqTolerance) {
      var reducedPoints = [points2[0]];
      for (var i = 1, prev = 0, len = points2.length; i < len; i++) {
        if (_sqDist(points2[i], points2[prev]) > sqTolerance) {
          reducedPoints.push(points2[i]);
          prev = i;
        }
      }
      if (prev < len - 1) {
        reducedPoints.push(points2[len - 1]);
      }
      return reducedPoints;
    }
    var _lastCode;
    function clipSegment(a, b, bounds, useLastCode, round2) {
      var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p2, newCode;
      _lastCode = codeB;
      while (true) {
        if (!(codeA | codeB)) {
          return [a, b];
        }
        if (codeA & codeB) {
          return false;
        }
        codeOut = codeA || codeB;
        p2 = _getEdgeIntersection(a, b, codeOut, bounds, round2);
        newCode = _getBitCode(p2, bounds);
        if (codeOut === codeA) {
          a = p2;
          codeA = newCode;
        } else {
          b = p2;
          codeB = newCode;
        }
      }
    }
    function _getEdgeIntersection(a, b, code, bounds, round2) {
      var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max2 = bounds.max, x2, y2;
      if (code & 8) {
        x2 = a.x + dx * (max2.y - a.y) / dy;
        y2 = max2.y;
      } else if (code & 4) {
        x2 = a.x + dx * (min.y - a.y) / dy;
        y2 = min.y;
      } else if (code & 2) {
        x2 = max2.x;
        y2 = a.y + dy * (max2.x - a.x) / dx;
      } else if (code & 1) {
        x2 = min.x;
        y2 = a.y + dy * (min.x - a.x) / dx;
      }
      return new Point(x2, y2, round2);
    }
    function _getBitCode(p2, bounds) {
      var code = 0;
      if (p2.x < bounds.min.x) {
        code |= 1;
      } else if (p2.x > bounds.max.x) {
        code |= 2;
      }
      if (p2.y < bounds.min.y) {
        code |= 4;
      } else if (p2.y > bounds.max.y) {
        code |= 8;
      }
      return code;
    }
    function _sqDist(p1, p2) {
      var dx = p2.x - p1.x, dy = p2.y - p1.y;
      return dx * dx + dy * dy;
    }
    function _sqClosestPointOnSegment(p2, p1, p22, sqDist) {
      var x2 = p1.x, y2 = p1.y, dx = p22.x - x2, dy = p22.y - y2, dot = dx * dx + dy * dy, t2;
      if (dot > 0) {
        t2 = ((p2.x - x2) * dx + (p2.y - y2) * dy) / dot;
        if (t2 > 1) {
          x2 = p22.x;
          y2 = p22.y;
        } else if (t2 > 0) {
          x2 += dx * t2;
          y2 += dy * t2;
        }
      }
      dx = p2.x - x2;
      dy = p2.y - y2;
      return sqDist ? dx * dx + dy * dy : new Point(x2, y2);
    }
    function isFlat(latlngs) {
      return !isArray2(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
    }
    function _flat(latlngs) {
      console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
      return isFlat(latlngs);
    }
    function polylineCenter(latlngs, crs) {
      var i, halfDist, segDist, dist, p1, p2, ratio, center2;
      if (!latlngs || latlngs.length === 0) {
        throw new Error("latlngs not passed");
      }
      if (!isFlat(latlngs)) {
        console.warn("latlngs are not flat! Only the first ring will be used");
        latlngs = latlngs[0];
      }
      var centroidLatLng = toLatLng2([0, 0]);
      var bounds = toLatLngBounds(latlngs);
      var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
      if (areaBounds < 1700) {
        centroidLatLng = centroid(latlngs);
      }
      var len = latlngs.length;
      var points2 = [];
      for (i = 0; i < len; i++) {
        var latlng = toLatLng2(latlngs[i]);
        points2.push(crs.project(toLatLng2([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
      }
      for (i = 0, halfDist = 0; i < len - 1; i++) {
        halfDist += points2[i].distanceTo(points2[i + 1]) / 2;
      }
      if (halfDist === 0) {
        center2 = points2[0];
      } else {
        for (i = 0, dist = 0; i < len - 1; i++) {
          p1 = points2[i];
          p2 = points2[i + 1];
          segDist = p1.distanceTo(p2);
          dist += segDist;
          if (dist > halfDist) {
            ratio = (dist - halfDist) / segDist;
            center2 = [
              p2.x - ratio * (p2.x - p1.x),
              p2.y - ratio * (p2.y - p1.y)
            ];
            break;
          }
        }
      }
      var latlngCenter = crs.unproject(toPoint(center2));
      return toLatLng2([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
    }
    var LineUtil = {
      __proto__: null,
      simplify,
      pointToSegmentDistance,
      closestPointOnSegment,
      clipSegment,
      _getEdgeIntersection,
      _getBitCode,
      _sqClosestPointOnSegment,
      isFlat,
      _flat,
      polylineCenter
    };
    var LonLat = {
      project: function(latlng) {
        return new Point(latlng.lng, latlng.lat);
      },
      unproject: function(point2) {
        return new LatLng(point2.y, point2.x);
      },
      bounds: new Bounds([-180, -90], [180, 90])
    };
    var Mercator = {
      R: 6378137,
      R_MINOR: 6356752314245179e-9,
      bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
      project: function(latlng) {
        var d = Math.PI / 180, r2 = this.R, y2 = latlng.lat * d, tmp = this.R_MINOR / r2, e2 = Math.sqrt(1 - tmp * tmp), con = e2 * Math.sin(y2);
        var ts = Math.tan(Math.PI / 4 - y2 / 2) / Math.pow((1 - con) / (1 + con), e2 / 2);
        y2 = -r2 * Math.log(Math.max(ts, 1e-10));
        return new Point(latlng.lng * d * r2, y2);
      },
      unproject: function(point2) {
        var d = 180 / Math.PI, r2 = this.R, tmp = this.R_MINOR / r2, e2 = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point2.y / r2), phi = Math.PI / 2 - 2 * Math.atan(ts);
        for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
          con = e2 * Math.sin(phi);
          con = Math.pow((1 - con) / (1 + con), e2 / 2);
          dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
          phi += dphi;
        }
        return new LatLng(phi * d, point2.x * d / r2);
      }
    };
    var index = {
      __proto__: null,
      LonLat,
      Mercator,
      SphericalMercator
    };
    var EPSG3395 = extend({}, Earth, {
      code: "EPSG:3395",
      projection: Mercator,
      transformation: function() {
        var scale2 = 0.5 / (Math.PI * Mercator.R);
        return toTransformation(scale2, 0.5, -scale2, 0.5);
      }()
    });
    var EPSG4326 = extend({}, Earth, {
      code: "EPSG:4326",
      projection: LonLat,
      transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
    });
    var Simple = extend({}, CRS, {
      projection: LonLat,
      transformation: toTransformation(1, 0, -1, 0),
      scale: function(zoom2) {
        return Math.pow(2, zoom2);
      },
      zoom: function(scale2) {
        return Math.log(scale2) / Math.LN2;
      },
      distance: function(latlng1, latlng2) {
        var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
        return Math.sqrt(dx * dx + dy * dy);
      },
      infinite: true
    });
    CRS.Earth = Earth;
    CRS.EPSG3395 = EPSG3395;
    CRS.EPSG3857 = EPSG3857;
    CRS.EPSG900913 = EPSG900913;
    CRS.EPSG4326 = EPSG4326;
    CRS.Simple = Simple;
    var Layer = Evented.extend({
      // Classes extending `L.Layer` will inherit the following options:
      options: {
        // @option pane: String = 'overlayPane'
        // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
        pane: "overlayPane",
        // @option attribution: String = null
        // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
        attribution: null,
        bubblingMouseEvents: true
      },
      /* @section
       * Classes extending `L.Layer` will inherit the following methods:
       *
       * @method addTo(map: Map|LayerGroup): this
       * Adds the layer to the given map or layer group.
       */
      addTo: function(map) {
        map.addLayer(this);
        return this;
      },
      // @method remove: this
      // Removes the layer from the map it is currently active on.
      remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      // @method removeFrom(map: Map): this
      // Removes the layer from the given map
      //
      // @alternative
      // @method removeFrom(group: LayerGroup): this
      // Removes the layer from the given `LayerGroup`
      removeFrom: function(obj) {
        if (obj) {
          obj.removeLayer(this);
        }
        return this;
      },
      // @method getPane(name? : String): HTMLElement
      // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
      getPane: function(name) {
        return this._map.getPane(name ? this.options[name] || name : this.options.pane);
      },
      addInteractiveTarget: function(targetEl) {
        this._map._targets[stamp(targetEl)] = this;
        return this;
      },
      removeInteractiveTarget: function(targetEl) {
        delete this._map._targets[stamp(targetEl)];
        return this;
      },
      // @method getAttribution: String
      // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
      getAttribution: function() {
        return this.options.attribution;
      },
      _layerAdd: function(e2) {
        var map = e2.target;
        if (!map.hasLayer(this)) {
          return;
        }
        this._map = map;
        this._zoomAnimated = map._zoomAnimated;
        if (this.getEvents) {
          var events = this.getEvents();
          map.on(events, this);
          this.once("remove", function() {
            map.off(events, this);
          }, this);
        }
        this.onAdd(map);
        this.fire("add");
        map.fire("layeradd", { layer: this });
      }
    });
    Map2.include({
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the map
      addLayer: function(layer) {
        if (!layer._layerAdd) {
          throw new Error("The provided object is not a Layer.");
        }
        var id2 = stamp(layer);
        if (this._layers[id2]) {
          return this;
        }
        this._layers[id2] = layer;
        layer._mapToAdd = this;
        if (layer.beforeAdd) {
          layer.beforeAdd(this);
        }
        this.whenReady(layer._layerAdd, layer);
        return this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the map.
      removeLayer: function(layer) {
        var id2 = stamp(layer);
        if (!this._layers[id2]) {
          return this;
        }
        if (this._loaded) {
          layer.onRemove(this);
        }
        delete this._layers[id2];
        if (this._loaded) {
          this.fire("layerremove", { layer });
          layer.fire("remove");
        }
        layer._map = layer._mapToAdd = null;
        return this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the map
      hasLayer: function(layer) {
        return stamp(layer) in this._layers;
      },
      /* @method eachLayer(fn: Function, context?: Object): this
       * Iterates over the layers of the map, optionally specifying context of the iterator function.
       * ```
       * map.eachLayer(function(layer){
       *     layer.bindPopup('Hello');
       * });
       * ```
       */
      eachLayer: function(method, context) {
        for (var i in this._layers) {
          method.call(context, this._layers[i]);
        }
        return this;
      },
      _addLayers: function(layers2) {
        layers2 = layers2 ? isArray2(layers2) ? layers2 : [layers2] : [];
        for (var i = 0, len = layers2.length; i < len; i++) {
          this.addLayer(layers2[i]);
        }
      },
      _addZoomLimit: function(layer) {
        if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
          this._zoomBoundLayers[stamp(layer)] = layer;
          this._updateZoomLevels();
        }
      },
      _removeZoomLimit: function(layer) {
        var id2 = stamp(layer);
        if (this._zoomBoundLayers[id2]) {
          delete this._zoomBoundLayers[id2];
          this._updateZoomLevels();
        }
      },
      _updateZoomLevels: function() {
        var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
        for (var i in this._zoomBoundLayers) {
          var options = this._zoomBoundLayers[i].options;
          minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
          maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
        }
        this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
        this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
        if (oldZoomSpan !== this._getZoomSpan()) {
          this.fire("zoomlevelschange");
        }
        if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
          this.setZoom(this._layersMaxZoom);
        }
        if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
          this.setZoom(this._layersMinZoom);
        }
      }
    });
    var LayerGroup = Layer.extend({
      initialize: function(layers2, options) {
        setOptions(this, options);
        this._layers = {};
        var i, len;
        if (layers2) {
          for (i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        }
      },
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the group.
      addLayer: function(layer) {
        var id2 = this.getLayerId(layer);
        this._layers[id2] = layer;
        if (this._map) {
          this._map.addLayer(layer);
        }
        return this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the group.
      // @alternative
      // @method removeLayer(id: Number): this
      // Removes the layer with the given internal ID from the group.
      removeLayer: function(layer) {
        var id2 = layer in this._layers ? layer : this.getLayerId(layer);
        if (this._map && this._layers[id2]) {
          this._map.removeLayer(this._layers[id2]);
        }
        delete this._layers[id2];
        return this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the group.
      // @alternative
      // @method hasLayer(id: Number): Boolean
      // Returns `true` if the given internal ID is currently added to the group.
      hasLayer: function(layer) {
        var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
        return layerId in this._layers;
      },
      // @method clearLayers(): this
      // Removes all the layers from the group.
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      },
      // @method invoke(methodName: String, …): this
      // Calls `methodName` on every layer contained in this group, passing any
      // additional parameters. Has no effect if the layers contained do not
      // implement `methodName`.
      invoke: function(methodName) {
        var args = Array.prototype.slice.call(arguments, 1), i, layer;
        for (i in this._layers) {
          layer = this._layers[i];
          if (layer[methodName]) {
            layer[methodName].apply(layer, args);
          }
        }
        return this;
      },
      onAdd: function(map) {
        this.eachLayer(map.addLayer, map);
      },
      onRemove: function(map) {
        this.eachLayer(map.removeLayer, map);
      },
      // @method eachLayer(fn: Function, context?: Object): this
      // Iterates over the layers of the group, optionally specifying context of the iterator function.
      // ```js
      // group.eachLayer(function (layer) {
      // 	layer.bindPopup('Hello');
      // });
      // ```
      eachLayer: function(method, context) {
        for (var i in this._layers) {
          method.call(context, this._layers[i]);
        }
        return this;
      },
      // @method getLayer(id: Number): Layer
      // Returns the layer with the given internal ID.
      getLayer: function(id2) {
        return this._layers[id2];
      },
      // @method getLayers(): Layer[]
      // Returns an array of all the layers added to the group.
      getLayers: function() {
        var layers2 = [];
        this.eachLayer(layers2.push, layers2);
        return layers2;
      },
      // @method setZIndex(zIndex: Number): this
      // Calls `setZIndex` on every layer contained in this group, passing the z-index.
      setZIndex: function(zIndex) {
        return this.invoke("setZIndex", zIndex);
      },
      // @method getLayerId(layer: Layer): Number
      // Returns the internal ID for a layer
      getLayerId: function(layer) {
        return stamp(layer);
      }
    });
    var layerGroup = function(layers2, options) {
      return new LayerGroup(layers2, options);
    };
    var FeatureGroup = LayerGroup.extend({
      addLayer: function(layer) {
        if (this.hasLayer(layer)) {
          return this;
        }
        layer.addEventParent(this);
        LayerGroup.prototype.addLayer.call(this, layer);
        return this.fire("layeradd", { layer });
      },
      removeLayer: function(layer) {
        if (!this.hasLayer(layer)) {
          return this;
        }
        if (layer in this._layers) {
          layer = this._layers[layer];
        }
        layer.removeEventParent(this);
        LayerGroup.prototype.removeLayer.call(this, layer);
        return this.fire("layerremove", { layer });
      },
      // @method setStyle(style: Path options): this
      // Sets the given path options to each layer of the group that has a `setStyle` method.
      setStyle: function(style2) {
        return this.invoke("setStyle", style2);
      },
      // @method bringToFront(): this
      // Brings the layer group to the top of all other layers
      bringToFront: function() {
        return this.invoke("bringToFront");
      },
      // @method bringToBack(): this
      // Brings the layer group to the back of all other layers
      bringToBack: function() {
        return this.invoke("bringToBack");
      },
      // @method getBounds(): LatLngBounds
      // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
      getBounds: function() {
        var bounds = new LatLngBounds();
        for (var id2 in this._layers) {
          var layer = this._layers[id2];
          bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
        }
        return bounds;
      }
    });
    var featureGroup = function(layers2, options) {
      return new FeatureGroup(layers2, options);
    };
    var Icon = Class.extend({
      /* @section
       * @aka Icon options
       *
       * @option iconUrl: String = null
       * **(required)** The URL to the icon image (absolute or relative to your script path).
       *
       * @option iconRetinaUrl: String = null
       * The URL to a retina sized version of the icon image (absolute or relative to your
       * script path). Used for Retina screen devices.
       *
       * @option iconSize: Point = null
       * Size of the icon image in pixels.
       *
       * @option iconAnchor: Point = null
       * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
       * will be aligned so that this point is at the marker's geographical location. Centered
       * by default if size is specified, also can be set in CSS with negative margins.
       *
       * @option popupAnchor: Point = [0, 0]
       * The coordinates of the point from which popups will "open", relative to the icon anchor.
       *
       * @option tooltipAnchor: Point = [0, 0]
       * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
       *
       * @option shadowUrl: String = null
       * The URL to the icon shadow image. If not specified, no shadow image will be created.
       *
       * @option shadowRetinaUrl: String = null
       *
       * @option shadowSize: Point = null
       * Size of the shadow image in pixels.
       *
       * @option shadowAnchor: Point = null
       * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
       * as iconAnchor if not specified).
       *
       * @option className: String = ''
       * A custom class name to assign to both icon and shadow images. Empty by default.
       */
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0],
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: false
      },
      initialize: function(options) {
        setOptions(this, options);
      },
      // @method createIcon(oldIcon?: HTMLElement): HTMLElement
      // Called internally when the icon has to be shown, returns a `<img>` HTML element
      // styled according to the options.
      createIcon: function(oldIcon) {
        return this._createIcon("icon", oldIcon);
      },
      // @method createShadow(oldIcon?: HTMLElement): HTMLElement
      // As `createIcon`, but for the shadow beneath it.
      createShadow: function(oldIcon) {
        return this._createIcon("shadow", oldIcon);
      },
      _createIcon: function(name, oldIcon) {
        var src = this._getIconUrl(name);
        if (!src) {
          if (name === "icon") {
            throw new Error("iconUrl not set in Icon options (see the docs).");
          }
          return null;
        }
        var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
        this._setIconStyles(img, name);
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        return img;
      },
      _setIconStyles: function(img, name) {
        var options = this.options;
        var sizeOption = options[name + "Size"];
        if (typeof sizeOption === "number") {
          sizeOption = [sizeOption, sizeOption];
        }
        var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
        img.className = "leaflet-marker-" + name + " " + (options.className || "");
        if (anchor) {
          img.style.marginLeft = -anchor.x + "px";
          img.style.marginTop = -anchor.y + "px";
        }
        if (size) {
          img.style.width = size.x + "px";
          img.style.height = size.y + "px";
        }
      },
      _createImg: function(src, el2) {
        el2 = el2 || document.createElement("img");
        el2.src = src;
        return el2;
      },
      _getIconUrl: function(name) {
        return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
      }
    });
    function icon(options) {
      return new Icon(options);
    }
    var IconDefault = Icon.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(name) {
        if (typeof IconDefault.imagePath !== "string") {
          IconDefault.imagePath = this._detectIconPath();
        }
        return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
      },
      _stripUrl: function(path) {
        var strip = function(str, re2, idx) {
          var match = re2.exec(str);
          return match && match[idx];
        };
        path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
        return path && strip(path, /^(.*)marker-icon\.png$/, 1);
      },
      _detectIconPath: function() {
        var el2 = create$1("div", "leaflet-default-icon-path", document.body);
        var path = getStyle(el2, "background-image") || getStyle(el2, "backgroundImage");
        document.body.removeChild(el2);
        path = this._stripUrl(path);
        if (path) {
          return path;
        }
        var link = document.querySelector('link[href$="leaflet.css"]');
        if (!link) {
          return "";
        }
        return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
      }
    });
    var MarkerDrag = Handler.extend({
      initialize: function(marker2) {
        this._marker = marker2;
      },
      addHooks: function() {
        var icon2 = this._marker._icon;
        if (!this._draggable) {
          this._draggable = new Draggable(icon2, icon2, true);
        }
        this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable();
        addClass(icon2, "leaflet-marker-draggable");
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable();
        if (this._marker._icon) {
          removeClass(this._marker._icon, "leaflet-marker-draggable");
        }
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      _adjustPan: function(e2) {
        var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
        var panBounds = toBounds2(
          bounds.min._subtract(origin).add(padding),
          bounds.max._subtract(origin).subtract(padding)
        );
        if (!panBounds.contains(iconPos)) {
          var movement = toPoint(
            (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
            (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
          ).multiplyBy(speed);
          map.panBy(movement, { animate: false });
          this._draggable._newPos._add(movement);
          this._draggable._startPos._add(movement);
          setPosition(marker2._icon, this._draggable._newPos);
          this._onDrag(e2);
          this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e2));
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng();
        this._marker.closePopup && this._marker.closePopup();
        this._marker.fire("movestart").fire("dragstart");
      },
      _onPreDrag: function(e2) {
        if (this._marker.options.autoPan) {
          cancelAnimFrame(this._panRequest);
          this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e2));
        }
      },
      _onDrag: function(e2) {
        var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
        if (shadow) {
          setPosition(shadow, iconPos);
        }
        marker2._latlng = latlng;
        e2.latlng = latlng;
        e2.oldLatLng = this._oldLatLng;
        marker2.fire("move", e2).fire("drag", e2);
      },
      _onDragEnd: function(e2) {
        cancelAnimFrame(this._panRequest);
        delete this._oldLatLng;
        this._marker.fire("moveend").fire("dragend", e2);
      }
    });
    var Marker2 = Layer.extend({
      // @section
      // @aka Marker options
      options: {
        // @option icon: Icon = *
        // Icon instance to use for rendering the marker.
        // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
        // If not specified, a common instance of `L.Icon.Default` is used.
        icon: new IconDefault(),
        // Option inherited from "Interactive layer" abstract class
        interactive: true,
        // @option keyboard: Boolean = true
        // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
        keyboard: true,
        // @option title: String = ''
        // Text for the browser tooltip that appear on marker hover (no tooltip by default).
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        title: "",
        // @option alt: String = 'Marker'
        // Text for the `alt` attribute of the icon image.
        // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
        alt: "Marker",
        // @option zIndexOffset: Number = 0
        // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
        zIndexOffset: 0,
        // @option opacity: Number = 1.0
        // The opacity of the marker.
        opacity: 1,
        // @option riseOnHover: Boolean = false
        // If `true`, the marker will get on top of others when you hover the mouse over it.
        riseOnHover: false,
        // @option riseOffset: Number = 250
        // The z-index offset used for the `riseOnHover` feature.
        riseOffset: 250,
        // @option pane: String = 'markerPane'
        // `Map pane` where the markers icon will be added.
        pane: "markerPane",
        // @option shadowPane: String = 'shadowPane'
        // `Map pane` where the markers shadow will be added.
        shadowPane: "shadowPane",
        // @option bubblingMouseEvents: Boolean = false
        // When `true`, a mouse event on this marker will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: false,
        // @option autoPanOnFocus: Boolean = true
        // When `true`, the map will pan whenever the marker is focused (via
        // e.g. pressing `tab` on the keyboard) to ensure the marker is
        // visible within the map's bounds
        autoPanOnFocus: true,
        // @section Draggable marker options
        // @option draggable: Boolean = false
        // Whether the marker is draggable with mouse/touch or not.
        draggable: false,
        // @option autoPan: Boolean = false
        // Whether to pan the map when dragging this marker near its edge or not.
        autoPan: false,
        // @option autoPanPadding: Point = Point(50, 50)
        // Distance (in pixels to the left/right and to the top/bottom) of the
        // map edge to start panning the map.
        autoPanPadding: [50, 50],
        // @option autoPanSpeed: Number = 10
        // Number of pixels the map should pan by.
        autoPanSpeed: 10
      },
      /* @section
       *
       * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
       */
      initialize: function(latlng, options) {
        setOptions(this, options);
        this._latlng = toLatLng2(latlng);
      },
      onAdd: function(map) {
        this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
        if (this._zoomAnimated) {
          map.on("zoomanim", this._animateZoom, this);
        }
        this._initIcon();
        this.update();
      },
      onRemove: function(map) {
        if (this.dragging && this.dragging.enabled()) {
          this.options.draggable = true;
          this.dragging.removeHooks();
        }
        delete this.dragging;
        if (this._zoomAnimated) {
          map.off("zoomanim", this._animateZoom, this);
        }
        this._removeIcon();
        this._removeShadow();
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      // @method getLatLng: LatLng
      // Returns the current geographical position of the marker.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Changes the marker position to the given point.
      setLatLng: function(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng2(latlng);
        this.update();
        return this.fire("move", { oldLatLng, latlng: this._latlng });
      },
      // @method setZIndexOffset(offset: Number): this
      // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
      setZIndexOffset: function(offset) {
        this.options.zIndexOffset = offset;
        return this.update();
      },
      // @method getIcon: Icon
      // Returns the current icon used by the marker
      getIcon: function() {
        return this.options.icon;
      },
      // @method setIcon(icon: Icon): this
      // Changes the marker icon.
      setIcon: function(icon2) {
        this.options.icon = icon2;
        if (this._map) {
          this._initIcon();
          this.update();
        }
        if (this._popup) {
          this.bindPopup(this._popup, this._popup.options);
        }
        return this;
      },
      getElement: function() {
        return this._icon;
      },
      update: function() {
        if (this._icon && this._map) {
          var pos = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(pos);
        }
        return this;
      },
      _initIcon: function() {
        var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        var icon2 = options.icon.createIcon(this._icon), addIcon = false;
        if (icon2 !== this._icon) {
          if (this._icon) {
            this._removeIcon();
          }
          addIcon = true;
          if (options.title) {
            icon2.title = options.title;
          }
          if (icon2.tagName === "IMG") {
            icon2.alt = options.alt || "";
          }
        }
        addClass(icon2, classToAdd);
        if (options.keyboard) {
          icon2.tabIndex = "0";
          icon2.setAttribute("role", "button");
        }
        this._icon = icon2;
        if (options.riseOnHover) {
          this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }
        if (this.options.autoPanOnFocus) {
          on(icon2, "focus", this._panOnFocus, this);
        }
        var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
        if (newShadow !== this._shadow) {
          this._removeShadow();
          addShadow = true;
        }
        if (newShadow) {
          addClass(newShadow, classToAdd);
          newShadow.alt = "";
        }
        this._shadow = newShadow;
        if (options.opacity < 1) {
          this._updateOpacity();
        }
        if (addIcon) {
          this.getPane().appendChild(this._icon);
        }
        this._initInteraction();
        if (newShadow && addShadow) {
          this.getPane(options.shadowPane).appendChild(this._shadow);
        }
      },
      _removeIcon: function() {
        if (this.options.riseOnHover) {
          this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }
        if (this.options.autoPanOnFocus) {
          off(this._icon, "focus", this._panOnFocus, this);
        }
        remove(this._icon);
        this.removeInteractiveTarget(this._icon);
        this._icon = null;
      },
      _removeShadow: function() {
        if (this._shadow) {
          remove(this._shadow);
        }
        this._shadow = null;
      },
      _setPos: function(pos) {
        if (this._icon) {
          setPosition(this._icon, pos);
        }
        if (this._shadow) {
          setPosition(this._shadow, pos);
        }
        this._zIndex = pos.y + this.options.zIndexOffset;
        this._resetZIndex();
      },
      _updateZIndex: function(offset) {
        if (this._icon) {
          this._icon.style.zIndex = this._zIndex + offset;
        }
      },
      _animateZoom: function(opt) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
        this._setPos(pos);
      },
      _initInteraction: function() {
        if (!this.options.interactive) {
          return;
        }
        addClass(this._icon, "leaflet-interactive");
        this.addInteractiveTarget(this._icon);
        if (MarkerDrag) {
          var draggable = this.options.draggable;
          if (this.dragging) {
            draggable = this.dragging.enabled();
            this.dragging.disable();
          }
          this.dragging = new MarkerDrag(this);
          if (draggable) {
            this.dragging.enable();
          }
        }
      },
      // @method setOpacity(opacity: Number): this
      // Changes the opacity of the marker.
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._map) {
          this._updateOpacity();
        }
        return this;
      },
      _updateOpacity: function() {
        var opacity = this.options.opacity;
        if (this._icon) {
          setOpacity(this._icon, opacity);
        }
        if (this._shadow) {
          setOpacity(this._shadow, opacity);
        }
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function() {
        this._updateZIndex(0);
      },
      _panOnFocus: function() {
        var map = this._map;
        if (!map) {
          return;
        }
        var iconOpts = this.options.icon.options;
        var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
        var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
        map.panInside(this._latlng, {
          paddingTopLeft: anchor,
          paddingBottomRight: size.subtract(anchor)
        });
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      }
    });
    function marker(latlng, options) {
      return new Marker2(latlng, options);
    }
    var Path = Layer.extend({
      // @section
      // @aka Path options
      options: {
        // @option stroke: Boolean = true
        // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
        stroke: true,
        // @option color: String = '#3388ff'
        // Stroke color
        color: "#3388ff",
        // @option weight: Number = 3
        // Stroke width in pixels
        weight: 3,
        // @option opacity: Number = 1.0
        // Stroke opacity
        opacity: 1,
        // @option lineCap: String= 'round'
        // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
        lineCap: "round",
        // @option lineJoin: String = 'round'
        // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
        lineJoin: "round",
        // @option dashArray: String = null
        // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashArray: null,
        // @option dashOffset: String = null
        // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashOffset: null,
        // @option fill: Boolean = depends
        // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
        fill: false,
        // @option fillColor: String = *
        // Fill color. Defaults to the value of the [`color`](#path-color) option
        fillColor: null,
        // @option fillOpacity: Number = 0.2
        // Fill opacity.
        fillOpacity: 0.2,
        // @option fillRule: String = 'evenodd'
        // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
        fillRule: "evenodd",
        // className: '',
        // Option inherited from "Interactive layer" abstract class
        interactive: true,
        // @option bubblingMouseEvents: Boolean = true
        // When `true`, a mouse event on this path will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: true
      },
      beforeAdd: function(map) {
        this._renderer = map.getRenderer(this);
      },
      onAdd: function() {
        this._renderer._initPath(this);
        this._reset();
        this._renderer._addPath(this);
      },
      onRemove: function() {
        this._renderer._removePath(this);
      },
      // @method redraw(): this
      // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
      redraw: function() {
        if (this._map) {
          this._renderer._updatePath(this);
        }
        return this;
      },
      // @method setStyle(style: Path options): this
      // Changes the appearance of a Path based on the options in the `Path options` object.
      setStyle: function(style2) {
        setOptions(this, style2);
        if (this._renderer) {
          this._renderer._updateStyle(this);
          if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
            this._updateBounds();
          }
        }
        return this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all path layers.
      bringToFront: function() {
        if (this._renderer) {
          this._renderer._bringToFront(this);
        }
        return this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all path layers.
      bringToBack: function() {
        if (this._renderer) {
          this._renderer._bringToBack(this);
        }
        return this;
      },
      getElement: function() {
        return this._path;
      },
      _reset: function() {
        this._project();
        this._update();
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
      }
    });
    var CircleMarker = Path.extend({
      // @section
      // @aka CircleMarker options
      options: {
        fill: true,
        // @option radius: Number = 10
        // Radius of the circle marker, in pixels
        radius: 10
      },
      initialize: function(latlng, options) {
        setOptions(this, options);
        this._latlng = toLatLng2(latlng);
        this._radius = this.options.radius;
      },
      // @method setLatLng(latLng: LatLng): this
      // Sets the position of a circle marker to a new location.
      setLatLng: function(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng2(latlng);
        this.redraw();
        return this.fire("move", { oldLatLng, latlng: this._latlng });
      },
      // @method getLatLng(): LatLng
      // Returns the current geographical position of the circle marker
      getLatLng: function() {
        return this._latlng;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle marker. Units are in pixels.
      setRadius: function(radius) {
        this.options.radius = this._radius = radius;
        return this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of the circle
      getRadius: function() {
        return this._radius;
      },
      setStyle: function(options) {
        var radius = options && options.radius || this._radius;
        Path.prototype.setStyle.call(this, options);
        this.setRadius(radius);
        return this;
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._updateBounds();
      },
      _updateBounds: function() {
        var r2 = this._radius, r22 = this._radiusY || r2, w2 = this._clickTolerance(), p2 = [r2 + w2, r22 + w2];
        this._pxBounds = new Bounds(this._point.subtract(p2), this._point.add(p2));
      },
      _update: function() {
        if (this._map) {
          this._updatePath();
        }
      },
      _updatePath: function() {
        this._renderer._updateCircle(this);
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(p2) {
        return p2.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    });
    function circleMarker(latlng, options) {
      return new CircleMarker(latlng, options);
    }
    var Circle = CircleMarker.extend({
      initialize: function(latlng, options, legacyOptions) {
        if (typeof options === "number") {
          options = extend({}, legacyOptions, { radius: options });
        }
        setOptions(this, options);
        this._latlng = toLatLng2(latlng);
        if (isNaN(this.options.radius)) {
          throw new Error("Circle radius cannot be NaN");
        }
        this._mRadius = this.options.radius;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle. Units are in meters.
      setRadius: function(radius) {
        this._mRadius = radius;
        return this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of a circle. Units are in meters.
      getRadius: function() {
        return this._mRadius;
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        var half = [this._radius, this._radiusY || this._radius];
        return new LatLngBounds(
          this._map.layerPointToLatLng(this._point.subtract(half)),
          this._map.layerPointToLatLng(this._point.add(half))
        );
      },
      setStyle: Path.prototype.setStyle,
      _project: function() {
        var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
        if (crs.distance === Earth.distance) {
          var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p2 = top.add(bottom).divideBy(2), lat2 = map.unproject(p2).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
          if (isNaN(lngR) || lngR === 0) {
            lngR = latR / Math.cos(Math.PI / 180 * lat);
          }
          this._point = p2.subtract(map.getPixelOrigin());
          this._radius = isNaN(lngR) ? 0 : p2.x - map.project([lat2, lng - lngR]).x;
          this._radiusY = p2.y - top.y;
        } else {
          var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = map.latLngToLayerPoint(this._latlng);
          this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
        }
        this._updateBounds();
      }
    });
    function circle2(latlng, options, legacyOptions) {
      return new Circle(latlng, options, legacyOptions);
    }
    var Polyline = Path.extend({
      // @section
      // @aka Polyline options
      options: {
        // @option smoothFactor: Number = 1.0
        // How much to simplify the polyline on each zoom level. More means
        // better performance and smoother look, and less means more accurate representation.
        smoothFactor: 1,
        // @option noClip: Boolean = false
        // Disable polyline clipping.
        noClip: false
      },
      initialize: function(latlngs, options) {
        setOptions(this, options);
        this._setLatLngs(latlngs);
      },
      // @method getLatLngs(): LatLng[]
      // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
      getLatLngs: function() {
        return this._latlngs;
      },
      // @method setLatLngs(latlngs: LatLng[]): this
      // Replaces all the points in the polyline with the given array of geographical points.
      setLatLngs: function(latlngs) {
        this._setLatLngs(latlngs);
        return this.redraw();
      },
      // @method isEmpty(): Boolean
      // Returns `true` if the Polyline has no LatLngs.
      isEmpty: function() {
        return !this._latlngs.length;
      },
      // @method closestLayerPoint(p: Point): Point
      // Returns the point closest to `p` on the Polyline.
      closestLayerPoint: function(p2) {
        var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p22;
        for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
          var points2 = this._parts[j];
          for (var i = 1, len = points2.length; i < len; i++) {
            p1 = points2[i - 1];
            p22 = points2[i];
            var sqDist = closest(p2, p1, p22, true);
            if (sqDist < minDistance) {
              minDistance = sqDist;
              minPoint = closest(p2, p1, p22);
            }
          }
        }
        if (minPoint) {
          minPoint.distance = Math.sqrt(minDistance);
        }
        return minPoint;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
      getCenter: function() {
        if (!this._map) {
          throw new Error("Must add layer to map before using getCenter()");
        }
        return polylineCenter(this._defaultShape(), this._map.options.crs);
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function() {
        return this._bounds;
      },
      // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
      // Adds a given point to the polyline. By default, adds to the first ring of
      // the polyline in case of a multi-polyline, but can be overridden by passing
      // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
      addLatLng: function(latlng, latlngs) {
        latlngs = latlngs || this._defaultShape();
        latlng = toLatLng2(latlng);
        latlngs.push(latlng);
        this._bounds.extend(latlng);
        return this.redraw();
      },
      _setLatLngs: function(latlngs) {
        this._bounds = new LatLngBounds();
        this._latlngs = this._convertLatLngs(latlngs);
      },
      _defaultShape: function() {
        return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
      _convertLatLngs: function(latlngs) {
        var result2 = [], flat = isFlat(latlngs);
        for (var i = 0, len = latlngs.length; i < len; i++) {
          if (flat) {
            result2[i] = toLatLng2(latlngs[i]);
            this._bounds.extend(result2[i]);
          } else {
            result2[i] = this._convertLatLngs(latlngs[i]);
          }
        }
        return result2;
      },
      _project: function() {
        var pxBounds = new Bounds();
        this._rings = [];
        this._projectLatlngs(this._latlngs, this._rings, pxBounds);
        if (this._bounds.isValid() && pxBounds.isValid()) {
          this._rawPxBounds = pxBounds;
          this._updateBounds();
        }
      },
      _updateBounds: function() {
        var w2 = this._clickTolerance(), p2 = new Point(w2, w2);
        if (!this._rawPxBounds) {
          return;
        }
        this._pxBounds = new Bounds([
          this._rawPxBounds.min.subtract(p2),
          this._rawPxBounds.max.add(p2)
        ]);
      },
      // recursively turns latlngs into a set of rings with projected coordinates
      _projectLatlngs: function(latlngs, result2, projectedBounds) {
        var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
        if (flat) {
          ring = [];
          for (i = 0; i < len; i++) {
            ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
            projectedBounds.extend(ring[i]);
          }
          result2.push(ring);
        } else {
          for (i = 0; i < len; i++) {
            this._projectLatlngs(latlngs[i], result2, projectedBounds);
          }
        }
      },
      // clip polyline by renderer bounds so that we have less to render for performance
      _clipPoints: function() {
        var bounds = this._renderer._bounds;
        this._parts = [];
        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }
        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }
        var parts = this._parts, i, j, k2, len, len2, segment, points2;
        for (i = 0, k2 = 0, len = this._rings.length; i < len; i++) {
          points2 = this._rings[i];
          for (j = 0, len2 = points2.length; j < len2 - 1; j++) {
            segment = clipSegment(points2[j], points2[j + 1], bounds, j, true);
            if (!segment) {
              continue;
            }
            parts[k2] = parts[k2] || [];
            parts[k2].push(segment[0]);
            if (segment[1] !== points2[j + 1] || j === len2 - 2) {
              parts[k2].push(segment[1]);
              k2++;
            }
          }
        }
      },
      // simplify each clipped part of the polyline for performance
      _simplifyPoints: function() {
        var parts = this._parts, tolerance = this.options.smoothFactor;
        for (var i = 0, len = parts.length; i < len; i++) {
          parts[i] = simplify(parts[i], tolerance);
        }
      },
      _update: function() {
        if (!this._map) {
          return;
        }
        this._clipPoints();
        this._simplifyPoints();
        this._updatePath();
      },
      _updatePath: function() {
        this._renderer._updatePoly(this);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(p2, closed) {
        var i, j, k2, len, len2, part, w2 = this._clickTolerance();
        if (!this._pxBounds || !this._pxBounds.contains(p2)) {
          return false;
        }
        for (i = 0, len = this._parts.length; i < len; i++) {
          part = this._parts[i];
          for (j = 0, len2 = part.length, k2 = len2 - 1; j < len2; k2 = j++) {
            if (!closed && j === 0) {
              continue;
            }
            if (pointToSegmentDistance(p2, part[k2], part[j]) <= w2) {
              return true;
            }
          }
        }
        return false;
      }
    });
    function polyline(latlngs, options) {
      return new Polyline(latlngs, options);
    }
    Polyline._flat = _flat;
    var Polygon = Polyline.extend({
      options: {
        fill: true
      },
      isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
      getCenter: function() {
        if (!this._map) {
          throw new Error("Must add layer to map before using getCenter()");
        }
        return polygonCenter(this._defaultShape(), this._map.options.crs);
      },
      _convertLatLngs: function(latlngs) {
        var result2 = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result2.length;
        if (len >= 2 && result2[0] instanceof LatLng && result2[0].equals(result2[len - 1])) {
          result2.pop();
        }
        return result2;
      },
      _setLatLngs: function(latlngs) {
        Polyline.prototype._setLatLngs.call(this, latlngs);
        if (isFlat(this._latlngs)) {
          this._latlngs = [this._latlngs];
        }
      },
      _defaultShape: function() {
        return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function() {
        var bounds = this._renderer._bounds, w2 = this.options.weight, p2 = new Point(w2, w2);
        bounds = new Bounds(bounds.min.subtract(p2), bounds.max.add(p2));
        this._parts = [];
        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }
        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }
        for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
          clipped = clipPolygon(this._rings[i], bounds, true);
          if (clipped.length) {
            this._parts.push(clipped);
          }
        }
      },
      _updatePath: function() {
        this._renderer._updatePoly(this, true);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function(p2) {
        var inside = false, part, p1, p22, i, j, k2, len, len2;
        if (!this._pxBounds || !this._pxBounds.contains(p2)) {
          return false;
        }
        for (i = 0, len = this._parts.length; i < len; i++) {
          part = this._parts[i];
          for (j = 0, len2 = part.length, k2 = len2 - 1; j < len2; k2 = j++) {
            p1 = part[j];
            p22 = part[k2];
            if (p1.y > p2.y !== p22.y > p2.y && p2.x < (p22.x - p1.x) * (p2.y - p1.y) / (p22.y - p1.y) + p1.x) {
              inside = !inside;
            }
          }
        }
        return inside || Polyline.prototype._containsPoint.call(this, p2, true);
      }
    });
    function polygon2(latlngs, options) {
      return new Polygon(latlngs, options);
    }
    var GeoJSON2 = FeatureGroup.extend({
      /* @section
       * @aka GeoJSON options
       *
       * @option pointToLayer: Function = *
       * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
       * called when data is added, passing the GeoJSON point feature and its `LatLng`.
       * The default is to spawn a default `Marker`:
       * ```js
       * function(geoJsonPoint, latlng) {
       * 	return L.marker(latlng);
       * }
       * ```
       *
       * @option style: Function = *
       * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
       * called internally when data is added.
       * The default value is to not override any defaults:
       * ```js
       * function (geoJsonFeature) {
       * 	return {}
       * }
       * ```
       *
       * @option onEachFeature: Function = *
       * A `Function` that will be called once for each created `Feature`, after it has
       * been created and styled. Useful for attaching events and popups to features.
       * The default is to do nothing with the newly created layers:
       * ```js
       * function (feature, layer) {}
       * ```
       *
       * @option filter: Function = *
       * A `Function` that will be used to decide whether to include a feature or not.
       * The default is to include all features:
       * ```js
       * function (geoJsonFeature) {
       * 	return true;
       * }
       * ```
       * Note: dynamically changing the `filter` option will have effect only on newly
       * added data. It will _not_ re-evaluate already included features.
       *
       * @option coordsToLatLng: Function = *
       * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
       * The default is the `coordsToLatLng` static method.
       *
       * @option markersInheritOptions: Boolean = false
       * Whether default Markers for "Point" type Features inherit from group options.
       */
      initialize: function(geojson, options) {
        setOptions(this, options);
        this._layers = {};
        if (geojson) {
          this.addData(geojson);
        }
      },
      // @method addData( <GeoJSON> data ): this
      // Adds a GeoJSON object to the layer.
      addData: function(geojson) {
        var features = isArray2(geojson) ? geojson : geojson.features, i, len, feature2;
        if (features) {
          for (i = 0, len = features.length; i < len; i++) {
            feature2 = features[i];
            if (feature2.geometries || feature2.geometry || feature2.features || feature2.coordinates) {
              this.addData(feature2);
            }
          }
          return this;
        }
        var options = this.options;
        if (options.filter && !options.filter(geojson)) {
          return this;
        }
        var layer = geometryToLayer(geojson, options);
        if (!layer) {
          return this;
        }
        layer.feature = asFeature(geojson);
        layer.defaultOptions = layer.options;
        this.resetStyle(layer);
        if (options.onEachFeature) {
          options.onEachFeature(geojson, layer);
        }
        return this.addLayer(layer);
      },
      // @method resetStyle( <Path> layer? ): this
      // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
      // If `layer` is omitted, the style of all features in the current layer is reset.
      resetStyle: function(layer) {
        if (layer === void 0) {
          return this.eachLayer(this.resetStyle, this);
        }
        layer.options = extend({}, layer.defaultOptions);
        this._setLayerStyle(layer, this.options.style);
        return this;
      },
      // @method setStyle( <Function> style ): this
      // Changes styles of GeoJSON vector layers with the given style function.
      setStyle: function(style2) {
        return this.eachLayer(function(layer) {
          this._setLayerStyle(layer, style2);
        }, this);
      },
      _setLayerStyle: function(layer, style2) {
        if (layer.setStyle) {
          if (typeof style2 === "function") {
            style2 = style2(layer.feature);
          }
          layer.setStyle(style2);
        }
      }
    });
    function geometryToLayer(geojson, options) {
      var geometry2 = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry2 ? geometry2.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
      if (!coords && !geometry2) {
        return null;
      }
      switch (geometry2.type) {
        case "Point":
          latlng = _coordsToLatLng(coords);
          return _pointToLayer(pointToLayer, geojson, latlng, options);
        case "MultiPoint":
          for (i = 0, len = coords.length; i < len; i++) {
            latlng = _coordsToLatLng(coords[i]);
            layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
          }
          return new FeatureGroup(layers2);
        case "LineString":
        case "MultiLineString":
          latlngs = coordsToLatLngs(coords, geometry2.type === "LineString" ? 0 : 1, _coordsToLatLng);
          return new Polyline(latlngs, options);
        case "Polygon":
        case "MultiPolygon":
          latlngs = coordsToLatLngs(coords, geometry2.type === "Polygon" ? 1 : 2, _coordsToLatLng);
          return new Polygon(latlngs, options);
        case "GeometryCollection":
          for (i = 0, len = geometry2.geometries.length; i < len; i++) {
            var geoLayer = geometryToLayer({
              geometry: geometry2.geometries[i],
              type: "Feature",
              properties: geojson.properties
            }, options);
            if (geoLayer) {
              layers2.push(geoLayer);
            }
          }
          return new FeatureGroup(layers2);
        case "FeatureCollection":
          for (i = 0, len = geometry2.features.length; i < len; i++) {
            var featureLayer = geometryToLayer(geometry2.features[i], options);
            if (featureLayer) {
              layers2.push(featureLayer);
            }
          }
          return new FeatureGroup(layers2);
        default:
          throw new Error("Invalid GeoJSON object.");
      }
    }
    function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
      return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker2(latlng, options && options.markersInheritOptions && options);
    }
    function coordsToLatLng(coords) {
      return new LatLng(coords[1], coords[0], coords[2]);
    }
    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
      var latlngs = [];
      for (var i = 0, len = coords.length, latlng; i < len; i++) {
        latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
        latlngs.push(latlng);
      }
      return latlngs;
    }
    function latLngToCoords(latlng, precision) {
      latlng = toLatLng2(latlng);
      return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
    }
    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
      var coords = [];
      for (var i = 0, len = latlngs.length; i < len; i++) {
        coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
      }
      if (!levelsDeep && closed && coords.length > 0) {
        coords.push(coords[0].slice());
      }
      return coords;
    }
    function getFeature(layer, newGeometry) {
      return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
    }
    function asFeature(geojson) {
      if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
        return geojson;
      }
      return {
        type: "Feature",
        properties: {},
        geometry: geojson
      };
    }
    var PointToGeoJSON = {
      toGeoJSON: function(precision) {
        return getFeature(this, {
          type: "Point",
          coordinates: latLngToCoords(this.getLatLng(), precision)
        });
      }
    };
    Marker2.include(PointToGeoJSON);
    Circle.include(PointToGeoJSON);
    CircleMarker.include(PointToGeoJSON);
    Polyline.include({
      toGeoJSON: function(precision) {
        var multi = !isFlat(this._latlngs);
        var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
        return getFeature(this, {
          type: (multi ? "Multi" : "") + "LineString",
          coordinates: coords
        });
      }
    });
    Polygon.include({
      toGeoJSON: function(precision) {
        var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
        var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
        if (!holes) {
          coords = [coords];
        }
        return getFeature(this, {
          type: (multi ? "Multi" : "") + "Polygon",
          coordinates: coords
        });
      }
    });
    LayerGroup.include({
      toMultiPoint: function(precision) {
        var coords = [];
        this.eachLayer(function(layer) {
          coords.push(layer.toGeoJSON(precision).geometry.coordinates);
        });
        return getFeature(this, {
          type: "MultiPoint",
          coordinates: coords
        });
      },
      // @method toGeoJSON(precision?: Number|false): Object
      // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
      // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
      toGeoJSON: function(precision) {
        var type2 = this.feature && this.feature.geometry && this.feature.geometry.type;
        if (type2 === "MultiPoint") {
          return this.toMultiPoint(precision);
        }
        var isGeometryCollection = type2 === "GeometryCollection", jsons = [];
        this.eachLayer(function(layer) {
          if (layer.toGeoJSON) {
            var json = layer.toGeoJSON(precision);
            if (isGeometryCollection) {
              jsons.push(json.geometry);
            } else {
              var feature2 = asFeature(json);
              if (feature2.type === "FeatureCollection") {
                jsons.push.apply(jsons, feature2.features);
              } else {
                jsons.push(feature2);
              }
            }
          }
        });
        if (isGeometryCollection) {
          return getFeature(this, {
            geometries: jsons,
            type: "GeometryCollection"
          });
        }
        return {
          type: "FeatureCollection",
          features: jsons
        };
      }
    });
    function geoJSON(geojson, options) {
      return new GeoJSON2(geojson, options);
    }
    var geoJson = geoJSON;
    var ImageOverlay = Layer.extend({
      // @section
      // @aka ImageOverlay options
      options: {
        // @option opacity: Number = 1.0
        // The opacity of the image overlay.
        opacity: 1,
        // @option alt: String = ''
        // Text for the `alt` attribute of the image (useful for accessibility).
        alt: "",
        // @option interactive: Boolean = false
        // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
        interactive: false,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the image.
        // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: false,
        // @option errorOverlayUrl: String = ''
        // URL to the overlay image to show in place of the overlay that failed to load.
        errorOverlayUrl: "",
        // @option zIndex: Number = 1
        // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
        zIndex: 1,
        // @option className: String = ''
        // A custom class name to assign to the image. Empty by default.
        className: ""
      },
      initialize: function(url, bounds, options) {
        this._url = url;
        this._bounds = toLatLngBounds(bounds);
        setOptions(this, options);
      },
      onAdd: function() {
        if (!this._image) {
          this._initImage();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
        }
        if (this.options.interactive) {
          addClass(this._image, "leaflet-interactive");
          this.addInteractiveTarget(this._image);
        }
        this.getPane().appendChild(this._image);
        this._reset();
      },
      onRemove: function() {
        remove(this._image);
        if (this.options.interactive) {
          this.removeInteractiveTarget(this._image);
        }
      },
      // @method setOpacity(opacity: Number): this
      // Sets the opacity of the overlay.
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._image) {
          this._updateOpacity();
        }
        return this;
      },
      setStyle: function(styleOpts) {
        if (styleOpts.opacity) {
          this.setOpacity(styleOpts.opacity);
        }
        return this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all overlays.
      bringToFront: function() {
        if (this._map) {
          toFront(this._image);
        }
        return this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all overlays.
      bringToBack: function() {
        if (this._map) {
          toBack(this._image);
        }
        return this;
      },
      // @method setUrl(url: String): this
      // Changes the URL of the image.
      setUrl: function(url) {
        this._url = url;
        if (this._image) {
          this._image.src = url;
        }
        return this;
      },
      // @method setBounds(bounds: LatLngBounds): this
      // Update the bounds that this ImageOverlay covers
      setBounds: function(bounds) {
        this._bounds = toLatLngBounds(bounds);
        if (this._map) {
          this._reset();
        }
        return this;
      },
      getEvents: function() {
        var events = {
          zoom: this._reset,
          viewreset: this._reset
        };
        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }
        return events;
      },
      // @method setZIndex(value: Number): this
      // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
      setZIndex: function(value) {
        this.options.zIndex = value;
        this._updateZIndex();
        return this;
      },
      // @method getBounds(): LatLngBounds
      // Get the bounds that this ImageOverlay covers
      getBounds: function() {
        return this._bounds;
      },
      // @method getElement(): HTMLElement
      // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
      // used by this overlay.
      getElement: function() {
        return this._image;
      },
      _initImage: function() {
        var wasElementSupplied = this._url.tagName === "IMG";
        var img = this._image = wasElementSupplied ? this._url : create$1("img");
        addClass(img, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(img, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(img, this.options.className);
        }
        img.onselectstart = falseFn;
        img.onmousemove = falseFn;
        img.onload = bind3(this.fire, this, "load");
        img.onerror = bind3(this._overlayOnError, this, "error");
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        if (this.options.zIndex) {
          this._updateZIndex();
        }
        if (wasElementSupplied) {
          this._url = img.src;
          return;
        }
        img.src = this._url;
        img.alt = this.options.alt;
      },
      _animateZoom: function(e2) {
        var scale2 = this._map.getZoomScale(e2.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e2.zoom, e2.center).min;
        setTransform(this._image, offset, scale2);
      },
      _reset: function() {
        var image = this._image, bounds = new Bounds(
          this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
          this._map.latLngToLayerPoint(this._bounds.getSouthEast())
        ), size = bounds.getSize();
        setPosition(image, bounds.min);
        image.style.width = size.x + "px";
        image.style.height = size.y + "px";
      },
      _updateOpacity: function() {
        setOpacity(this._image, this.options.opacity);
      },
      _updateZIndex: function() {
        if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
          this._image.style.zIndex = this.options.zIndex;
        }
      },
      _overlayOnError: function() {
        this.fire("error");
        var errorUrl = this.options.errorOverlayUrl;
        if (errorUrl && this._url !== errorUrl) {
          this._url = errorUrl;
          this._image.src = errorUrl;
        }
      },
      // @method getCenter(): LatLng
      // Returns the center of the ImageOverlay.
      getCenter: function() {
        return this._bounds.getCenter();
      }
    });
    var imageOverlay = function(url, bounds, options) {
      return new ImageOverlay(url, bounds, options);
    };
    var VideoOverlay = ImageOverlay.extend({
      // @section
      // @aka VideoOverlay options
      options: {
        // @option autoplay: Boolean = true
        // Whether the video starts playing automatically when loaded.
        // On some browsers autoplay will only work with `muted: true`
        autoplay: true,
        // @option loop: Boolean = true
        // Whether the video will loop back to the beginning when played.
        loop: true,
        // @option keepAspectRatio: Boolean = true
        // Whether the video will save aspect ratio after the projection.
        // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
        keepAspectRatio: true,
        // @option muted: Boolean = false
        // Whether the video starts on mute when loaded.
        muted: false,
        // @option playsInline: Boolean = true
        // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
        playsInline: true
      },
      _initImage: function() {
        var wasElementSupplied = this._url.tagName === "VIDEO";
        var vid = this._image = wasElementSupplied ? this._url : create$1("video");
        addClass(vid, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(vid, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(vid, this.options.className);
        }
        vid.onselectstart = falseFn;
        vid.onmousemove = falseFn;
        vid.onloadeddata = bind3(this.fire, this, "load");
        if (wasElementSupplied) {
          var sourceElements = vid.getElementsByTagName("source");
          var sources = [];
          for (var j = 0; j < sourceElements.length; j++) {
            sources.push(sourceElements[j].src);
          }
          this._url = sourceElements.length > 0 ? sources : [vid.src];
          return;
        }
        if (!isArray2(this._url)) {
          this._url = [this._url];
        }
        if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
          vid.style["objectFit"] = "fill";
        }
        vid.autoplay = !!this.options.autoplay;
        vid.loop = !!this.options.loop;
        vid.muted = !!this.options.muted;
        vid.playsInline = !!this.options.playsInline;
        for (var i = 0; i < this._url.length; i++) {
          var source = create$1("source");
          source.src = this._url[i];
          vid.appendChild(source);
        }
      }
      // @method getElement(): HTMLVideoElement
      // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
      // used by this overlay.
    });
    function videoOverlay(video, bounds, options) {
      return new VideoOverlay(video, bounds, options);
    }
    var SVGOverlay = ImageOverlay.extend({
      _initImage: function() {
        var el2 = this._image = this._url;
        addClass(el2, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(el2, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(el2, this.options.className);
        }
        el2.onselectstart = falseFn;
        el2.onmousemove = falseFn;
      }
      // @method getElement(): SVGElement
      // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
      // used by this overlay.
    });
    function svgOverlay(el2, bounds, options) {
      return new SVGOverlay(el2, bounds, options);
    }
    var DivOverlay = Layer.extend({
      // @section
      // @aka DivOverlay options
      options: {
        // @option interactive: Boolean = false
        // If true, the popup/tooltip will listen to the mouse events.
        interactive: false,
        // @option offset: Point = Point(0, 0)
        // The offset of the overlay position.
        offset: [0, 0],
        // @option className: String = ''
        // A custom CSS class name to assign to the overlay.
        className: "",
        // @option pane: String = undefined
        // `Map pane` where the overlay will be added.
        pane: void 0,
        // @option content: String|HTMLElement|Function = ''
        // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
        // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
        content: ""
      },
      initialize: function(options, source) {
        if (options && (options instanceof LatLng || isArray2(options))) {
          this._latlng = toLatLng2(options);
          setOptions(this, source);
        } else {
          setOptions(this, options);
          this._source = source;
        }
        if (this.options.content) {
          this._content = this.options.content;
        }
      },
      // @method openOn(map: Map): this
      // Adds the overlay to the map.
      // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
      openOn: function(map) {
        map = arguments.length ? map : this._source._map;
        if (!map.hasLayer(this)) {
          map.addLayer(this);
        }
        return this;
      },
      // @method close(): this
      // Closes the overlay.
      // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
      // and `layer.closePopup()`/`.closeTooltip()`.
      close: function() {
        if (this._map) {
          this._map.removeLayer(this);
        }
        return this;
      },
      // @method toggle(layer?: Layer): this
      // Opens or closes the overlay bound to layer depending on its current state.
      // Argument may be omitted only for overlay bound to layer.
      // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
      toggle: function(layer) {
        if (this._map) {
          this.close();
        } else {
          if (arguments.length) {
            this._source = layer;
          } else {
            layer = this._source;
          }
          this._prepareOpen();
          this.openOn(layer._map);
        }
        return this;
      },
      onAdd: function(map) {
        this._zoomAnimated = map._zoomAnimated;
        if (!this._container) {
          this._initLayout();
        }
        if (map._fadeAnimated) {
          setOpacity(this._container, 0);
        }
        clearTimeout(this._removeTimeout);
        this.getPane().appendChild(this._container);
        this.update();
        if (map._fadeAnimated) {
          setOpacity(this._container, 1);
        }
        this.bringToFront();
        if (this.options.interactive) {
          addClass(this._container, "leaflet-interactive");
          this.addInteractiveTarget(this._container);
        }
      },
      onRemove: function(map) {
        if (map._fadeAnimated) {
          setOpacity(this._container, 0);
          this._removeTimeout = setTimeout(bind3(remove, void 0, this._container), 200);
        } else {
          remove(this._container);
        }
        if (this.options.interactive) {
          removeClass(this._container, "leaflet-interactive");
          this.removeInteractiveTarget(this._container);
        }
      },
      // @namespace DivOverlay
      // @method getLatLng: LatLng
      // Returns the geographical point of the overlay.
      getLatLng: function() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Sets the geographical point where the overlay will open.
      setLatLng: function(latlng) {
        this._latlng = toLatLng2(latlng);
        if (this._map) {
          this._updatePosition();
          this._adjustPan();
        }
        return this;
      },
      // @method getContent: String|HTMLElement
      // Returns the content of the overlay.
      getContent: function() {
        return this._content;
      },
      // @method setContent(htmlContent: String|HTMLElement|Function): this
      // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
      // The function should return a `String` or `HTMLElement` to be used in the overlay.
      setContent: function(content) {
        this._content = content;
        this.update();
        return this;
      },
      // @method getElement: String|HTMLElement
      // Returns the HTML container of the overlay.
      getElement: function() {
        return this._container;
      },
      // @method update: null
      // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
      update: function() {
        if (!this._map) {
          return;
        }
        this._container.style.visibility = "hidden";
        this._updateContent();
        this._updateLayout();
        this._updatePosition();
        this._container.style.visibility = "";
        this._adjustPan();
      },
      getEvents: function() {
        var events = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }
        return events;
      },
      // @method isOpen: Boolean
      // Returns `true` when the overlay is visible on the map.
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      },
      // @method bringToFront: this
      // Brings this overlay in front of other overlays (in the same map pane).
      bringToFront: function() {
        if (this._map) {
          toFront(this._container);
        }
        return this;
      },
      // @method bringToBack: this
      // Brings this overlay to the back of other overlays (in the same map pane).
      bringToBack: function() {
        if (this._map) {
          toBack(this._container);
        }
        return this;
      },
      // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
      _prepareOpen: function(latlng) {
        var source = this._source;
        if (!source._map) {
          return false;
        }
        if (source instanceof FeatureGroup) {
          source = null;
          var layers2 = this._source._layers;
          for (var id2 in layers2) {
            if (layers2[id2]._map) {
              source = layers2[id2];
              break;
            }
          }
          if (!source) {
            return false;
          }
          this._source = source;
        }
        if (!latlng) {
          if (source.getCenter) {
            latlng = source.getCenter();
          } else if (source.getLatLng) {
            latlng = source.getLatLng();
          } else if (source.getBounds) {
            latlng = source.getBounds().getCenter();
          } else {
            throw new Error("Unable to get source layer LatLng.");
          }
        }
        this.setLatLng(latlng);
        if (this._map) {
          this.update();
        }
        return true;
      },
      _updateContent: function() {
        if (!this._content) {
          return;
        }
        var node = this._contentNode;
        var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
        if (typeof content === "string") {
          node.innerHTML = content;
        } else {
          while (node.hasChildNodes()) {
            node.removeChild(node.firstChild);
          }
          node.appendChild(content);
        }
        this.fire("contentupdate");
      },
      _updatePosition: function() {
        if (!this._map) {
          return;
        }
        var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
        if (this._zoomAnimated) {
          setPosition(this._container, pos.add(anchor));
        } else {
          offset = offset.add(pos).add(anchor);
        }
        var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
        this._container.style.bottom = bottom + "px";
        this._container.style.left = left + "px";
      },
      _getAnchor: function() {
        return [0, 0];
      }
    });
    Map2.include({
      _initOverlay: function(OverlayClass, content, latlng, options) {
        var overlay = content;
        if (!(overlay instanceof OverlayClass)) {
          overlay = new OverlayClass(options).setContent(content);
        }
        if (latlng) {
          overlay.setLatLng(latlng);
        }
        return overlay;
      }
    });
    Layer.include({
      _initOverlay: function(OverlayClass, old, content, options) {
        var overlay = content;
        if (overlay instanceof OverlayClass) {
          setOptions(overlay, options);
          overlay._source = this;
        } else {
          overlay = old && !options ? old : new OverlayClass(options, this);
          overlay.setContent(content);
        }
        return overlay;
      }
    });
    var Popup = DivOverlay.extend({
      // @section
      // @aka Popup options
      options: {
        // @option pane: String = 'popupPane'
        // `Map pane` where the popup will be added.
        pane: "popupPane",
        // @option offset: Point = Point(0, 7)
        // The offset of the popup position.
        offset: [0, 7],
        // @option maxWidth: Number = 300
        // Max width of the popup, in pixels.
        maxWidth: 300,
        // @option minWidth: Number = 50
        // Min width of the popup, in pixels.
        minWidth: 50,
        // @option maxHeight: Number = null
        // If set, creates a scrollable container of the given height
        // inside a popup if its content exceeds it.
        // The scrollable container can be styled using the
        // `leaflet-popup-scrolled` CSS class selector.
        maxHeight: null,
        // @option autoPan: Boolean = true
        // Set it to `false` if you don't want the map to do panning animation
        // to fit the opened popup.
        autoPan: true,
        // @option autoPanPaddingTopLeft: Point = null
        // The margin between the popup and the top left corner of the map
        // view after autopanning was performed.
        autoPanPaddingTopLeft: null,
        // @option autoPanPaddingBottomRight: Point = null
        // The margin between the popup and the bottom right corner of the map
        // view after autopanning was performed.
        autoPanPaddingBottomRight: null,
        // @option autoPanPadding: Point = Point(5, 5)
        // Equivalent of setting both top left and bottom right autopan padding to the same value.
        autoPanPadding: [5, 5],
        // @option keepInView: Boolean = false
        // Set it to `true` if you want to prevent users from panning the popup
        // off of the screen while it is open.
        keepInView: false,
        // @option closeButton: Boolean = true
        // Controls the presence of a close button in the popup.
        closeButton: true,
        // @option autoClose: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the popup closing when another popup is opened.
        autoClose: true,
        // @option closeOnEscapeKey: Boolean = true
        // Set it to `false` if you want to override the default behavior of
        // the ESC key for closing of the popup.
        closeOnEscapeKey: true,
        // @option closeOnClick: Boolean = *
        // Set it if you want to override the default behavior of the popup closing when user clicks
        // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
        // @option className: String = ''
        // A custom CSS class name to assign to the popup.
        className: ""
      },
      // @namespace Popup
      // @method openOn(map: Map): this
      // Alternative to `map.openPopup(popup)`.
      // Adds the popup to the map and closes the previous one.
      openOn: function(map) {
        map = arguments.length ? map : this._source._map;
        if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
          map.removeLayer(map._popup);
        }
        map._popup = this;
        return DivOverlay.prototype.openOn.call(this, map);
      },
      onAdd: function(map) {
        DivOverlay.prototype.onAdd.call(this, map);
        map.fire("popupopen", { popup: this });
        if (this._source) {
          this._source.fire("popupopen", { popup: this }, true);
          if (!(this._source instanceof Path)) {
            this._source.on("preclick", stopPropagation);
          }
        }
      },
      onRemove: function(map) {
        DivOverlay.prototype.onRemove.call(this, map);
        map.fire("popupclose", { popup: this });
        if (this._source) {
          this._source.fire("popupclose", { popup: this }, true);
          if (!(this._source instanceof Path)) {
            this._source.off("preclick", stopPropagation);
          }
        }
      },
      getEvents: function() {
        var events = DivOverlay.prototype.getEvents.call(this);
        if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
          events.preclick = this.close;
        }
        if (this.options.keepInView) {
          events.moveend = this._adjustPan;
        }
        return events;
      },
      _initLayout: function() {
        var prefix = "leaflet-popup", container = this._container = create$1(
          "div",
          prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
        );
        var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
        this._contentNode = create$1("div", prefix + "-content", wrapper);
        disableClickPropagation(container);
        disableScrollPropagation(this._contentNode);
        on(container, "contextmenu", stopPropagation);
        this._tipContainer = create$1("div", prefix + "-tip-container", container);
        this._tip = create$1("div", prefix + "-tip", this._tipContainer);
        if (this.options.closeButton) {
          var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
          closeButton.setAttribute("role", "button");
          closeButton.setAttribute("aria-label", "Close popup");
          closeButton.href = "#close";
          closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
          on(closeButton, "click", function(ev) {
            preventDefault(ev);
            this.close();
          }, this);
        }
      },
      _updateLayout: function() {
        var container = this._contentNode, style2 = container.style;
        style2.width = "";
        style2.whiteSpace = "nowrap";
        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);
        style2.width = width + 1 + "px";
        style2.whiteSpace = "";
        style2.height = "";
        var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
        if (maxHeight && height > maxHeight) {
          style2.height = maxHeight + "px";
          addClass(container, scrolledClass);
        } else {
          removeClass(container, scrolledClass);
        }
        this._containerWidth = this._container.offsetWidth;
      },
      _animateZoom: function(e2) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, e2.zoom, e2.center), anchor = this._getAnchor();
        setPosition(this._container, pos.add(anchor));
      },
      _adjustPan: function() {
        if (!this.options.autoPan) {
          return;
        }
        if (this._map._panAnim) {
          this._map._panAnim.stop();
        }
        if (this._autopanning) {
          this._autopanning = false;
          return;
        }
        var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
        layerPos._add(getPosition(this._container));
        var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
        if (containerPos.x + containerWidth + paddingBR.x > size.x) {
          dx = containerPos.x + containerWidth - size.x + paddingBR.x;
        }
        if (containerPos.x - dx - paddingTL.x < 0) {
          dx = containerPos.x - paddingTL.x;
        }
        if (containerPos.y + containerHeight + paddingBR.y > size.y) {
          dy = containerPos.y + containerHeight - size.y + paddingBR.y;
        }
        if (containerPos.y - dy - paddingTL.y < 0) {
          dy = containerPos.y - paddingTL.y;
        }
        if (dx || dy) {
          if (this.options.keepInView) {
            this._autopanning = true;
          }
          map.fire("autopanstart").panBy([dx, dy]);
        }
      },
      _getAnchor: function() {
        return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      }
    });
    var popup = function(options, source) {
      return new Popup(options, source);
    };
    Map2.mergeOptions({
      closePopupOnClick: true
    });
    Map2.include({
      // @method openPopup(popup: Popup): this
      // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
      // @alternative
      // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
      // Creates a popup with the specified content and options and opens it in the given point on a map.
      openPopup: function(popup2, latlng, options) {
        this._initOverlay(Popup, popup2, latlng, options).openOn(this);
        return this;
      },
      // @method closePopup(popup?: Popup): this
      // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
      closePopup: function(popup2) {
        popup2 = arguments.length ? popup2 : this._popup;
        if (popup2) {
          popup2.close();
        }
        return this;
      }
    });
    Layer.include({
      // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
      // Binds a popup to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindPopup: function(content, options) {
        this._popup = this._initOverlay(Popup, this._popup, content, options);
        if (!this._popupHandlersAdded) {
          this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          });
          this._popupHandlersAdded = true;
        }
        return this;
      },
      // @method unbindPopup(): this
      // Removes the popup previously bound with `bindPopup`.
      unbindPopup: function() {
        if (this._popup) {
          this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          });
          this._popupHandlersAdded = false;
          this._popup = null;
        }
        return this;
      },
      // @method openPopup(latlng?: LatLng): this
      // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
      openPopup: function(latlng) {
        if (this._popup) {
          if (!(this instanceof FeatureGroup)) {
            this._popup._source = this;
          }
          if (this._popup._prepareOpen(latlng || this._latlng)) {
            this._popup.openOn(this._map);
          }
        }
        return this;
      },
      // @method closePopup(): this
      // Closes the popup bound to this layer if it is open.
      closePopup: function() {
        if (this._popup) {
          this._popup.close();
        }
        return this;
      },
      // @method togglePopup(): this
      // Opens or closes the popup bound to this layer depending on its current state.
      togglePopup: function() {
        if (this._popup) {
          this._popup.toggle(this);
        }
        return this;
      },
      // @method isPopupOpen(): boolean
      // Returns `true` if the popup bound to this layer is currently open.
      isPopupOpen: function() {
        return this._popup ? this._popup.isOpen() : false;
      },
      // @method setPopupContent(content: String|HTMLElement|Popup): this
      // Sets the content of the popup bound to this layer.
      setPopupContent: function(content) {
        if (this._popup) {
          this._popup.setContent(content);
        }
        return this;
      },
      // @method getPopup(): Popup
      // Returns the popup bound to this layer.
      getPopup: function() {
        return this._popup;
      },
      _openPopup: function(e2) {
        if (!this._popup || !this._map) {
          return;
        }
        stop(e2);
        var target = e2.layer || e2.target;
        if (this._popup._source === target && !(target instanceof Path)) {
          if (this._map.hasLayer(this._popup)) {
            this.closePopup();
          } else {
            this.openPopup(e2.latlng);
          }
          return;
        }
        this._popup._source = target;
        this.openPopup(e2.latlng);
      },
      _movePopup: function(e2) {
        this._popup.setLatLng(e2.latlng);
      },
      _onKeyPress: function(e2) {
        if (e2.originalEvent.keyCode === 13) {
          this._openPopup(e2);
        }
      }
    });
    var Tooltip = DivOverlay.extend({
      // @section
      // @aka Tooltip options
      options: {
        // @option pane: String = 'tooltipPane'
        // `Map pane` where the tooltip will be added.
        pane: "tooltipPane",
        // @option offset: Point = Point(0, 0)
        // Optional offset of the tooltip position.
        offset: [0, 0],
        // @option direction: String = 'auto'
        // Direction where to open the tooltip. Possible values are: `right`, `left`,
        // `top`, `bottom`, `center`, `auto`.
        // `auto` will dynamically switch between `right` and `left` according to the tooltip
        // position on the map.
        direction: "auto",
        // @option permanent: Boolean = false
        // Whether to open the tooltip permanently or only on mouseover.
        permanent: false,
        // @option sticky: Boolean = false
        // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
        sticky: false,
        // @option opacity: Number = 0.9
        // Tooltip container opacity.
        opacity: 0.9
      },
      onAdd: function(map) {
        DivOverlay.prototype.onAdd.call(this, map);
        this.setOpacity(this.options.opacity);
        map.fire("tooltipopen", { tooltip: this });
        if (this._source) {
          this.addEventParent(this._source);
          this._source.fire("tooltipopen", { tooltip: this }, true);
        }
      },
      onRemove: function(map) {
        DivOverlay.prototype.onRemove.call(this, map);
        map.fire("tooltipclose", { tooltip: this });
        if (this._source) {
          this.removeEventParent(this._source);
          this._source.fire("tooltipclose", { tooltip: this }, true);
        }
      },
      getEvents: function() {
        var events = DivOverlay.prototype.getEvents.call(this);
        if (!this.options.permanent) {
          events.preclick = this.close;
        }
        return events;
      },
      _initLayout: function() {
        var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = create$1("div", className);
        this._container.setAttribute("role", "tooltip");
        this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
      },
      _updateLayout: function() {
      },
      _adjustPan: function() {
      },
      _setPosition: function(pos) {
        var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
        if (direction === "top") {
          subX = tooltipWidth / 2;
          subY = tooltipHeight;
        } else if (direction === "bottom") {
          subX = tooltipWidth / 2;
          subY = 0;
        } else if (direction === "center") {
          subX = tooltipWidth / 2;
          subY = tooltipHeight / 2;
        } else if (direction === "right") {
          subX = 0;
          subY = tooltipHeight / 2;
        } else if (direction === "left") {
          subX = tooltipWidth;
          subY = tooltipHeight / 2;
        } else if (tooltipPoint.x < centerPoint.x) {
          direction = "right";
          subX = 0;
          subY = tooltipHeight / 2;
        } else {
          direction = "left";
          subX = tooltipWidth + (offset.x + anchor.x) * 2;
          subY = tooltipHeight / 2;
        }
        pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
        removeClass(container, "leaflet-tooltip-right");
        removeClass(container, "leaflet-tooltip-left");
        removeClass(container, "leaflet-tooltip-top");
        removeClass(container, "leaflet-tooltip-bottom");
        addClass(container, "leaflet-tooltip-" + direction);
        setPosition(container, pos);
      },
      _updatePosition: function() {
        var pos = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(pos);
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._container) {
          setOpacity(this._container, opacity);
        }
      },
      _animateZoom: function(e2) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, e2.zoom, e2.center);
        this._setPosition(pos);
      },
      _getAnchor: function() {
        return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      }
    });
    var tooltip = function(options, source) {
      return new Tooltip(options, source);
    };
    Map2.include({
      // @method openTooltip(tooltip: Tooltip): this
      // Opens the specified tooltip.
      // @alternative
      // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
      // Creates a tooltip with the specified content and options and open it.
      openTooltip: function(tooltip2, latlng, options) {
        this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
        return this;
      },
      // @method closeTooltip(tooltip: Tooltip): this
      // Closes the tooltip given as parameter.
      closeTooltip: function(tooltip2) {
        tooltip2.close();
        return this;
      }
    });
    Layer.include({
      // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
      // Binds a tooltip to the layer with the passed `content` and sets up the
      // necessary event listeners. If a `Function` is passed it will receive
      // the layer as the first argument and should return a `String` or `HTMLElement`.
      bindTooltip: function(content, options) {
        if (this._tooltip && this.isTooltipOpen()) {
          this.unbindTooltip();
        }
        this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
        this._initTooltipInteractions();
        if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
          this.openTooltip();
        }
        return this;
      },
      // @method unbindTooltip(): this
      // Removes the tooltip previously bound with `bindTooltip`.
      unbindTooltip: function() {
        if (this._tooltip) {
          this._initTooltipInteractions(true);
          this.closeTooltip();
          this._tooltip = null;
        }
        return this;
      },
      _initTooltipInteractions: function(remove2) {
        if (!remove2 && this._tooltipHandlersAdded) {
          return;
        }
        var onOff = remove2 ? "off" : "on", events = {
          remove: this.closeTooltip,
          move: this._moveTooltip
        };
        if (!this._tooltip.options.permanent) {
          events.mouseover = this._openTooltip;
          events.mouseout = this.closeTooltip;
          events.click = this._openTooltip;
          if (this._map) {
            this._addFocusListeners();
          } else {
            events.add = this._addFocusListeners;
          }
        } else {
          events.add = this._openTooltip;
        }
        if (this._tooltip.options.sticky) {
          events.mousemove = this._moveTooltip;
        }
        this[onOff](events);
        this._tooltipHandlersAdded = !remove2;
      },
      // @method openTooltip(latlng?: LatLng): this
      // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
      openTooltip: function(latlng) {
        if (this._tooltip) {
          if (!(this instanceof FeatureGroup)) {
            this._tooltip._source = this;
          }
          if (this._tooltip._prepareOpen(latlng)) {
            this._tooltip.openOn(this._map);
            if (this.getElement) {
              this._setAriaDescribedByOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._setAriaDescribedByOnLayer, this);
            }
          }
        }
        return this;
      },
      // @method closeTooltip(): this
      // Closes the tooltip bound to this layer if it is open.
      closeTooltip: function() {
        if (this._tooltip) {
          return this._tooltip.close();
        }
      },
      // @method toggleTooltip(): this
      // Opens or closes the tooltip bound to this layer depending on its current state.
      toggleTooltip: function() {
        if (this._tooltip) {
          this._tooltip.toggle(this);
        }
        return this;
      },
      // @method isTooltipOpen(): boolean
      // Returns `true` if the tooltip bound to this layer is currently open.
      isTooltipOpen: function() {
        return this._tooltip.isOpen();
      },
      // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
      // Sets the content of the tooltip bound to this layer.
      setTooltipContent: function(content) {
        if (this._tooltip) {
          this._tooltip.setContent(content);
        }
        return this;
      },
      // @method getTooltip(): Tooltip
      // Returns the tooltip bound to this layer.
      getTooltip: function() {
        return this._tooltip;
      },
      _addFocusListeners: function() {
        if (this.getElement) {
          this._addFocusListenersOnLayer(this);
        } else if (this.eachLayer) {
          this.eachLayer(this._addFocusListenersOnLayer, this);
        }
      },
      _addFocusListenersOnLayer: function(layer) {
        var el2 = typeof layer.getElement === "function" && layer.getElement();
        if (el2) {
          on(el2, "focus", function() {
            this._tooltip._source = layer;
            this.openTooltip();
          }, this);
          on(el2, "blur", this.closeTooltip, this);
        }
      },
      _setAriaDescribedByOnLayer: function(layer) {
        var el2 = typeof layer.getElement === "function" && layer.getElement();
        if (el2) {
          el2.setAttribute("aria-describedby", this._tooltip._container.id);
        }
      },
      _openTooltip: function(e2) {
        if (!this._tooltip || !this._map) {
          return;
        }
        if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
          this._openOnceFlag = true;
          var that = this;
          this._map.once("moveend", function() {
            that._openOnceFlag = false;
            that._openTooltip(e2);
          });
          return;
        }
        this._tooltip._source = e2.layer || e2.target;
        this.openTooltip(this._tooltip.options.sticky ? e2.latlng : void 0);
      },
      _moveTooltip: function(e2) {
        var latlng = e2.latlng, containerPoint, layerPoint;
        if (this._tooltip.options.sticky && e2.originalEvent) {
          containerPoint = this._map.mouseEventToContainerPoint(e2.originalEvent);
          layerPoint = this._map.containerPointToLayerPoint(containerPoint);
          latlng = this._map.layerPointToLatLng(layerPoint);
        }
        this._tooltip.setLatLng(latlng);
      }
    });
    var DivIcon = Icon.extend({
      options: {
        // @section
        // @aka DivIcon options
        iconSize: [12, 12],
        // also can be set through CSS
        // iconAnchor: (Point),
        // popupAnchor: (Point),
        // @option html: String|HTMLElement = ''
        // Custom HTML code to put inside the div element, empty by default. Alternatively,
        // an instance of `HTMLElement`.
        html: false,
        // @option bgPos: Point = [0, 0]
        // Optional relative position of the background, in pixels
        bgPos: null,
        className: "leaflet-div-icon"
      },
      createIcon: function(oldIcon) {
        var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
        if (options.html instanceof Element) {
          empty(div);
          div.appendChild(options.html);
        } else {
          div.innerHTML = options.html !== false ? options.html : "";
        }
        if (options.bgPos) {
          var bgPos = toPoint(options.bgPos);
          div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
        }
        this._setIconStyles(div, "icon");
        return div;
      },
      createShadow: function() {
        return null;
      }
    });
    function divIcon(options) {
      return new DivIcon(options);
    }
    Icon.Default = IconDefault;
    var GridLayer = Layer.extend({
      // @section
      // @aka GridLayer options
      options: {
        // @option tileSize: Number|Point = 256
        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
        tileSize: 256,
        // @option opacity: Number = 1.0
        // Opacity of the tiles. Can be used in the `createTile()` function.
        opacity: 1,
        // @option updateWhenIdle: Boolean = (depends)
        // Load new tiles only when panning ends.
        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
        updateWhenIdle: Browser.mobile,
        // @option updateWhenZooming: Boolean = true
        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
        updateWhenZooming: true,
        // @option updateInterval: Number = 200
        // Tiles will not update more than once every `updateInterval` milliseconds when panning.
        updateInterval: 200,
        // @option zIndex: Number = 1
        // The explicit zIndex of the tile layer.
        zIndex: 1,
        // @option bounds: LatLngBounds = undefined
        // If set, tiles will only be loaded inside the set `LatLngBounds`.
        bounds: null,
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = undefined
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: void 0,
        // @option maxNativeZoom: Number = undefined
        // Maximum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
        // from `maxNativeZoom` level and auto-scaled.
        maxNativeZoom: void 0,
        // @option minNativeZoom: Number = undefined
        // Minimum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
        // from `minNativeZoom` level and auto-scaled.
        minNativeZoom: void 0,
        // @option noWrap: Boolean = false
        // Whether the layer is wrapped around the antimeridian. If `true`, the
        // GridLayer will only be displayed once at low zoom levels. Has no
        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
        // tiles outside the CRS limits.
        noWrap: false,
        // @option pane: String = 'tilePane'
        // `Map pane` where the grid layer will be added.
        pane: "tilePane",
        // @option className: String = ''
        // A custom class name to assign to the tile layer. Empty by default.
        className: "",
        // @option keepBuffer: Number = 2
        // When panning the map, keep this many rows and columns of tiles before unloading them.
        keepBuffer: 2
      },
      initialize: function(options) {
        setOptions(this, options);
      },
      onAdd: function() {
        this._initContainer();
        this._levels = {};
        this._tiles = {};
        this._resetView();
      },
      beforeAdd: function(map) {
        map._addZoomLimit(this);
      },
      onRemove: function(map) {
        this._removeAllTiles();
        remove(this._container);
        map._removeZoomLimit(this);
        this._container = null;
        this._tileZoom = void 0;
      },
      // @method bringToFront: this
      // Brings the tile layer to the top of all tile layers.
      bringToFront: function() {
        if (this._map) {
          toFront(this._container);
          this._setAutoZIndex(Math.max);
        }
        return this;
      },
      // @method bringToBack: this
      // Brings the tile layer to the bottom of all tile layers.
      bringToBack: function() {
        if (this._map) {
          toBack(this._container);
          this._setAutoZIndex(Math.min);
        }
        return this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the tiles for this layer.
      getContainer: function() {
        return this._container;
      },
      // @method setOpacity(opacity: Number): this
      // Changes the [opacity](#gridlayer-opacity) of the grid layer.
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        this._updateOpacity();
        return this;
      },
      // @method setZIndex(zIndex: Number): this
      // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
      setZIndex: function(zIndex) {
        this.options.zIndex = zIndex;
        this._updateZIndex();
        return this;
      },
      // @method isLoading: Boolean
      // Returns `true` if any tile in the grid layer has not finished loading.
      isLoading: function() {
        return this._loading;
      },
      // @method redraw: this
      // Causes the layer to clear all the tiles and request them again.
      redraw: function() {
        if (this._map) {
          this._removeAllTiles();
          var tileZoom = this._clampZoom(this._map.getZoom());
          if (tileZoom !== this._tileZoom) {
            this._tileZoom = tileZoom;
            this._updateLevels();
          }
          this._update();
        }
        return this;
      },
      getEvents: function() {
        var events = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };
        if (!this.options.updateWhenIdle) {
          if (!this._onMove) {
            this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
          }
          events.move = this._onMove;
        }
        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }
        return events;
      },
      // @section Extension methods
      // Layers extending `GridLayer` shall reimplement the following method.
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, must be overridden by classes extending `GridLayer`.
      // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
      // is specified, it must be called when the tile has finished loading and drawing.
      createTile: function() {
        return document.createElement("div");
      },
      // @section
      // @method getTileSize: Point
      // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
      getTileSize: function() {
        var s2 = this.options.tileSize;
        return s2 instanceof Point ? s2 : new Point(s2, s2);
      },
      _updateZIndex: function() {
        if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
          this._container.style.zIndex = this.options.zIndex;
        }
      },
      _setAutoZIndex: function(compare) {
        var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
        for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
          zIndex = layers2[i].style.zIndex;
          if (layers2[i] !== this._container && zIndex) {
            edgeZIndex = compare(edgeZIndex, +zIndex);
          }
        }
        if (isFinite(edgeZIndex)) {
          this.options.zIndex = edgeZIndex + compare(-1, 1);
          this._updateZIndex();
        }
      },
      _updateOpacity: function() {
        if (!this._map) {
          return;
        }
        if (Browser.ielt9) {
          return;
        }
        setOpacity(this._container, this.options.opacity);
        var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
        for (var key in this._tiles) {
          var tile = this._tiles[key];
          if (!tile.current || !tile.loaded) {
            continue;
          }
          var fade = Math.min(1, (now - tile.loaded) / 200);
          setOpacity(tile.el, fade);
          if (fade < 1) {
            nextFrame = true;
          } else {
            if (tile.active) {
              willPrune = true;
            } else {
              this._onOpaqueTile(tile);
            }
            tile.active = true;
          }
        }
        if (willPrune && !this._noPrune) {
          this._pruneTiles();
        }
        if (nextFrame) {
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        }
      },
      _onOpaqueTile: falseFn,
      _initContainer: function() {
        if (this._container) {
          return;
        }
        this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
        this._updateZIndex();
        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
        this.getPane().appendChild(this._container);
      },
      _updateLevels: function() {
        var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
        if (zoom2 === void 0) {
          return void 0;
        }
        for (var z2 in this._levels) {
          z2 = Number(z2);
          if (this._levels[z2].el.children.length || z2 === zoom2) {
            this._levels[z2].el.style.zIndex = maxZoom - Math.abs(zoom2 - z2);
            this._onUpdateLevel(z2);
          } else {
            remove(this._levels[z2].el);
            this._removeTilesAtZoom(z2);
            this._onRemoveLevel(z2);
            delete this._levels[z2];
          }
        }
        var level = this._levels[zoom2], map = this._map;
        if (!level) {
          level = this._levels[zoom2] = {};
          level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
          level.el.style.zIndex = maxZoom;
          level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
          level.zoom = zoom2;
          this._setZoomTransform(level, map.getCenter(), map.getZoom());
          falseFn(level.el.offsetWidth);
          this._onCreateLevel(level);
        }
        this._level = level;
        return level;
      },
      _onUpdateLevel: falseFn,
      _onRemoveLevel: falseFn,
      _onCreateLevel: falseFn,
      _pruneTiles: function() {
        if (!this._map) {
          return;
        }
        var key, tile;
        var zoom2 = this._map.getZoom();
        if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
          this._removeAllTiles();
          return;
        }
        for (key in this._tiles) {
          tile = this._tiles[key];
          tile.retain = tile.current;
        }
        for (key in this._tiles) {
          tile = this._tiles[key];
          if (tile.current && !tile.active) {
            var coords = tile.coords;
            if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
              this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
            }
          }
        }
        for (key in this._tiles) {
          if (!this._tiles[key].retain) {
            this._removeTile(key);
          }
        }
      },
      _removeTilesAtZoom: function(zoom2) {
        for (var key in this._tiles) {
          if (this._tiles[key].coords.z !== zoom2) {
            continue;
          }
          this._removeTile(key);
        }
      },
      _removeAllTiles: function() {
        for (var key in this._tiles) {
          this._removeTile(key);
        }
      },
      _invalidateAll: function() {
        for (var z2 in this._levels) {
          remove(this._levels[z2].el);
          this._onRemoveLevel(Number(z2));
          delete this._levels[z2];
        }
        this._removeAllTiles();
        this._tileZoom = void 0;
      },
      _retainParent: function(x2, y2, z2, minZoom) {
        var x22 = Math.floor(x2 / 2), y22 = Math.floor(y2 / 2), z22 = z2 - 1, coords2 = new Point(+x22, +y22);
        coords2.z = +z22;
        var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
        if (tile && tile.active) {
          tile.retain = true;
          return true;
        } else if (tile && tile.loaded) {
          tile.retain = true;
        }
        if (z22 > minZoom) {
          return this._retainParent(x22, y22, z22, minZoom);
        }
        return false;
      },
      _retainChildren: function(x2, y2, z2, maxZoom) {
        for (var i = 2 * x2; i < 2 * x2 + 2; i++) {
          for (var j = 2 * y2; j < 2 * y2 + 2; j++) {
            var coords = new Point(i, j);
            coords.z = z2 + 1;
            var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              continue;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z2 + 1 < maxZoom) {
              this._retainChildren(i, j, z2 + 1, maxZoom);
            }
          }
        }
      },
      _resetView: function(e2) {
        var animating = e2 && (e2.pinch || e2.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
      },
      _animateZoom: function(e2) {
        this._setView(e2.center, e2.zoom, true, e2.noUpdate);
      },
      _clampZoom: function(zoom2) {
        var options = this.options;
        if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
          return options.minNativeZoom;
        }
        if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
          return options.maxNativeZoom;
        }
        return zoom2;
      },
      _setView: function(center2, zoom2, noPrune, noUpdate) {
        var tileZoom = Math.round(zoom2);
        if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
          tileZoom = void 0;
        } else {
          tileZoom = this._clampZoom(tileZoom);
        }
        var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
        if (!noUpdate || tileZoomChanged) {
          this._tileZoom = tileZoom;
          if (this._abortLoading) {
            this._abortLoading();
          }
          this._updateLevels();
          this._resetGrid();
          if (tileZoom !== void 0) {
            this._update(center2);
          }
          if (!noPrune) {
            this._pruneTiles();
          }
          this._noPrune = !!noPrune;
        }
        this._setZoomTransforms(center2, zoom2);
      },
      _setZoomTransforms: function(center2, zoom2) {
        for (var i in this._levels) {
          this._setZoomTransform(this._levels[i], center2, zoom2);
        }
      },
      _setZoomTransform: function(level, center2, zoom2) {
        var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center2, zoom2)).round();
        if (Browser.any3d) {
          setTransform(level.el, translate, scale2);
        } else {
          setPosition(level.el, translate);
        }
      },
      _resetGrid: function() {
        var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
        var bounds = this._map.getPixelWorldBounds(this._tileZoom);
        if (bounds) {
          this._globalTileRange = this._pxBoundsToTileRange(bounds);
        }
        this._wrapX = crs.wrapLng && !this.options.noWrap && [
          Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
          Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
        ];
        this._wrapY = crs.wrapLat && !this.options.noWrap && [
          Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
          Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
        ];
      },
      _onMoveEnd: function() {
        if (!this._map || this._map._animatingZoom) {
          return;
        }
        this._update();
      },
      _getTiledPixelBounds: function(center2) {
        var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center2, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
        return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
      },
      // Private method to load tiles in the grid's active zoom level according to map bounds
      _update: function(center2) {
        var map = this._map;
        if (!map) {
          return;
        }
        var zoom2 = this._clampZoom(map.getZoom());
        if (center2 === void 0) {
          center2 = map.getCenter();
        }
        if (this._tileZoom === void 0) {
          return;
        }
        var pixelBounds = this._getTiledPixelBounds(center2), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
          tileRange.getBottomLeft().subtract([margin, -margin]),
          tileRange.getTopRight().add([margin, -margin])
        );
        if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
          throw new Error("Attempted to load an infinite number of tiles");
        }
        for (var key in this._tiles) {
          var c = this._tiles[key].coords;
          if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
            this._tiles[key].current = false;
          }
        }
        if (Math.abs(zoom2 - this._tileZoom) > 1) {
          this._setView(center2, zoom2);
          return;
        }
        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
          for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
            var coords = new Point(i, j);
            coords.z = this._tileZoom;
            if (!this._isValidTile(coords)) {
              continue;
            }
            var tile = this._tiles[this._tileCoordsToKey(coords)];
            if (tile) {
              tile.current = true;
            } else {
              queue.push(coords);
            }
          }
        }
        queue.sort(function(a, b) {
          return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
        });
        if (queue.length !== 0) {
          if (!this._loading) {
            this._loading = true;
            this.fire("loading");
          }
          var fragment = document.createDocumentFragment();
          for (i = 0; i < queue.length; i++) {
            this._addTile(queue[i], fragment);
          }
          this._level.el.appendChild(fragment);
        }
      },
      _isValidTile: function(coords) {
        var crs = this._map.options.crs;
        if (!crs.infinite) {
          var bounds = this._globalTileRange;
          if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
            return false;
          }
        }
        if (!this.options.bounds) {
          return true;
        }
        var tileBounds = this._tileCoordsToBounds(coords);
        return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
      },
      _keyToBounds: function(key) {
        return this._tileCoordsToBounds(this._keyToTileCoords(key));
      },
      _tileCoordsToNwSe: function(coords) {
        var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se2 = map.unproject(sePoint, coords.z);
        return [nw, se2];
      },
      // converts tile coordinates to its geographical bounds
      _tileCoordsToBounds: function(coords) {
        var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
        if (!this.options.noWrap) {
          bounds = this._map.wrapLatLngBounds(bounds);
        }
        return bounds;
      },
      // converts tile coordinates to key for the tile cache
      _tileCoordsToKey: function(coords) {
        return coords.x + ":" + coords.y + ":" + coords.z;
      },
      // converts tile cache key to coordinates
      _keyToTileCoords: function(key) {
        var k2 = key.split(":"), coords = new Point(+k2[0], +k2[1]);
        coords.z = +k2[2];
        return coords;
      },
      _removeTile: function(key) {
        var tile = this._tiles[key];
        if (!tile) {
          return;
        }
        remove(tile.el);
        delete this._tiles[key];
        this.fire("tileunload", {
          tile: tile.el,
          coords: this._keyToTileCoords(key)
        });
      },
      _initTile: function(tile) {
        addClass(tile, "leaflet-tile");
        var tileSize = this.getTileSize();
        tile.style.width = tileSize.x + "px";
        tile.style.height = tileSize.y + "px";
        tile.onselectstart = falseFn;
        tile.onmousemove = falseFn;
        if (Browser.ielt9 && this.options.opacity < 1) {
          setOpacity(tile, this.options.opacity);
        }
      },
      _addTile: function(coords, container) {
        var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
        var tile = this.createTile(this._wrapCoords(coords), bind3(this._tileReady, this, coords));
        this._initTile(tile);
        if (this.createTile.length < 2) {
          requestAnimFrame(bind3(this._tileReady, this, coords, null, tile));
        }
        setPosition(tile, tilePos);
        this._tiles[key] = {
          el: tile,
          coords,
          current: true
        };
        container.appendChild(tile);
        this.fire("tileloadstart", {
          tile,
          coords
        });
      },
      _tileReady: function(coords, err, tile) {
        if (err) {
          this.fire("tileerror", {
            error: err,
            tile,
            coords
          });
        }
        var key = this._tileCoordsToKey(coords);
        tile = this._tiles[key];
        if (!tile) {
          return;
        }
        tile.loaded = +/* @__PURE__ */ new Date();
        if (this._map._fadeAnimated) {
          setOpacity(tile.el, 0);
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        } else {
          tile.active = true;
          this._pruneTiles();
        }
        if (!err) {
          addClass(tile.el, "leaflet-tile-loaded");
          this.fire("tileload", {
            tile: tile.el,
            coords
          });
        }
        if (this._noTilesToLoad()) {
          this._loading = false;
          this.fire("load");
          if (Browser.ielt9 || !this._map._fadeAnimated) {
            requestAnimFrame(this._pruneTiles, this);
          } else {
            setTimeout(bind3(this._pruneTiles, this), 250);
          }
        }
      },
      _getTilePos: function(coords) {
        return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function(coords) {
        var newCoords = new Point(
          this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
          this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
        );
        newCoords.z = coords.z;
        return newCoords;
      },
      _pxBoundsToTileRange: function(bounds) {
        var tileSize = this.getTileSize();
        return new Bounds(
          bounds.min.unscaleBy(tileSize).floor(),
          bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
        );
      },
      _noTilesToLoad: function() {
        for (var key in this._tiles) {
          if (!this._tiles[key].loaded) {
            return false;
          }
        }
        return true;
      }
    });
    function gridLayer(options) {
      return new GridLayer(options);
    }
    var TileLayer2 = GridLayer.extend({
      // @section
      // @aka TileLayer options
      options: {
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = 18
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: 18,
        // @option subdomains: String|String[] = 'abc'
        // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
        subdomains: "abc",
        // @option errorTileUrl: String = ''
        // URL to the tile image to show in place of the tile that failed to load.
        errorTileUrl: "",
        // @option zoomOffset: Number = 0
        // The zoom number used in tile URLs will be offset with this value.
        zoomOffset: 0,
        // @option tms: Boolean = false
        // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
        tms: false,
        // @option zoomReverse: Boolean = false
        // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
        zoomReverse: false,
        // @option detectRetina: Boolean = false
        // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
        detectRetina: false,
        // @option crossOrigin: Boolean|String = false
        // Whether the crossOrigin attribute will be added to the tiles.
        // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
        // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
        crossOrigin: false,
        // @option referrerPolicy: Boolean|String = false
        // Whether the referrerPolicy attribute will be added to the tiles.
        // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
        // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
        // (e.g. to validate an API token).
        // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
        referrerPolicy: false
      },
      initialize: function(url, options) {
        this._url = url;
        options = setOptions(this, options);
        if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
          options.tileSize = Math.floor(options.tileSize / 2);
          if (!options.zoomReverse) {
            options.zoomOffset++;
            options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
          } else {
            options.zoomOffset--;
            options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
          }
          options.minZoom = Math.max(0, options.minZoom);
        } else if (!options.zoomReverse) {
          options.maxZoom = Math.max(options.minZoom, options.maxZoom);
        } else {
          options.minZoom = Math.min(options.maxZoom, options.minZoom);
        }
        if (typeof options.subdomains === "string") {
          options.subdomains = options.subdomains.split("");
        }
        this.on("tileunload", this._onTileRemove);
      },
      // @method setUrl(url: String, noRedraw?: Boolean): this
      // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
      // If the URL does not change, the layer will not be redrawn unless
      // the noRedraw parameter is set to false.
      setUrl: function(url, noRedraw) {
        if (this._url === url && noRedraw === void 0) {
          noRedraw = true;
        }
        this._url = url;
        if (!noRedraw) {
          this.redraw();
        }
        return this;
      },
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
      // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
      // callback is called when the tile has been loaded.
      createTile: function(coords, done) {
        var tile = document.createElement("img");
        on(tile, "load", bind3(this._tileOnLoad, this, done, tile));
        on(tile, "error", bind3(this._tileOnError, this, done, tile));
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        if (typeof this.options.referrerPolicy === "string") {
          tile.referrerPolicy = this.options.referrerPolicy;
        }
        tile.alt = "";
        tile.src = this.getTileUrl(coords);
        return tile;
      },
      // @section Extension methods
      // @uninheritable
      // Layers extending `TileLayer` might reimplement the following method.
      // @method getTileUrl(coords: Object): String
      // Called only internally, returns the URL for a tile given its coordinates.
      // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
      getTileUrl: function(coords) {
        var data = {
          r: Browser.retina ? "@2x" : "",
          s: this._getSubdomain(coords),
          x: coords.x,
          y: coords.y,
          z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
          var invertedY = this._globalTileRange.max.y - coords.y;
          if (this.options.tms) {
            data["y"] = invertedY;
          }
          data["-y"] = invertedY;
        }
        return template(this._url, extend(data, this.options));
      },
      _tileOnLoad: function(done, tile) {
        if (Browser.ielt9) {
          setTimeout(bind3(done, this, null, tile), 0);
        } else {
          done(null, tile);
        }
      },
      _tileOnError: function(done, tile, e2) {
        var errorUrl = this.options.errorTileUrl;
        if (errorUrl && tile.getAttribute("src") !== errorUrl) {
          tile.src = errorUrl;
        }
        done(e2, tile);
      },
      _onTileRemove: function(e2) {
        e2.tile.onload = null;
      },
      _getZoomForUrl: function() {
        var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
        if (zoomReverse) {
          zoom2 = maxZoom - zoom2;
        }
        return zoom2 + zoomOffset;
      },
      _getSubdomain: function(tilePoint) {
        var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
        return this.options.subdomains[index2];
      },
      // stops loading all tiles in the background layer
      _abortLoading: function() {
        var i, tile;
        for (i in this._tiles) {
          if (this._tiles[i].coords.z !== this._tileZoom) {
            tile = this._tiles[i].el;
            tile.onload = falseFn;
            tile.onerror = falseFn;
            if (!tile.complete) {
              tile.src = emptyImageUrl;
              var coords = this._tiles[i].coords;
              remove(tile);
              delete this._tiles[i];
              this.fire("tileabort", {
                tile,
                coords
              });
            }
          }
        }
      },
      _removeTile: function(key) {
        var tile = this._tiles[key];
        if (!tile) {
          return;
        }
        tile.el.setAttribute("src", emptyImageUrl);
        return GridLayer.prototype._removeTile.call(this, key);
      },
      _tileReady: function(coords, err, tile) {
        if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
          return;
        }
        return GridLayer.prototype._tileReady.call(this, coords, err, tile);
      }
    });
    function tileLayer(url, options) {
      return new TileLayer2(url, options);
    }
    var TileLayerWMS = TileLayer2.extend({
      // @section
      // @aka TileLayer.WMS options
      // If any custom options not documented here are used, they will be sent to the
      // WMS server as extra parameters in each request URL. This can be useful for
      // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
      defaultWmsParams: {
        service: "WMS",
        request: "GetMap",
        // @option layers: String = ''
        // **(required)** Comma-separated list of WMS layers to show.
        layers: "",
        // @option styles: String = ''
        // Comma-separated list of WMS styles.
        styles: "",
        // @option format: String = 'image/jpeg'
        // WMS image format (use `'image/png'` for layers with transparency).
        format: "image/jpeg",
        // @option transparent: Boolean = false
        // If `true`, the WMS service will return images with transparency.
        transparent: false,
        // @option version: String = '1.1.1'
        // Version of the WMS service to use
        version: "1.1.1"
      },
      options: {
        // @option crs: CRS = null
        // Coordinate Reference System to use for the WMS requests, defaults to
        // map CRS. Don't change this if you're not sure what it means.
        crs: null,
        // @option uppercase: Boolean = false
        // If `true`, WMS request parameter keys will be uppercase.
        uppercase: false
      },
      initialize: function(url, options) {
        this._url = url;
        var wmsParams = extend({}, this.defaultWmsParams);
        for (var i in options) {
          if (!(i in this.options)) {
            wmsParams[i] = options[i];
          }
        }
        options = setOptions(this, options);
        var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
        var tileSize = this.getTileSize();
        wmsParams.width = tileSize.x * realRetina;
        wmsParams.height = tileSize.y * realRetina;
        this.wmsParams = wmsParams;
      },
      onAdd: function(map) {
        this._crs = this.options.crs || map.options.crs;
        this._wmsVersion = parseFloat(this.wmsParams.version);
        var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
        this.wmsParams[projectionKey] = this._crs.code;
        TileLayer2.prototype.onAdd.call(this, map);
      },
      getTileUrl: function(coords) {
        var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds2(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max2 = bounds.max, bbox2 = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max2.y, max2.x] : [min.x, min.y, max2.x, max2.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords);
        return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox2;
      },
      // @method setParams(params: Object, noRedraw?: Boolean): this
      // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
      setParams: function(params, noRedraw) {
        extend(this.wmsParams, params);
        if (!noRedraw) {
          this.redraw();
        }
        return this;
      }
    });
    function tileLayerWMS(url, options) {
      return new TileLayerWMS(url, options);
    }
    TileLayer2.WMS = TileLayerWMS;
    tileLayer.wms = tileLayerWMS;
    var Renderer = Layer.extend({
      // @section
      // @aka Renderer options
      options: {
        // @option padding: Number = 0.1
        // How much to extend the clip area around the map view (relative to its size)
        // e.g. 0.1 would be 10% of map view in each direction
        padding: 0.1
      },
      initialize: function(options) {
        setOptions(this, options);
        stamp(this);
        this._layers = this._layers || {};
      },
      onAdd: function() {
        if (!this._container) {
          this._initContainer();
          addClass(this._container, "leaflet-zoom-animated");
        }
        this.getPane().appendChild(this._container);
        this._update();
        this.on("update", this._updatePaths, this);
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this);
        this._destroyContainer();
      },
      getEvents: function() {
        var events = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        if (this._zoomAnimated) {
          events.zoomanim = this._onAnimZoom;
        }
        return events;
      },
      _onAnimZoom: function(ev) {
        this._updateTransform(ev.center, ev.zoom);
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      },
      _updateTransform: function(center2, zoom2) {
        var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center2, zoom2));
        if (Browser.any3d) {
          setTransform(this._container, topLeftOffset, scale2);
        } else {
          setPosition(this._container, topLeftOffset);
        }
      },
      _reset: function() {
        this._update();
        this._updateTransform(this._center, this._zoom);
        for (var id2 in this._layers) {
          this._layers[id2]._reset();
        }
      },
      _onZoomEnd: function() {
        for (var id2 in this._layers) {
          this._layers[id2]._project();
        }
      },
      _updatePaths: function() {
        for (var id2 in this._layers) {
          this._layers[id2]._update();
        }
      },
      _update: function() {
        var p2 = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p2)).round();
        this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p2 * 2)).round());
        this._center = this._map.getCenter();
        this._zoom = this._map.getZoom();
      }
    });
    var Canvas = Renderer.extend({
      // @section
      // @aka Canvas options
      options: {
        // @option tolerance: Number = 0
        // How much to extend the click tolerance around a path/object on the map.
        tolerance: 0
      },
      getEvents: function() {
        var events = Renderer.prototype.getEvents.call(this);
        events.viewprereset = this._onViewPreReset;
        return events;
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = true;
      },
      onAdd: function() {
        Renderer.prototype.onAdd.call(this);
        this._draw();
      },
      _initContainer: function() {
        var container = this._container = document.createElement("canvas");
        on(container, "mousemove", this._onMouseMove, this);
        on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
        on(container, "mouseout", this._handleMouseOut, this);
        container["_leaflet_disable_events"] = true;
        this._ctx = container.getContext("2d");
      },
      _destroyContainer: function() {
        cancelAnimFrame(this._redrawRequest);
        delete this._ctx;
        remove(this._container);
        off(this._container);
        delete this._container;
      },
      _updatePaths: function() {
        if (this._postponeUpdatePaths) {
          return;
        }
        var layer;
        this._redrawBounds = null;
        for (var id2 in this._layers) {
          layer = this._layers[id2];
          layer._update();
        }
        this._redraw();
      },
      _update: function() {
        if (this._map._animatingZoom && this._bounds) {
          return;
        }
        Renderer.prototype._update.call(this);
        var b = this._bounds, container = this._container, size = b.getSize(), m2 = Browser.retina ? 2 : 1;
        setPosition(container, b.min);
        container.width = m2 * size.x;
        container.height = m2 * size.y;
        container.style.width = size.x + "px";
        container.style.height = size.y + "px";
        if (Browser.retina) {
          this._ctx.scale(2, 2);
        }
        this._ctx.translate(-b.min.x, -b.min.y);
        this.fire("update");
      },
      _reset: function() {
        Renderer.prototype._reset.call(this);
        if (this._postponeUpdatePaths) {
          this._postponeUpdatePaths = false;
          this._updatePaths();
        }
      },
      _initPath: function(layer) {
        this._updateDashArray(layer);
        this._layers[stamp(layer)] = layer;
        var order = layer._order = {
          layer,
          prev: this._drawLast,
          next: null
        };
        if (this._drawLast) {
          this._drawLast.next = order;
        }
        this._drawLast = order;
        this._drawFirst = this._drawFirst || this._drawLast;
      },
      _addPath: function(layer) {
        this._requestRedraw(layer);
      },
      _removePath: function(layer) {
        var order = layer._order;
        var next = order.next;
        var prev = order.prev;
        if (next) {
          next.prev = prev;
        } else {
          this._drawLast = prev;
        }
        if (prev) {
          prev.next = next;
        } else {
          this._drawFirst = next;
        }
        delete layer._order;
        delete this._layers[stamp(layer)];
        this._requestRedraw(layer);
      },
      _updatePath: function(layer) {
        this._extendRedrawBounds(layer);
        layer._project();
        layer._update();
        this._requestRedraw(layer);
      },
      _updateStyle: function(layer) {
        this._updateDashArray(layer);
        this._requestRedraw(layer);
      },
      _updateDashArray: function(layer) {
        if (typeof layer.options.dashArray === "string") {
          var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
          for (i = 0; i < parts.length; i++) {
            dashValue = Number(parts[i]);
            if (isNaN(dashValue)) {
              return;
            }
            dashArray.push(dashValue);
          }
          layer.options._dashArray = dashArray;
        } else {
          layer.options._dashArray = layer.options.dashArray;
        }
      },
      _requestRedraw: function(layer) {
        if (!this._map) {
          return;
        }
        this._extendRedrawBounds(layer);
        this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
      },
      _extendRedrawBounds: function(layer) {
        if (layer._pxBounds) {
          var padding = (layer.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new Bounds();
          this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
          this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
        }
      },
      _redraw: function() {
        this._redrawRequest = null;
        if (this._redrawBounds) {
          this._redrawBounds.min._floor();
          this._redrawBounds.max._ceil();
        }
        this._clear();
        this._draw();
        this._redrawBounds = null;
      },
      _clear: function() {
        var bounds = this._redrawBounds;
        if (bounds) {
          var size = bounds.getSize();
          this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
        } else {
          this._ctx.save();
          this._ctx.setTransform(1, 0, 0, 1, 0, 0);
          this._ctx.clearRect(0, 0, this._container.width, this._container.height);
          this._ctx.restore();
        }
      },
      _draw: function() {
        var layer, bounds = this._redrawBounds;
        this._ctx.save();
        if (bounds) {
          var size = bounds.getSize();
          this._ctx.beginPath();
          this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
          this._ctx.clip();
        }
        this._drawing = true;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
            layer._updatePath();
          }
        }
        this._drawing = false;
        this._ctx.restore();
      },
      _updatePoly: function(layer, closed) {
        if (!this._drawing) {
          return;
        }
        var i, j, len2, p2, parts = layer._parts, len = parts.length, ctx = this._ctx;
        if (!len) {
          return;
        }
        ctx.beginPath();
        for (i = 0; i < len; i++) {
          for (j = 0, len2 = parts[i].length; j < len2; j++) {
            p2 = parts[i][j];
            ctx[j ? "lineTo" : "moveTo"](p2.x, p2.y);
          }
          if (closed) {
            ctx.closePath();
          }
        }
        this._fillStroke(ctx, layer);
      },
      _updateCircle: function(layer) {
        if (!this._drawing || layer._empty()) {
          return;
        }
        var p2 = layer._point, ctx = this._ctx, r2 = Math.max(Math.round(layer._radius), 1), s2 = (Math.max(Math.round(layer._radiusY), 1) || r2) / r2;
        if (s2 !== 1) {
          ctx.save();
          ctx.scale(1, s2);
        }
        ctx.beginPath();
        ctx.arc(p2.x, p2.y / s2, r2, 0, Math.PI * 2, false);
        if (s2 !== 1) {
          ctx.restore();
        }
        this._fillStroke(ctx, layer);
      },
      _fillStroke: function(ctx, layer) {
        var options = layer.options;
        if (options.fill) {
          ctx.globalAlpha = options.fillOpacity;
          ctx.fillStyle = options.fillColor || options.color;
          ctx.fill(options.fillRule || "evenodd");
        }
        if (options.stroke && options.weight !== 0) {
          if (ctx.setLineDash) {
            ctx.setLineDash(layer.options && layer.options._dashArray || []);
          }
          ctx.globalAlpha = options.opacity;
          ctx.lineWidth = options.weight;
          ctx.strokeStyle = options.color;
          ctx.lineCap = options.lineCap;
          ctx.lineJoin = options.lineJoin;
          ctx.stroke();
        }
      },
      // Canvas obviously doesn't have mouse events for individual drawn objects,
      // so we emulate that by calculating what's under the mouse on mousemove/click manually
      _onClick: function(e2) {
        var point2 = this._map.mouseEventToLayerPoint(e2), layer, clickedLayer;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (layer.options.interactive && layer._containsPoint(point2)) {
            if (!(e2.type === "click" || e2.type === "preclick") || !this._map._draggableMoved(layer)) {
              clickedLayer = layer;
            }
          }
        }
        this._fireEvent(clickedLayer ? [clickedLayer] : false, e2);
      },
      _onMouseMove: function(e2) {
        if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
          return;
        }
        var point2 = this._map.mouseEventToLayerPoint(e2);
        this._handleMouseHover(e2, point2);
      },
      _handleMouseOut: function(e2) {
        var layer = this._hoveredLayer;
        if (layer) {
          removeClass(this._container, "leaflet-interactive");
          this._fireEvent([layer], e2, "mouseout");
          this._hoveredLayer = null;
          this._mouseHoverThrottled = false;
        }
      },
      _handleMouseHover: function(e2, point2) {
        if (this._mouseHoverThrottled) {
          return;
        }
        var layer, candidateHoveredLayer;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (layer.options.interactive && layer._containsPoint(point2)) {
            candidateHoveredLayer = layer;
          }
        }
        if (candidateHoveredLayer !== this._hoveredLayer) {
          this._handleMouseOut(e2);
          if (candidateHoveredLayer) {
            addClass(this._container, "leaflet-interactive");
            this._fireEvent([candidateHoveredLayer], e2, "mouseover");
            this._hoveredLayer = candidateHoveredLayer;
          }
        }
        this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e2);
        this._mouseHoverThrottled = true;
        setTimeout(bind3(function() {
          this._mouseHoverThrottled = false;
        }, this), 32);
      },
      _fireEvent: function(layers2, e2, type2) {
        this._map._fireDOMEvent(e2, type2 || e2.type, layers2);
      },
      _bringToFront: function(layer) {
        var order = layer._order;
        if (!order) {
          return;
        }
        var next = order.next;
        var prev = order.prev;
        if (next) {
          next.prev = prev;
        } else {
          return;
        }
        if (prev) {
          prev.next = next;
        } else if (next) {
          this._drawFirst = next;
        }
        order.prev = this._drawLast;
        this._drawLast.next = order;
        order.next = null;
        this._drawLast = order;
        this._requestRedraw(layer);
      },
      _bringToBack: function(layer) {
        var order = layer._order;
        if (!order) {
          return;
        }
        var next = order.next;
        var prev = order.prev;
        if (prev) {
          prev.next = next;
        } else {
          return;
        }
        if (next) {
          next.prev = prev;
        } else if (prev) {
          this._drawLast = prev;
        }
        order.prev = null;
        order.next = this._drawFirst;
        this._drawFirst.prev = order;
        this._drawFirst = order;
        this._requestRedraw(layer);
      }
    });
    function canvas(options) {
      return Browser.canvas ? new Canvas(options) : null;
    }
    var vmlCreate = function() {
      try {
        document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
        return function(name) {
          return document.createElement("<lvml:" + name + ' class="lvml">');
        };
      } catch (e2) {
      }
      return function(name) {
        return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }();
    var vmlMixin = {
      _initContainer: function() {
        this._container = create$1("div", "leaflet-vml-container");
      },
      _update: function() {
        if (this._map._animatingZoom) {
          return;
        }
        Renderer.prototype._update.call(this);
        this.fire("update");
      },
      _initPath: function(layer) {
        var container = layer._container = vmlCreate("shape");
        addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
        container.coordsize = "1 1";
        layer._path = vmlCreate("path");
        container.appendChild(layer._path);
        this._updateStyle(layer);
        this._layers[stamp(layer)] = layer;
      },
      _addPath: function(layer) {
        var container = layer._container;
        this._container.appendChild(container);
        if (layer.options.interactive) {
          layer.addInteractiveTarget(container);
        }
      },
      _removePath: function(layer) {
        var container = layer._container;
        remove(container);
        layer.removeInteractiveTarget(container);
        delete this._layers[stamp(layer)];
      },
      _updateStyle: function(layer) {
        var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
        container.stroked = !!options.stroke;
        container.filled = !!options.fill;
        if (options.stroke) {
          if (!stroke) {
            stroke = layer._stroke = vmlCreate("stroke");
          }
          container.appendChild(stroke);
          stroke.weight = options.weight + "px";
          stroke.color = options.color;
          stroke.opacity = options.opacity;
          if (options.dashArray) {
            stroke.dashStyle = isArray2(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
          } else {
            stroke.dashStyle = "";
          }
          stroke.endcap = options.lineCap.replace("butt", "flat");
          stroke.joinstyle = options.lineJoin;
        } else if (stroke) {
          container.removeChild(stroke);
          layer._stroke = null;
        }
        if (options.fill) {
          if (!fill) {
            fill = layer._fill = vmlCreate("fill");
          }
          container.appendChild(fill);
          fill.color = options.fillColor || options.color;
          fill.opacity = options.fillOpacity;
        } else if (fill) {
          container.removeChild(fill);
          layer._fill = null;
        }
      },
      _updateCircle: function(layer) {
        var p2 = layer._point.round(), r2 = Math.round(layer._radius), r22 = Math.round(layer._radiusY || r2);
        this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p2.x + "," + p2.y + " " + r2 + "," + r22 + " 0," + 65535 * 360);
      },
      _setPath: function(layer, path) {
        layer._path.v = path;
      },
      _bringToFront: function(layer) {
        toFront(layer._container);
      },
      _bringToBack: function(layer) {
        toBack(layer._container);
      }
    };
    var create = Browser.vml ? vmlCreate : svgCreate;
    var SVG = Renderer.extend({
      _initContainer: function() {
        this._container = create("svg");
        this._container.setAttribute("pointer-events", "none");
        this._rootGroup = create("g");
        this._container.appendChild(this._rootGroup);
      },
      _destroyContainer: function() {
        remove(this._container);
        off(this._container);
        delete this._container;
        delete this._rootGroup;
        delete this._svgSize;
      },
      _update: function() {
        if (this._map._animatingZoom && this._bounds) {
          return;
        }
        Renderer.prototype._update.call(this);
        var b = this._bounds, size = b.getSize(), container = this._container;
        if (!this._svgSize || !this._svgSize.equals(size)) {
          this._svgSize = size;
          container.setAttribute("width", size.x);
          container.setAttribute("height", size.y);
        }
        setPosition(container, b.min);
        container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
        this.fire("update");
      },
      // methods below are called by vector layers implementations
      _initPath: function(layer) {
        var path = layer._path = create("path");
        if (layer.options.className) {
          addClass(path, layer.options.className);
        }
        if (layer.options.interactive) {
          addClass(path, "leaflet-interactive");
        }
        this._updateStyle(layer);
        this._layers[stamp(layer)] = layer;
      },
      _addPath: function(layer) {
        if (!this._rootGroup) {
          this._initContainer();
        }
        this._rootGroup.appendChild(layer._path);
        layer.addInteractiveTarget(layer._path);
      },
      _removePath: function(layer) {
        remove(layer._path);
        layer.removeInteractiveTarget(layer._path);
        delete this._layers[stamp(layer)];
      },
      _updatePath: function(layer) {
        layer._project();
        layer._update();
      },
      _updateStyle: function(layer) {
        var path = layer._path, options = layer.options;
        if (!path) {
          return;
        }
        if (options.stroke) {
          path.setAttribute("stroke", options.color);
          path.setAttribute("stroke-opacity", options.opacity);
          path.setAttribute("stroke-width", options.weight);
          path.setAttribute("stroke-linecap", options.lineCap);
          path.setAttribute("stroke-linejoin", options.lineJoin);
          if (options.dashArray) {
            path.setAttribute("stroke-dasharray", options.dashArray);
          } else {
            path.removeAttribute("stroke-dasharray");
          }
          if (options.dashOffset) {
            path.setAttribute("stroke-dashoffset", options.dashOffset);
          } else {
            path.removeAttribute("stroke-dashoffset");
          }
        } else {
          path.setAttribute("stroke", "none");
        }
        if (options.fill) {
          path.setAttribute("fill", options.fillColor || options.color);
          path.setAttribute("fill-opacity", options.fillOpacity);
          path.setAttribute("fill-rule", options.fillRule || "evenodd");
        } else {
          path.setAttribute("fill", "none");
        }
      },
      _updatePoly: function(layer, closed) {
        this._setPath(layer, pointsToPath(layer._parts, closed));
      },
      _updateCircle: function(layer) {
        var p2 = layer._point, r2 = Math.max(Math.round(layer._radius), 1), r22 = Math.max(Math.round(layer._radiusY), 1) || r2, arc = "a" + r2 + "," + r22 + " 0 1,0 ";
        var d = layer._empty() ? "M0 0" : "M" + (p2.x - r2) + "," + p2.y + arc + r2 * 2 + ",0 " + arc + -r2 * 2 + ",0 ";
        this._setPath(layer, d);
      },
      _setPath: function(layer, path) {
        layer._path.setAttribute("d", path);
      },
      // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
      _bringToFront: function(layer) {
        toFront(layer._path);
      },
      _bringToBack: function(layer) {
        toBack(layer._path);
      }
    });
    if (Browser.vml) {
      SVG.include(vmlMixin);
    }
    function svg(options) {
      return Browser.svg || Browser.vml ? new SVG(options) : null;
    }
    Map2.include({
      // @namespace Map; @method getRenderer(layer: Path): Renderer
      // Returns the instance of `Renderer` that should be used to render the given
      // `Path`. It will ensure that the `renderer` options of the map and paths
      // are respected, and that the renderers do exist on the map.
      getRenderer: function(layer) {
        var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
        if (!renderer) {
          renderer = this._renderer = this._createRenderer();
        }
        if (!this.hasLayer(renderer)) {
          this.addLayer(renderer);
        }
        return renderer;
      },
      _getPaneRenderer: function(name) {
        if (name === "overlayPane" || name === void 0) {
          return false;
        }
        var renderer = this._paneRenderers[name];
        if (renderer === void 0) {
          renderer = this._createRenderer({ pane: name });
          this._paneRenderers[name] = renderer;
        }
        return renderer;
      },
      _createRenderer: function(options) {
        return this.options.preferCanvas && canvas(options) || svg(options);
      }
    });
    var Rectangle = Polygon.extend({
      initialize: function(latLngBounds, options) {
        Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
      },
      // @method setBounds(latLngBounds: LatLngBounds): this
      // Redraws the rectangle with the passed bounds.
      setBounds: function(latLngBounds) {
        return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
      },
      _boundsToLatLngs: function(latLngBounds) {
        latLngBounds = toLatLngBounds(latLngBounds);
        return [
          latLngBounds.getSouthWest(),
          latLngBounds.getNorthWest(),
          latLngBounds.getNorthEast(),
          latLngBounds.getSouthEast()
        ];
      }
    });
    function rectangle(latLngBounds, options) {
      return new Rectangle(latLngBounds, options);
    }
    SVG.create = create;
    SVG.pointsToPath = pointsToPath;
    GeoJSON2.geometryToLayer = geometryToLayer;
    GeoJSON2.coordsToLatLng = coordsToLatLng;
    GeoJSON2.coordsToLatLngs = coordsToLatLngs;
    GeoJSON2.latLngToCoords = latLngToCoords;
    GeoJSON2.latLngsToCoords = latLngsToCoords;
    GeoJSON2.getFeature = getFeature;
    GeoJSON2.asFeature = asFeature;
    Map2.mergeOptions({
      // @option boxZoom: Boolean = true
      // Whether the map can be zoomed to a rectangular area specified by
      // dragging the mouse while pressing the shift key.
      boxZoom: true
    });
    var BoxZoom = Handler.extend({
      initialize: function(map) {
        this._map = map;
        this._container = map._container;
        this._pane = map._panes.overlayPane;
        this._resetStateTimeout = 0;
        map.on("unload", this._destroy, this);
      },
      addHooks: function() {
        on(this._container, "mousedown", this._onMouseDown, this);
      },
      removeHooks: function() {
        off(this._container, "mousedown", this._onMouseDown, this);
      },
      moved: function() {
        return this._moved;
      },
      _destroy: function() {
        remove(this._pane);
        delete this._pane;
      },
      _resetState: function() {
        this._resetStateTimeout = 0;
        this._moved = false;
      },
      _clearDeferredResetState: function() {
        if (this._resetStateTimeout !== 0) {
          clearTimeout(this._resetStateTimeout);
          this._resetStateTimeout = 0;
        }
      },
      _onMouseDown: function(e2) {
        if (!e2.shiftKey || e2.which !== 1 && e2.button !== 1) {
          return false;
        }
        this._clearDeferredResetState();
        this._resetState();
        disableTextSelection();
        disableImageDrag();
        this._startPoint = this._map.mouseEventToContainerPoint(e2);
        on(document, {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseMove: function(e2) {
        if (!this._moved) {
          this._moved = true;
          this._box = create$1("div", "leaflet-zoom-box", this._container);
          addClass(this._container, "leaflet-crosshair");
          this._map.fire("boxzoomstart");
        }
        this._point = this._map.mouseEventToContainerPoint(e2);
        var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
        setPosition(this._box, bounds.min);
        this._box.style.width = size.x + "px";
        this._box.style.height = size.y + "px";
      },
      _finish: function() {
        if (this._moved) {
          remove(this._box);
          removeClass(this._container, "leaflet-crosshair");
        }
        enableTextSelection();
        enableImageDrag();
        off(document, {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseUp: function(e2) {
        if (e2.which !== 1 && e2.button !== 1) {
          return;
        }
        this._finish();
        if (!this._moved) {
          return;
        }
        this._clearDeferredResetState();
        this._resetStateTimeout = setTimeout(bind3(this._resetState, this), 0);
        var bounds = new LatLngBounds(
          this._map.containerPointToLatLng(this._startPoint),
          this._map.containerPointToLatLng(this._point)
        );
        this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
      },
      _onKeyDown: function(e2) {
        if (e2.keyCode === 27) {
          this._finish();
          this._clearDeferredResetState();
          this._resetState();
        }
      }
    });
    Map2.addInitHook("addHandler", "boxZoom", BoxZoom);
    Map2.mergeOptions({
      // @option doubleClickZoom: Boolean|String = true
      // Whether the map can be zoomed in by double clicking on it and
      // zoomed out by double clicking while holding shift. If passed
      // `'center'`, double-click zoom will zoom to the center of the
      //  view regardless of where the mouse was.
      doubleClickZoom: true
    });
    var DoubleClickZoom = Handler.extend({
      addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      },
      removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      },
      _onDoubleClick: function(e2) {
        var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e2.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
        if (map.options.doubleClickZoom === "center") {
          map.setZoom(zoom2);
        } else {
          map.setZoomAround(e2.containerPoint, zoom2);
        }
      }
    });
    Map2.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
    Map2.mergeOptions({
      // @option dragging: Boolean = true
      // Whether the map is draggable with mouse/touch or not.
      dragging: true,
      // @section Panning Inertia Options
      // @option inertia: Boolean = *
      // If enabled, panning of the map will have an inertia effect where
      // the map builds momentum while dragging and continues moving in
      // the same direction for some time. Feels especially nice on touch
      // devices. Enabled by default.
      inertia: true,
      // @option inertiaDeceleration: Number = 3000
      // The rate with which the inertial movement slows down, in pixels/second².
      inertiaDeceleration: 3400,
      // px/s^2
      // @option inertiaMaxSpeed: Number = Infinity
      // Max speed of the inertial movement, in pixels/second.
      inertiaMaxSpeed: Infinity,
      // px/s
      // @option easeLinearity: Number = 0.2
      easeLinearity: 0.2,
      // TODO refactor, move to CRS
      // @option worldCopyJump: Boolean = false
      // With this option enabled, the map tracks when you pan to another "copy"
      // of the world and seamlessly jumps to the original one so that all overlays
      // like markers and vector layers are still visible.
      worldCopyJump: false,
      // @option maxBoundsViscosity: Number = 0.0
      // If `maxBounds` is set, this option will control how solid the bounds
      // are when dragging the map around. The default value of `0.0` allows the
      // user to drag outside the bounds at normal speed, higher values will
      // slow down map dragging outside bounds, and `1.0` makes the bounds fully
      // solid, preventing the user from dragging outside the bounds.
      maxBoundsViscosity: 0
    });
    var Drag = Handler.extend({
      addHooks: function() {
        if (!this._draggable) {
          var map = this._map;
          this._draggable = new Draggable(map._mapPane, map._container);
          this._draggable.on({
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this);
          this._draggable.on("predrag", this._onPreDragLimit, this);
          if (map.options.worldCopyJump) {
            this._draggable.on("predrag", this._onPreDragWrap, this);
            map.on("zoomend", this._onZoomEnd, this);
            map.whenReady(this._onZoomEnd, this);
          }
        }
        addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
        this._draggable.enable();
        this._positions = [];
        this._times = [];
      },
      removeHooks: function() {
        removeClass(this._map._container, "leaflet-grab");
        removeClass(this._map._container, "leaflet-touch-drag");
        this._draggable.disable();
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      moving: function() {
        return this._draggable && this._draggable._moving;
      },
      _onDragStart: function() {
        var map = this._map;
        map._stop();
        if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
          var bounds = toLatLngBounds(this._map.options.maxBounds);
          this._offsetLimit = toBounds2(
            this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
            this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
          );
          this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
        } else {
          this._offsetLimit = null;
        }
        map.fire("movestart").fire("dragstart");
        if (map.options.inertia) {
          this._positions = [];
          this._times = [];
        }
      },
      _onDrag: function(e2) {
        if (this._map.options.inertia) {
          var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
          this._positions.push(pos);
          this._times.push(time);
          this._prunePositions(time);
        }
        this._map.fire("move", e2).fire("drag", e2);
      },
      _prunePositions: function(time) {
        while (this._positions.length > 1 && time - this._times[0] > 50) {
          this._positions.shift();
          this._times.shift();
        }
      },
      _onZoomEnd: function() {
        var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
        this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      },
      _viscousLimit: function(value, threshold) {
        return value - (value - threshold) * this._viscosity;
      },
      _onPreDragLimit: function() {
        if (!this._viscosity || !this._offsetLimit) {
          return;
        }
        var offset = this._draggable._newPos.subtract(this._draggable._startPos);
        var limit = this._offsetLimit;
        if (offset.x < limit.min.x) {
          offset.x = this._viscousLimit(offset.x, limit.min.x);
        }
        if (offset.y < limit.min.y) {
          offset.y = this._viscousLimit(offset.y, limit.min.y);
        }
        if (offset.x > limit.max.x) {
          offset.x = this._viscousLimit(offset.x, limit.max.x);
        }
        if (offset.y > limit.max.y) {
          offset.y = this._viscousLimit(offset.y, limit.max.y);
        }
        this._draggable._newPos = this._draggable._startPos.add(offset);
      },
      _onPreDragWrap: function() {
        var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x2 = this._draggable._newPos.x, newX1 = (x2 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x2 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
        this._draggable._absPos = this._draggable._newPos.clone();
        this._draggable._newPos.x = newX;
      },
      _onDragEnd: function(e2) {
        var map = this._map, options = map.options, noInertia = !options.inertia || e2.noInertia || this._times.length < 2;
        map.fire("dragend", e2);
        if (noInertia) {
          map.fire("moveend");
        } else {
          this._prunePositions(+/* @__PURE__ */ new Date());
          var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
          if (!offset.x && !offset.y) {
            map.fire("moveend");
          } else {
            offset = map._limitOffset(offset, map.options.maxBounds);
            requestAnimFrame(function() {
              map.panBy(offset, {
                duration: decelerationDuration,
                easeLinearity: ease,
                noMoveStart: true,
                animate: true
              });
            });
          }
        }
      }
    });
    Map2.addInitHook("addHandler", "dragging", Drag);
    Map2.mergeOptions({
      // @option keyboard: Boolean = true
      // Makes the map focusable and allows users to navigate the map with keyboard
      // arrows and `+`/`-` keys.
      keyboard: true,
      // @option keyboardPanDelta: Number = 80
      // Amount of pixels to pan when pressing an arrow key.
      keyboardPanDelta: 80
    });
    var Keyboard = Handler.extend({
      keyCodes: {
        left: [37],
        right: [39],
        down: [40],
        up: [38],
        zoomIn: [187, 107, 61, 171],
        zoomOut: [189, 109, 54, 173]
      },
      initialize: function(map) {
        this._map = map;
        this._setPanDelta(map.options.keyboardPanDelta);
        this._setZoomDelta(map.options.zoomDelta);
      },
      addHooks: function() {
        var container = this._map._container;
        if (container.tabIndex <= 0) {
          container.tabIndex = "0";
        }
        on(container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this);
        this._map.on({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      removeHooks: function() {
        this._removeHooks();
        off(this._map._container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this);
        this._map.off({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      _onMouseDown: function() {
        if (this._focused) {
          return;
        }
        var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
        this._map._container.focus();
        window.scrollTo(left, top);
      },
      _onFocus: function() {
        this._focused = true;
        this._map.fire("focus");
      },
      _onBlur: function() {
        this._focused = false;
        this._map.fire("blur");
      },
      _setPanDelta: function(panDelta) {
        var keys3 = this._panKeys = {}, codes = this.keyCodes, i, len;
        for (i = 0, len = codes.left.length; i < len; i++) {
          keys3[codes.left[i]] = [-1 * panDelta, 0];
        }
        for (i = 0, len = codes.right.length; i < len; i++) {
          keys3[codes.right[i]] = [panDelta, 0];
        }
        for (i = 0, len = codes.down.length; i < len; i++) {
          keys3[codes.down[i]] = [0, panDelta];
        }
        for (i = 0, len = codes.up.length; i < len; i++) {
          keys3[codes.up[i]] = [0, -1 * panDelta];
        }
      },
      _setZoomDelta: function(zoomDelta) {
        var keys3 = this._zoomKeys = {}, codes = this.keyCodes, i, len;
        for (i = 0, len = codes.zoomIn.length; i < len; i++) {
          keys3[codes.zoomIn[i]] = zoomDelta;
        }
        for (i = 0, len = codes.zoomOut.length; i < len; i++) {
          keys3[codes.zoomOut[i]] = -zoomDelta;
        }
      },
      _addHooks: function() {
        on(document, "keydown", this._onKeyDown, this);
      },
      _removeHooks: function() {
        off(document, "keydown", this._onKeyDown, this);
      },
      _onKeyDown: function(e2) {
        if (e2.altKey || e2.ctrlKey || e2.metaKey) {
          return;
        }
        var key = e2.keyCode, map = this._map, offset;
        if (key in this._panKeys) {
          if (!map._panAnim || !map._panAnim._inProgress) {
            offset = this._panKeys[key];
            if (e2.shiftKey) {
              offset = toPoint(offset).multiplyBy(3);
            }
            if (map.options.maxBounds) {
              offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
            }
            if (map.options.worldCopyJump) {
              var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
              map.panTo(newLatLng);
            } else {
              map.panBy(offset);
            }
          }
        } else if (key in this._zoomKeys) {
          map.setZoom(map.getZoom() + (e2.shiftKey ? 3 : 1) * this._zoomKeys[key]);
        } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
          map.closePopup();
        } else {
          return;
        }
        stop(e2);
      }
    });
    Map2.addInitHook("addHandler", "keyboard", Keyboard);
    Map2.mergeOptions({
      // @section Mouse wheel options
      // @option scrollWheelZoom: Boolean|String = true
      // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
      // it will zoom to the center of the view regardless of where the mouse was.
      scrollWheelZoom: true,
      // @option wheelDebounceTime: Number = 40
      // Limits the rate at which a wheel can fire (in milliseconds). By default
      // user can't zoom via wheel more often than once per 40 ms.
      wheelDebounceTime: 40,
      // @option wheelPxPerZoomLevel: Number = 60
      // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
      // mean a change of one full zoom level. Smaller values will make wheel-zooming
      // faster (and vice versa).
      wheelPxPerZoomLevel: 60
    });
    var ScrollWheelZoom = Handler.extend({
      addHooks: function() {
        on(this._map._container, "wheel", this._onWheelScroll, this);
        this._delta = 0;
      },
      removeHooks: function() {
        off(this._map._container, "wheel", this._onWheelScroll, this);
      },
      _onWheelScroll: function(e2) {
        var delta = getWheelDelta(e2);
        var debounce = this._map.options.wheelDebounceTime;
        this._delta += delta;
        this._lastMousePos = this._map.mouseEventToContainerPoint(e2);
        if (!this._startTime) {
          this._startTime = +/* @__PURE__ */ new Date();
        }
        var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
        clearTimeout(this._timer);
        this._timer = setTimeout(bind3(this._performZoom, this), left);
        stop(e2);
      },
      _performZoom: function() {
        var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
        map._stop();
        var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
        this._delta = 0;
        this._startTime = null;
        if (!delta) {
          return;
        }
        if (map.options.scrollWheelZoom === "center") {
          map.setZoom(zoom2 + delta);
        } else {
          map.setZoomAround(this._lastMousePos, zoom2 + delta);
        }
      }
    });
    Map2.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
    var tapHoldDelay = 600;
    Map2.mergeOptions({
      // @section Touch interaction options
      // @option tapHold: Boolean
      // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
      tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
      // @option tapTolerance: Number = 15
      // The max number of pixels a user can shift his finger during touch
      // for it to be considered a valid tap.
      tapTolerance: 15
    });
    var TapHold = Handler.extend({
      addHooks: function() {
        on(this._map._container, "touchstart", this._onDown, this);
      },
      removeHooks: function() {
        off(this._map._container, "touchstart", this._onDown, this);
      },
      _onDown: function(e2) {
        clearTimeout(this._holdTimeout);
        if (e2.touches.length !== 1) {
          return;
        }
        var first = e2.touches[0];
        this._startPos = this._newPos = new Point(first.clientX, first.clientY);
        this._holdTimeout = setTimeout(bind3(function() {
          this._cancel();
          if (!this._isTapValid()) {
            return;
          }
          on(document, "touchend", preventDefault);
          on(document, "touchend touchcancel", this._cancelClickPrevent);
          this._simulateEvent("contextmenu", first);
        }, this), tapHoldDelay);
        on(document, "touchend touchcancel contextmenu", this._cancel, this);
        on(document, "touchmove", this._onMove, this);
      },
      _cancelClickPrevent: function cancelClickPrevent() {
        off(document, "touchend", preventDefault);
        off(document, "touchend touchcancel", cancelClickPrevent);
      },
      _cancel: function() {
        clearTimeout(this._holdTimeout);
        off(document, "touchend touchcancel contextmenu", this._cancel, this);
        off(document, "touchmove", this._onMove, this);
      },
      _onMove: function(e2) {
        var first = e2.touches[0];
        this._newPos = new Point(first.clientX, first.clientY);
      },
      _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      },
      _simulateEvent: function(type2, e2) {
        var simulatedEvent = new MouseEvent(type2, {
          bubbles: true,
          cancelable: true,
          view: window,
          // detail: 1,
          screenX: e2.screenX,
          screenY: e2.screenY,
          clientX: e2.clientX,
          clientY: e2.clientY
          // button: 2,
          // buttons: 2
        });
        simulatedEvent._simulated = true;
        e2.target.dispatchEvent(simulatedEvent);
      }
    });
    Map2.addInitHook("addHandler", "tapHold", TapHold);
    Map2.mergeOptions({
      // @section Touch interaction options
      // @option touchZoom: Boolean|String = *
      // Whether the map can be zoomed by touch-dragging with two fingers. If
      // passed `'center'`, it will zoom to the center of the view regardless of
      // where the touch events (fingers) were. Enabled for touch-capable web
      // browsers.
      touchZoom: Browser.touch,
      // @option bounceAtZoomLimits: Boolean = true
      // Set it to false if you don't want the map to zoom beyond min/max zoom
      // and then bounce back when pinch-zooming.
      bounceAtZoomLimits: true
    });
    var TouchZoom = Handler.extend({
      addHooks: function() {
        addClass(this._map._container, "leaflet-touch-zoom");
        on(this._map._container, "touchstart", this._onTouchStart, this);
      },
      removeHooks: function() {
        removeClass(this._map._container, "leaflet-touch-zoom");
        off(this._map._container, "touchstart", this._onTouchStart, this);
      },
      _onTouchStart: function(e2) {
        var map = this._map;
        if (!e2.touches || e2.touches.length !== 2 || map._animatingZoom || this._zooming) {
          return;
        }
        var p1 = map.mouseEventToContainerPoint(e2.touches[0]), p2 = map.mouseEventToContainerPoint(e2.touches[1]);
        this._centerPoint = map.getSize()._divideBy(2);
        this._startLatLng = map.containerPointToLatLng(this._centerPoint);
        if (map.options.touchZoom !== "center") {
          this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
        }
        this._startDist = p1.distanceTo(p2);
        this._startZoom = map.getZoom();
        this._moved = false;
        this._zooming = true;
        map._stop();
        on(document, "touchmove", this._onTouchMove, this);
        on(document, "touchend touchcancel", this._onTouchEnd, this);
        preventDefault(e2);
      },
      _onTouchMove: function(e2) {
        if (!e2.touches || e2.touches.length !== 2 || !this._zooming) {
          return;
        }
        var map = this._map, p1 = map.mouseEventToContainerPoint(e2.touches[0]), p2 = map.mouseEventToContainerPoint(e2.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
        this._zoom = map.getScaleZoom(scale2, this._startZoom);
        if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
          this._zoom = map._limitZoom(this._zoom);
        }
        if (map.options.touchZoom === "center") {
          this._center = this._startLatLng;
          if (scale2 === 1) {
            return;
          }
        } else {
          var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
          if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
            return;
          }
          this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
        }
        if (!this._moved) {
          map._moveStart(true, false);
          this._moved = true;
        }
        cancelAnimFrame(this._animRequest);
        var moveFn = bind3(map._move, map, this._center, this._zoom, { pinch: true, round: false }, void 0);
        this._animRequest = requestAnimFrame(moveFn, this, true);
        preventDefault(e2);
      },
      _onTouchEnd: function() {
        if (!this._moved || !this._zooming) {
          this._zooming = false;
          return;
        }
        this._zooming = false;
        cancelAnimFrame(this._animRequest);
        off(document, "touchmove", this._onTouchMove, this);
        off(document, "touchend touchcancel", this._onTouchEnd, this);
        if (this._map.options.zoomAnimation) {
          this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
        } else {
          this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      }
    });
    Map2.addInitHook("addHandler", "touchZoom", TouchZoom);
    Map2.BoxZoom = BoxZoom;
    Map2.DoubleClickZoom = DoubleClickZoom;
    Map2.Drag = Drag;
    Map2.Keyboard = Keyboard;
    Map2.ScrollWheelZoom = ScrollWheelZoom;
    Map2.TapHold = TapHold;
    Map2.TouchZoom = TouchZoom;
    exports2.Bounds = Bounds;
    exports2.Browser = Browser;
    exports2.CRS = CRS;
    exports2.Canvas = Canvas;
    exports2.Circle = Circle;
    exports2.CircleMarker = CircleMarker;
    exports2.Class = Class;
    exports2.Control = Control;
    exports2.DivIcon = DivIcon;
    exports2.DivOverlay = DivOverlay;
    exports2.DomEvent = DomEvent;
    exports2.DomUtil = DomUtil;
    exports2.Draggable = Draggable;
    exports2.Evented = Evented;
    exports2.FeatureGroup = FeatureGroup;
    exports2.GeoJSON = GeoJSON2;
    exports2.GridLayer = GridLayer;
    exports2.Handler = Handler;
    exports2.Icon = Icon;
    exports2.ImageOverlay = ImageOverlay;
    exports2.LatLng = LatLng;
    exports2.LatLngBounds = LatLngBounds;
    exports2.Layer = Layer;
    exports2.LayerGroup = LayerGroup;
    exports2.LineUtil = LineUtil;
    exports2.Map = Map2;
    exports2.Marker = Marker2;
    exports2.Mixin = Mixin;
    exports2.Path = Path;
    exports2.Point = Point;
    exports2.PolyUtil = PolyUtil;
    exports2.Polygon = Polygon;
    exports2.Polyline = Polyline;
    exports2.Popup = Popup;
    exports2.PosAnimation = PosAnimation;
    exports2.Projection = index;
    exports2.Rectangle = Rectangle;
    exports2.Renderer = Renderer;
    exports2.SVG = SVG;
    exports2.SVGOverlay = SVGOverlay;
    exports2.TileLayer = TileLayer2;
    exports2.Tooltip = Tooltip;
    exports2.Transformation = Transformation;
    exports2.Util = Util;
    exports2.VideoOverlay = VideoOverlay;
    exports2.bind = bind3;
    exports2.bounds = toBounds2;
    exports2.canvas = canvas;
    exports2.circle = circle2;
    exports2.circleMarker = circleMarker;
    exports2.control = control;
    exports2.divIcon = divIcon;
    exports2.extend = extend;
    exports2.featureGroup = featureGroup;
    exports2.geoJSON = geoJSON;
    exports2.geoJson = geoJson;
    exports2.gridLayer = gridLayer;
    exports2.icon = icon;
    exports2.imageOverlay = imageOverlay;
    exports2.latLng = toLatLng2;
    exports2.latLngBounds = toLatLngBounds;
    exports2.layerGroup = layerGroup;
    exports2.map = createMap;
    exports2.marker = marker;
    exports2.point = toPoint;
    exports2.polygon = polygon2;
    exports2.polyline = polyline;
    exports2.popup = popup;
    exports2.rectangle = rectangle;
    exports2.setOptions = setOptions;
    exports2.stamp = stamp;
    exports2.svg = svg;
    exports2.svgOverlay = svgOverlay;
    exports2.tileLayer = tileLayer;
    exports2.tooltip = tooltip;
    exports2.transformation = toTransformation;
    exports2.version = version;
    exports2.videoOverlay = videoOverlay;
    var oldL = window.L;
    exports2.noConflict = function() {
      window.L = oldL;
      return this;
    };
    window.L = exports2;
  });
})(leafletSrc, leafletSrc.exports);
var leafletSrcExports = leafletSrc.exports;
const L$3 = /* @__PURE__ */ getDefaultExportFromCjs(leafletSrcExports);
function splitClassName(className) {
  return className.split(" ").filter(Boolean);
}
function addClassName(element, className) {
  splitClassName(className).forEach((cls) => {
    leafletSrcExports.DomUtil.addClass(element, cls);
  });
}
function createElementObject(instance, context, container) {
  return Object.freeze({
    instance,
    context,
    container
  });
}
function createElementHook(createElement, updateElement) {
  if (updateElement == null) {
    return function useImmutableLeafletElement(props, context) {
      const elementRef = reactExports.useRef();
      if (!elementRef.current) elementRef.current = createElement(props, context);
      return elementRef;
    };
  }
  return function useMutableLeafletElement(props, context) {
    const elementRef = reactExports.useRef();
    if (!elementRef.current) elementRef.current = createElement(props, context);
    const propsRef = reactExports.useRef(props);
    const { instance } = elementRef.current;
    reactExports.useEffect(function updateElementProps() {
      if (propsRef.current !== props) {
        updateElement(instance, props, propsRef.current);
        propsRef.current = props;
      }
    }, [
      instance,
      props,
      context
    ]);
    return elementRef;
  };
}
function useLayerLifecycle(element, context) {
  reactExports.useEffect(function addLayer() {
    const container = context.layerContainer ?? context.map;
    container.addLayer(element.instance);
    return function removeLayer() {
      var _a;
      (_a = context.layerContainer) == null ? void 0 : _a.removeLayer(element.instance);
      context.map.removeLayer(element.instance);
    };
  }, [
    context,
    element
  ]);
}
function createLayerHook(useElement) {
  return function useLayer(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useAttribution(context.map, props.attribution);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    return elementRef;
  };
}
function usePathOptions(element, props) {
  const optionsRef = reactExports.useRef();
  reactExports.useEffect(function updatePathOptions() {
    if (props.pathOptions !== optionsRef.current) {
      const options = props.pathOptions ?? {};
      element.instance.setStyle(options);
      optionsRef.current = options;
    }
  }, [
    element,
    props
  ]);
}
function createPathHook(useElement) {
  return function usePath(props) {
    const context = useLeafletContext();
    const elementRef = useElement(withPane(props, context), context);
    useEventHandlers(elementRef.current, props.eventHandlers);
    useLayerLifecycle(elementRef.current, context);
    usePathOptions(elementRef.current, props);
    return elementRef;
  };
}
function createControlComponent(createInstance) {
  function createElement(props, context) {
    return createElementObject(createInstance(props), context);
  }
  const useElement = createElementHook(createElement);
  const useControl = createControlHook(useElement);
  return createLeafComponent(useControl);
}
function createLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createContainerComponent(useLayer);
}
function createPathComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const usePath = createPathHook(useElement);
  return createContainerComponent(usePath);
}
function createTileLayerComponent(createElement, updateElement) {
  const useElement = createElementHook(createElement, updateElement);
  const useLayer = createLayerHook(useElement);
  return createLeafComponent(useLayer);
}
function updateGridLayer(layer, props, prevProps) {
  const { opacity, zIndex } = props;
  if (opacity != null && opacity !== prevProps.opacity) {
    layer.setOpacity(opacity);
  }
  if (zIndex != null && zIndex !== prevProps.zIndex) {
    layer.setZIndex(zIndex);
  }
}
function useMap() {
  return useLeafletContext().map;
}
const AttributionControl = createControlComponent(function createAttributionControl(props) {
  return new leafletSrcExports.Control.Attribution(props);
});
const useLayersControlElement = createElementHook(function createLayersControl({ children: _c, ...options }, ctx) {
  const control = new leafletSrcExports.Control.Layers(void 0, void 0, options);
  return createElementObject(control, extendContext(ctx, {
    layersControl: control
  }));
}, function updateLayersControl(control, props, prevProps) {
  if (props.collapsed !== prevProps.collapsed) {
    if (props.collapsed === true) {
      control.collapse();
    } else {
      control.expand();
    }
  }
});
const useLayersControl = createControlHook(useLayersControlElement);
const LayersControl = createContainerComponent(useLayersControl);
function createControlledLayer(addLayerToControl) {
  return function ControlledLayer(props) {
    const parentContext = useLeafletContext();
    const propsRef = reactExports.useRef(props);
    const [layer, setLayer] = reactExports.useState(null);
    const { layersControl, map } = parentContext;
    const addLayer = reactExports.useCallback((layerToAdd) => {
      if (layersControl != null) {
        if (propsRef.current.checked) {
          map.addLayer(layerToAdd);
        }
        addLayerToControl(layersControl, layerToAdd, propsRef.current.name);
        setLayer(layerToAdd);
      }
    }, [
      layersControl,
      map
    ]);
    const removeLayer = reactExports.useCallback((layerToRemove) => {
      layersControl == null ? void 0 : layersControl.removeLayer(layerToRemove);
      setLayer(null);
    }, [
      layersControl
    ]);
    const context = reactExports.useMemo(() => {
      return extendContext(parentContext, {
        layerContainer: {
          addLayer,
          removeLayer
        }
      });
    }, [
      parentContext,
      addLayer,
      removeLayer
    ]);
    reactExports.useEffect(() => {
      if (layer !== null && propsRef.current !== props) {
        if (props.checked === true && (propsRef.current.checked == null || propsRef.current.checked === false)) {
          map.addLayer(layer);
        } else if (propsRef.current.checked === true && (props.checked == null || props.checked === false)) {
          map.removeLayer(layer);
        }
        propsRef.current = props;
      }
    });
    return props.children ? /* @__PURE__ */ ReactExports.createElement(LeafletProvider, {
      value: context
    }, props.children) : null;
  };
}
LayersControl.BaseLayer = createControlledLayer(function addBaseLayer(layersControl, layer, name) {
  layersControl.addBaseLayer(layer, name);
});
LayersControl.Overlay = createControlledLayer(function addOverlay(layersControl, layer, name) {
  layersControl.addOverlay(layer, name);
});
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function MapContainerComponent({ bounds, boundsOptions, center: center2, children, className, id: id2, placeholder, style, whenReady, zoom, ...options }, forwardedRef) {
  const [props] = reactExports.useState({
    className,
    id: id2,
    style
  });
  const [context, setContext] = reactExports.useState(null);
  reactExports.useImperativeHandle(forwardedRef, () => (context == null ? void 0 : context.map) ?? null, [
    context
  ]);
  const mapRef = reactExports.useCallback((node) => {
    if (node !== null && context === null) {
      const map = new leafletSrcExports.Map(node, options);
      if (center2 != null && zoom != null) {
        map.setView(center2, zoom);
      } else if (bounds != null) {
        map.fitBounds(bounds, boundsOptions);
      }
      if (whenReady != null) {
        map.whenReady(whenReady);
      }
      setContext(createLeafletContext(map));
    }
  }, []);
  reactExports.useEffect(() => {
    return () => {
      context == null ? void 0 : context.map.remove();
    };
  }, [
    context
  ]);
  const contents = context ? /* @__PURE__ */ ReactExports.createElement(LeafletProvider, {
    value: context
  }, children) : placeholder ?? null;
  return /* @__PURE__ */ ReactExports.createElement("div", _extends({}, props, {
    ref: mapRef
  }), contents);
}
const MapContainer = /* @__PURE__ */ reactExports.forwardRef(MapContainerComponent);
const Marker = createLayerComponent(function createMarker({ position, ...options }, ctx) {
  const marker = new leafletSrcExports.Marker(position, options);
  return createElementObject(marker, extendContext(ctx, {
    overlayContainer: marker
  }));
}, function updateMarker(marker, props, prevProps) {
  if (props.position !== prevProps.position) {
    marker.setLatLng(props.position);
  }
  if (props.icon != null && props.icon !== prevProps.icon) {
    marker.setIcon(props.icon);
  }
  if (props.zIndexOffset != null && props.zIndexOffset !== prevProps.zIndexOffset) {
    marker.setZIndexOffset(props.zIndexOffset);
  }
  if (props.opacity != null && props.opacity !== prevProps.opacity) {
    marker.setOpacity(props.opacity);
  }
  if (marker.dragging != null && props.draggable !== prevProps.draggable) {
    if (props.draggable === true) {
      marker.dragging.enable();
    } else {
      marker.dragging.disable();
    }
  }
});
const DEFAULT_PANES = [
  "mapPane",
  "markerPane",
  "overlayPane",
  "popupPane",
  "shadowPane",
  "tilePane",
  "tooltipPane"
];
function omitPane(obj, pane) {
  const { [pane]: _p, ...others } = obj;
  return others;
}
function createPane(name, props, context) {
  if (DEFAULT_PANES.indexOf(name) !== -1) {
    throw new Error(`You must use a unique name for a pane that is not a default Leaflet pane: ${name}`);
  }
  if (context.map.getPane(name) != null) {
    throw new Error(`A pane with this name already exists: ${name}`);
  }
  const parentPaneName = props.pane ?? context.pane;
  const parentPane = parentPaneName ? context.map.getPane(parentPaneName) : void 0;
  const element = context.map.createPane(name, parentPane);
  if (props.className != null) {
    addClassName(element, props.className);
  }
  if (props.style != null) {
    Object.keys(props.style).forEach((key) => {
      element.style[key] = props.style[key];
    });
  }
  return element;
}
function PaneComponent(props, forwardedRef) {
  const [paneName] = reactExports.useState(props.name);
  const [paneElement, setPaneElement] = reactExports.useState(null);
  reactExports.useImperativeHandle(forwardedRef, () => paneElement, [
    paneElement
  ]);
  const context = useLeafletContext();
  const newContext = reactExports.useMemo(() => ({
    ...context,
    pane: paneName
  }), [
    context
  ]);
  reactExports.useEffect(() => {
    setPaneElement(createPane(paneName, props, context));
    return function removeCreatedPane() {
      var _a;
      const pane = context.map.getPane(paneName);
      (_a = pane == null ? void 0 : pane.remove) == null ? void 0 : _a.call(pane);
      if (context.map._panes != null) {
        context.map._panes = omitPane(context.map._panes, paneName);
        context.map._paneRenderers = omitPane(
          // @ts-ignore map internals
          context.map._paneRenderers,
          paneName
        );
      }
    };
  }, []);
  return props.children != null && paneElement != null ? /* @__PURE__ */ reactDomExports.createPortal(/* @__PURE__ */ ReactExports.createElement(LeafletProvider, {
    value: newContext
  }, props.children), paneElement) : null;
}
const Pane = /* @__PURE__ */ reactExports.forwardRef(PaneComponent);
const ScaleControl = createControlComponent(function createScaleControl(props) {
  return new leafletSrcExports.Control.Scale(props);
});
const TileLayer = createTileLayerComponent(function createTileLayer({ url, ...options }, context) {
  const layer = new leafletSrcExports.TileLayer(url, withPane(options, context));
  return createElementObject(layer, context);
}, function updateTileLayer(layer, props, prevProps) {
  updateGridLayer(layer, props, prevProps);
  const { url } = props;
  if (url != null && url !== prevProps.url) {
    layer.setUrl(url);
  }
});
const WMSTileLayer = createTileLayerComponent(function createWMSTileLayer({ eventHandlers: _eh, params = {}, url, ...options }, context) {
  const layer = new leafletSrcExports.TileLayer.WMS(url, {
    ...params,
    ...withPane(options, context)
  });
  return createElementObject(layer, context);
}, function updateWMSTileLayer(layer, props, prevProps) {
  updateGridLayer(layer, props, prevProps);
  if (props.params != null && props.params !== prevProps.params) {
    layer.setParams(props.params);
  }
});
const ZoomControl = createControlComponent(function createZoomControl(props) {
  return new leafletSrcExports.Control.Zoom(props);
});
var toStr$9 = Object.prototype.toString;
var isArguments$3 = function isArguments(value) {
  var str = toStr$9.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$9.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$b;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation$b;
  hasRequiredImplementation = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments$3;
    var isEnumerable2 = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable2.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable2.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k2 in window) {
        try {
          if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
            try {
              equalsConstructorPrototype(window[k2]);
            } catch (e2) {
              return true;
            }
          }
        } catch (e2) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e2) {
        return false;
      }
    };
    keysShim2 = function keys3(object) {
      var isObject2 = object !== null && typeof object === "object";
      var isFunction2 = toStr2.call(object) === "[object Function]";
      var isArguments5 = isArgs2(object);
      var isString3 = isObject2 && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction2 && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString3 && object.length > 0 && !has2.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments5 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && has2.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k2 = 0; k2 < dontEnums.length; ++k2) {
          if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object, dontEnums[k2])) {
            theKeys.push(dontEnums[k2]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$b = keysShim2;
  return implementation$b;
}
var slice = Array.prototype.slice;
var isArgs = isArguments$3;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : requireImplementation();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$2 = keysShim;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type = TypeError;
var uri = URIError;
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$5 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  __proto__: null,
  foo: {}
};
var $Object$1 = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object$1);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$8 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$a = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$8.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result2 = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result2) === result2) {
        return result2;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound2 = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$9 = implementation$a;
var functionBind = Function.prototype.bind || implementation$9;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call, $hasOwn);
var undefined$1;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError$2 = syntax;
var $TypeError$6 = type;
var $URIError = uri;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$2 = Object.getOwnPropertyDescriptor;
if ($gOPD$2) {
  try {
    $gOPD$2({}, "");
  } catch (e2) {
    $gOPD$2 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$6();
};
var ThrowTypeError = $gOPD$2 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$2(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$4 = hasSymbols$5();
var hasProto2 = hasProto$1();
var getProto$1 = Object.getPrototypeOf || (hasProto2 ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$4 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$4 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$4 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$4 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$2,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$6,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto$1) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto$1(getProto$1(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto$1) {
      value = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$2 = hasown;
var $concat$1 = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec$1 = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$2("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$2("invalid intrinsic syntax, expected opening `%`");
  }
  var result2 = [];
  $replace$1(string, rePropName, function(match, number, quote2, subString) {
    result2[result2.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
  });
  return result2;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$2(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$6("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$2("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$6("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$6('"allowMissing" argument must be a boolean');
  }
  if ($exec$1(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError$2("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$2("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$6("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$2 && i + 1 >= parts.length) {
        var desc = $gOPD$2(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$2(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var GetIntrinsic$8 = getIntrinsic;
var $defineProperty$2 = GetIntrinsic$8("%Object.defineProperty%", true) || false;
if ($defineProperty$2) {
  try {
    $defineProperty$2({}, "a", { value: 1 });
  } catch (e2) {
    $defineProperty$2 = false;
  }
}
var esDefineProperty = $defineProperty$2;
var GetIntrinsic$7 = getIntrinsic;
var $gOPD$1 = GetIntrinsic$7("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var gopd$1 = $gOPD$1;
var $defineProperty$1 = esDefineProperty;
var $SyntaxError$1 = syntax;
var $TypeError$5 = type;
var gopd = gopd$1;
var defineDataProperty$1 = function defineDataProperty(obj, property, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$5("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$5("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$5("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$5("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$5("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$5("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty$1) {
    $defineProperty$1(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property] = value;
  } else {
    throw new $SyntaxError$1("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var $defineProperty = esDefineProperty;
var hasPropertyDescriptors = function hasPropertyDescriptors2() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors;
var keys2 = objectKeys$2;
var hasSymbols$3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$7 = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty2 = defineDataProperty$1;
var isFunction = function(fn) {
  return typeof fn === "function" && toStr$7.call(fn) === "[object Function]";
};
var supportsDescriptors$2 = hasPropertyDescriptors_1();
var defineProperty$1 = function(object, name, value, predicate) {
  if (name in object) {
    if (predicate === true) {
      if (object[name] === value) {
        return;
      }
    } else if (!isFunction(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors$2) {
    defineDataProperty2(object, name, value, true);
  } else {
    defineDataProperty2(object, name, value);
  }
};
var defineProperties$1 = function(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys2(map);
  if (hasSymbols$3) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties$1.supportsDescriptors = !!supportsDescriptors$2;
var defineProperties_1 = defineProperties$1;
var callBind$6 = { exports: {} };
var GetIntrinsic$6 = getIntrinsic;
var define$5 = defineDataProperty$1;
var hasDescriptors$1 = hasPropertyDescriptors_1();
var gOPD$4 = gopd$1;
var $TypeError$4 = type;
var $floor$1 = GetIntrinsic$6("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length) {
  if (typeof fn !== "function") {
    throw new $TypeError$4("`fn` is not a function");
  }
  if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor$1(length) !== length) {
    throw new $TypeError$4("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD$4) {
    var desc = gOPD$4(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors$1) {
      define$5(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length,
        true,
        true
      );
    } else {
      define$5(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length
      );
    }
  }
  return fn;
};
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = type;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty2 = esDefineProperty;
  var $max = GetIntrinsic3("%Math.max%");
  module.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind3, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$6);
var callBindExports = callBind$6.exports;
var GetIntrinsic$5 = getIntrinsic;
var callBind$5 = callBindExports;
var $indexOf$1 = callBind$5(GetIntrinsic$5("String.prototype.indexOf"));
var callBound$c = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$5(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.") > -1) {
    return callBind$5(intrinsic);
  }
  return intrinsic;
};
var objectKeys$1 = objectKeys$2;
var hasSymbols$2 = shams$1();
var callBound$b = callBound$c;
var toObject = Object;
var $push = callBound$b("Array.prototype.push");
var $propIsEnumerable = callBound$b("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols$2 ? Object.getOwnPropertySymbols : null;
var implementation$8 = function assign(target, source1) {
  if (target == null) {
    throw new TypeError("target must be an object");
  }
  var to = toObject(target);
  if (arguments.length === 1) {
    return to;
  }
  for (var s2 = 1; s2 < arguments.length; ++s2) {
    var from = toObject(arguments[s2]);
    var keys3 = objectKeys$1(from);
    var getSymbols = hasSymbols$2 && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j = 0; j < syms.length; ++j) {
        var key = syms[j];
        if ($propIsEnumerable(from, key)) {
          $push(keys3, key);
        }
      }
    }
    for (var i = 0; i < keys3.length; ++i) {
      var nextKey = keys3[i];
      if ($propIsEnumerable(from, nextKey)) {
        var propValue = from[nextKey];
        to[nextKey] = propValue;
      }
    }
  }
  return to;
};
var implementation$7 = implementation$8;
var lacksProperEnumerationOrder = function() {
  if (!Object.assign) {
    return false;
  }
  var str = "abcdefghijklmnopqrst";
  var letters = str.split("");
  var map = {};
  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map);
  var actual = "";
  for (var k2 in obj) {
    actual += k2;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  var thrower = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(thrower, "xy");
  } catch (e2) {
    return thrower[1] === "y";
  }
  return false;
};
var polyfill$4 = function getPolyfill() {
  if (!Object.assign) {
    return implementation$7;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation$7;
  }
  if (assignHasPendingExceptions()) {
    return implementation$7;
  }
  return Object.assign;
};
var define$4 = defineProperties_1;
var getPolyfill$5 = polyfill$4;
var shim$6 = function shimAssign() {
  var polyfill3 = getPolyfill$5();
  define$4(
    Object,
    { assign: polyfill3 },
    { assign: function() {
      return Object.assign !== polyfill3;
    } }
  );
  return polyfill3;
};
var defineProperties = defineProperties_1;
var callBind$4 = callBindExports;
var implementation$6 = implementation$8;
var getPolyfill$4 = polyfill$4;
var shim$5 = shim$6;
var polyfill$3 = callBind$4.apply(getPolyfill$4());
var bound = function assign2(target, source1) {
  return polyfill$3(Object, arguments);
};
defineProperties(bound, {
  getPolyfill: getPolyfill$4,
  implementation: implementation$6,
  shim: shim$5
});
var object_assign = bound;
var functionsHaveNames = function functionsHaveNames2() {
  return typeof (function f2() {
  }).name === "string";
};
var gOPD$3 = Object.getOwnPropertyDescriptor;
if (gOPD$3) {
  try {
    gOPD$3([], "length");
  } catch (e2) {
    gOPD$3 = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD$3) {
    return false;
  }
  var desc = gOPD$3(function() {
  }, "name");
  return !!desc && !!desc.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === "function" && (function f2() {
  }).bind().name !== "";
};
var functionsHaveNames_1 = functionsHaveNames;
var define$3 = defineDataProperty$1;
var hasDescriptors = hasPropertyDescriptors_1();
var functionsHaveConfigurableNames2 = functionsHaveNames_1.functionsHaveConfigurableNames();
var $TypeError$3 = type;
var setFunctionName$1 = function setFunctionName(fn, name) {
  if (typeof fn !== "function") {
    throw new $TypeError$3("`fn` is not a function");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  if (!loose || functionsHaveConfigurableNames2) {
    if (hasDescriptors) {
      define$3(
        /** @type {Parameters<define>[0]} */
        fn,
        "name",
        name,
        true,
        true
      );
    } else {
      define$3(
        /** @type {Parameters<define>[0]} */
        fn,
        "name",
        name
      );
    }
  }
  return fn;
};
var setFunctionName2 = setFunctionName$1;
var $TypeError$2 = type;
var $Object = Object;
var implementation$5 = setFunctionName2(function flags() {
  if (this == null || this !== $Object(this)) {
    throw new $TypeError$2("RegExp.prototype.flags getter called on non-object");
  }
  var result2 = "";
  if (this.hasIndices) {
    result2 += "d";
  }
  if (this.global) {
    result2 += "g";
  }
  if (this.ignoreCase) {
    result2 += "i";
  }
  if (this.multiline) {
    result2 += "m";
  }
  if (this.dotAll) {
    result2 += "s";
  }
  if (this.unicode) {
    result2 += "u";
  }
  if (this.unicodeSets) {
    result2 += "v";
  }
  if (this.sticky) {
    result2 += "y";
  }
  return result2;
}, "get flags", true);
var implementation$4 = implementation$5;
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD = Object.getOwnPropertyDescriptor;
var polyfill$2 = function getPolyfill2() {
  if (supportsDescriptors$1 && /a/mig.flags === "gim") {
    var descriptor = $gOPD(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
      var calls = "";
      var o = {};
      Object.defineProperty(o, "hasIndices", {
        get: function() {
          calls += "d";
        }
      });
      Object.defineProperty(o, "sticky", {
        get: function() {
          calls += "y";
        }
      });
      if (calls === "dy") {
        return descriptor.get;
      }
    }
  }
  return implementation$4;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var getPolyfill$3 = polyfill$2;
var gOPD$2 = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;
var shim$4 = function shimFlags() {
  if (!supportsDescriptors || !getProto) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill3 = getPolyfill$3();
  var proto = getProto(regex);
  var descriptor = gOPD$2(proto, "flags");
  if (!descriptor || descriptor.get !== polyfill3) {
    defineProperty(proto, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill3
    });
  }
  return polyfill3;
};
var define$2 = defineProperties_1;
var callBind$3 = callBindExports;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$2;
var shim$3 = shim$4;
var flagsBound = callBind$3(getPolyfill$2());
define$2(flagsBound, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$3
});
var regexp_prototype_flags = flagsBound;
var esGetIterator = { exports: {} };
var hasSymbols$1 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$1() && !!Symbol.toStringTag;
};
var hasToStringTag$7 = shams();
var callBound$a = callBound$c;
var $toString$4 = callBound$a("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$7 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$4(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$4(value) !== "[object Array]" && $toString$4(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice$1 = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf$1 = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO$1 = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice$1.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol$2(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$2(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$2(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$2(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$2(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp(obj)) {
    var name = nameOf(obj);
    var keys3 = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
  }
  if (isSymbol$2(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$2(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap$4(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf$1("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet$4(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf$1("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap$1(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet$1(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber$2(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt$1(obj)) {
    return markBoxed(inspect2(bigIntValueOf$1.call(obj)));
  }
  if (isBoolean$1(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$3(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate$1(obj) && !isRegExp(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO$1 ? gPO$1(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice$1.call(toStr$6(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace.call(String(s2), /"/g, "&quot;");
}
function isArray$2(obj) {
  return toStr$6(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate$1(obj) {
  return toStr$6(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp(obj) {
  return toStr$6(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr$6(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$3(obj) {
  return toStr$6(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber$2(obj) {
  return toStr$6(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean$1(obj) {
  return toStr$6(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol$2(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt$1(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf$1) {
    return false;
  }
  try {
    bigIntValueOf$1.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$2(obj, key) {
  return hasOwn$1.call(obj, key);
}
function toStr$6(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x2) {
      return i;
    }
  }
  return -1;
}
function isMap$4(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s2) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap$1(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet$4(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet$1(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice$1.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c) {
  var n2 = c.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf$1(type2, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$2(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$2(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key in obj) {
    if (!has$2(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic$4 = getIntrinsic;
var callBound$9 = callBound$c;
var inspect = objectInspect;
var $TypeError$1 = type;
var $WeakMap$1 = GetIntrinsic$4("%WeakMap%", true);
var $Map$3 = GetIntrinsic$4("%Map%", true);
var $weakMapGet = callBound$9("WeakMap.prototype.get", true);
var $weakMapSet = callBound$9("WeakMap.prototype.set", true);
var $weakMapHas = callBound$9("WeakMap.prototype.has", true);
var $mapGet$1 = callBound$9("Map.prototype.get", true);
var $mapSet = callBound$9("Map.prototype.set", true);
var $mapHas$5 = callBound$9("Map.prototype.has", true);
var listGetNode = function(list, key) {
  var prev = list;
  var curr;
  for (; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = /** @type {NonNullable<typeof list.next>} */
      list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = /** @type {import('.').ListNode<typeof value>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel2 = {
    assert: function(key) {
      if (!channel2.has(key)) {
        throw new $TypeError$1("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map$3) {
        if ($m) {
          return $mapGet$1($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map$3) {
        if ($m) {
          return $mapHas$5($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap$1();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map$3) {
        if (!$m) {
          $m = new $Map$3();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel2;
};
var hasOwn = hasown;
var channel = sideChannel();
var $TypeError = type;
var SLOT$1 = {
  assert: function(O2, slot) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new $TypeError("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError("`slot` must be a string");
    }
    channel.assert(O2);
    if (!SLOT$1.has(O2, slot)) {
      throw new $TypeError("`" + slot + "` is not present on `O`");
    }
  },
  get: function(O2, slot) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new $TypeError("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError("`slot` must be a string");
    }
    var slots = channel.get(O2);
    return slots && slots["$" + slot];
  },
  has: function(O2, slot) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new $TypeError("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError("`slot` must be a string");
    }
    var slots = channel.get(O2);
    return !!slots && hasOwn(slots, "$" + slot);
  },
  set: function(O2, slot, V2) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new $TypeError("`O` is not an object");
    }
    if (typeof slot !== "string") {
      throw new $TypeError("`slot` must be a string");
    }
    var slots = channel.get(O2);
    if (!slots) {
      slots = {};
      channel.set(O2, slots);
    }
    slots["$" + slot] = V2;
  }
};
if (Object.freeze) {
  Object.freeze(SLOT$1);
}
var internalSlot = SLOT$1;
var SLOT = internalSlot;
var $SyntaxError = SyntaxError;
var $StopIteration = typeof StopIteration === "object" ? StopIteration : null;
var stopIterationIterator = function getStopIterationIterator(origIterator) {
  if (!$StopIteration) {
    throw new $SyntaxError("this environment lacks StopIteration");
  }
  SLOT.set(origIterator, "[[Done]]", false);
  var siIterator = {
    next: function next() {
      var iterator = SLOT.get(this, "[[Iterator]]");
      var done = SLOT.get(iterator, "[[Done]]");
      try {
        return {
          done,
          value: done ? void 0 : iterator.next()
        };
      } catch (e2) {
        SLOT.set(iterator, "[[Done]]", true);
        if (e2 !== $StopIteration) {
          throw e2;
        }
        return {
          done: true,
          value: void 0
        };
      }
    }
  };
  SLOT.set(siIterator, "[[Iterator]]", origIterator);
  return siIterator;
};
var toString = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$5 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$6 = shams();
var isString$2 = function isString(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$6 ? tryStringObject(value) : toStr$5.call(value) === strClass;
};
var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$3 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$2;
if (!$Map$2) {
  exported$2 = function isMap3(x2) {
    return false;
  };
}
var $mapHas$4 = $Map$2 ? Map.prototype.has : null;
var $setHas$4 = $Set$3 ? Set.prototype.has : null;
if (!exported$2 && !$mapHas$4) {
  exported$2 = function isMap3(x2) {
    return false;
  };
}
var isMap$3 = exported$2 || function isMap(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas$4.call(x2);
    if ($setHas$4) {
      try {
        $setHas$4.call(x2);
      } catch (e2) {
        return true;
      }
    }
    return x2 instanceof $Map$2;
  } catch (e2) {
  }
  return false;
};
var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$1;
if (!$Set$2) {
  exported$1 = function isSet3(x2) {
    return false;
  };
}
var $mapHas$3 = $Map$1 ? Map.prototype.has : null;
var $setHas$3 = $Set$2 ? Set.prototype.has : null;
if (!exported$1 && !$setHas$3) {
  exported$1 = function isSet3(x2) {
    return false;
  };
}
var isSet$3 = exported$1 || function isSet(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $setHas$3.call(x2);
    if ($mapHas$3) {
      try {
        $mapHas$3.call(x2);
      } catch (e2) {
        return true;
      }
    }
    return x2 instanceof $Set$2;
  } catch (e2) {
  }
  return false;
};
var isArguments$1 = isArguments$2;
var getStopIterationIterator2 = stopIterationIterator;
if (hasSymbols$5() || shams$1()) {
  var $iterator = Symbol.iterator;
  esGetIterator.exports = function getIterator2(iterable) {
    if (iterable != null && typeof iterable[$iterator] !== "undefined") {
      return iterable[$iterator]();
    }
    if (isArguments$1(iterable)) {
      return Array.prototype[$iterator].call(iterable);
    }
  };
} else {
  var isArray$1 = isarray;
  var isString$1 = isString$2;
  var GetIntrinsic$3 = getIntrinsic;
  var $Map = GetIntrinsic$3("%Map%", true);
  var $Set$1 = GetIntrinsic$3("%Set%", true);
  var callBound$8 = callBound$c;
  var $arrayPush = callBound$8("Array.prototype.push");
  var $charCodeAt = callBound$8("String.prototype.charCodeAt");
  var $stringSlice = callBound$8("String.prototype.slice");
  var advanceStringIndex = function advanceStringIndex2(S2, index) {
    var length = S2.length;
    if (index + 1 >= length) {
      return index + 1;
    }
    var first = $charCodeAt(S2, index);
    if (first < 55296 || first > 56319) {
      return index + 1;
    }
    var second = $charCodeAt(S2, index + 1);
    if (second < 56320 || second > 57343) {
      return index + 1;
    }
    return index + 2;
  };
  var getArrayIterator = function getArrayIterator2(arraylike) {
    var i = 0;
    return {
      next: function next() {
        var done = i >= arraylike.length;
        var value;
        if (!done) {
          value = arraylike[i];
          i += 1;
        }
        return {
          done,
          value
        };
      }
    };
  };
  var getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
    if (isArray$1(iterable) || isArguments$1(iterable)) {
      return getArrayIterator(iterable);
    }
    if (isString$1(iterable)) {
      var i = 0;
      return {
        next: function next() {
          var nextIndex = advanceStringIndex(iterable, i);
          var value = $stringSlice(iterable, i, nextIndex);
          i = nextIndex;
          return {
            done: nextIndex > iterable.length,
            value
          };
        }
      };
    }
    if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
      return iterable["_es6-shim iterator_"]();
    }
  };
  if (!$Map && !$Set$1) {
    esGetIterator.exports = function getIterator2(iterable) {
      if (iterable != null) {
        return getNonCollectionIterator(iterable, true);
      }
    };
  } else {
    var isMap$2 = isMap$3;
    var isSet$2 = isSet$3;
    var $mapForEach = callBound$8("Map.prototype.forEach", true);
    var $setForEach = callBound$8("Set.prototype.forEach", true);
    if (typeof process === "undefined" || !process.versions || !process.versions.node) {
      var $mapIterator = callBound$8("Map.prototype.iterator", true);
      var $setIterator = callBound$8("Set.prototype.iterator", true);
    }
    var $mapAtAtIterator = callBound$8("Map.prototype.@@iterator", true) || callBound$8("Map.prototype._es6-shim iterator_", true);
    var $setAtAtIterator = callBound$8("Set.prototype.@@iterator", true) || callBound$8("Set.prototype._es6-shim iterator_", true);
    var getCollectionIterator = function getCollectionIterator2(iterable) {
      if (isMap$2(iterable)) {
        if ($mapIterator) {
          return getStopIterationIterator2($mapIterator(iterable));
        }
        if ($mapAtAtIterator) {
          return $mapAtAtIterator(iterable);
        }
        if ($mapForEach) {
          var entries = [];
          $mapForEach(iterable, function(v2, k2) {
            $arrayPush(entries, [k2, v2]);
          });
          return getArrayIterator(entries);
        }
      }
      if (isSet$2(iterable)) {
        if ($setIterator) {
          return getStopIterationIterator2($setIterator(iterable));
        }
        if ($setAtAtIterator) {
          return $setAtAtIterator(iterable);
        }
        if ($setForEach) {
          var values = [];
          $setForEach(iterable, function(v2) {
            $arrayPush(values, v2);
          });
          return getArrayIterator(values);
        }
      }
    };
    esGetIterator.exports = function getIterator2(iterable) {
      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
    };
  }
}
var esGetIteratorExports = esGetIterator.exports;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$2 = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};
var implementation$1 = implementation$2;
var polyfill$1 = function getPolyfill3() {
  return typeof Object.is === "function" ? Object.is : implementation$1;
};
var getPolyfill$1 = polyfill$1;
var define$1 = defineProperties_1;
var shim$2 = function shimObjectIs() {
  var polyfill3 = getPolyfill$1();
  define$1(Object, { is: polyfill3 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill3;
    }
  });
  return polyfill3;
};
var define = defineProperties_1;
var callBind$2 = callBindExports;
var implementation = implementation$2;
var getPolyfill4 = polyfill$1;
var shim$1 = shim$2;
var polyfill2 = callBind$2(getPolyfill4(), Object);
define(polyfill2, {
  getPolyfill: getPolyfill4,
  implementation,
  shim: shim$1
});
var objectIs = polyfill2;
var callBind$1 = callBindExports;
var callBound$7 = callBound$c;
var GetIntrinsic$2 = getIntrinsic;
var $ArrayBuffer = GetIntrinsic$2("%ArrayBuffer%", true);
var $byteLength$2 = callBound$7("ArrayBuffer.prototype.byteLength", true);
var $toString$3 = callBound$7("Object.prototype.toString");
var abSlice = !!$ArrayBuffer && !$byteLength$2 && new $ArrayBuffer(0).slice;
var $abSlice = !!abSlice && callBind$1(abSlice);
var isArrayBuffer$2 = $byteLength$2 || $abSlice ? function isArrayBuffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  try {
    if ($byteLength$2) {
      $byteLength$2(obj);
    } else {
      $abSlice(obj, 0);
    }
    return true;
  } catch (e2) {
    return false;
  }
} : $ArrayBuffer ? function isArrayBuffer2(obj) {
  return $toString$3(obj) === "[object ArrayBuffer]";
} : function isArrayBuffer3(obj) {
  return false;
};
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$4 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$5 = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$5 ? tryDateObject(value) : toStr$4.call(value) === dateClass;
};
var callBound$6 = callBound$c;
var hasToStringTag$4 = shams();
var has$1;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$4) {
  has$1 = callBound$6("Object.prototype.hasOwnProperty");
  $exec = callBound$6("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString$2 = callBound$6("Object.prototype.toString");
var gOPD$1 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$4 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD$1(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e2) {
    return e2 === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString$2(value) === regexClass;
};
var callBound$5 = callBound$c;
var $byteLength$1 = callBound$5("SharedArrayBuffer.prototype.byteLength", true);
var isSharedArrayBuffer$1 = $byteLength$1 ? function isSharedArrayBuffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  try {
    $byteLength$1(obj);
    return true;
  } catch (e2) {
    return false;
  }
} : function isSharedArrayBuffer2(obj) {
  return false;
};
var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject2(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$3 = Object.prototype.toString;
var numClass = "[object Number]";
var hasToStringTag$3 = shams();
var isNumberObject = function isNumberObject2(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$3 ? tryNumberObject(value) : toStr$3.call(value) === numClass;
};
var callBound$4 = callBound$c;
var $boolToStr = callBound$4("Boolean.prototype.toString");
var $toString$1 = callBound$4("Object.prototype.toString");
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var boolClass = "[object Boolean]";
var hasToStringTag$2 = shams();
var isBooleanObject = function isBoolean(value) {
  if (typeof value === "boolean") {
    return true;
  }
  if (value === null || typeof value !== "object") {
    return false;
  }
  return hasToStringTag$2 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$1(value) === boolClass;
};
var isSymbol$1 = { exports: {} };
var toStr$2 = Object.prototype.toString;
var hasSymbols2 = hasSymbols$5();
if (hasSymbols2) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== "symbol") {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  isSymbol$1.exports = function isSymbol2(value) {
    if (typeof value === "symbol") {
      return true;
    }
    if (toStr$2.call(value) !== "[object Symbol]") {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e2) {
      return false;
    }
  };
} else {
  isSymbol$1.exports = function isSymbol2(value) {
    return false;
  };
}
var isSymbolExports = isSymbol$1.exports;
var isBigint = { exports: {} };
var $BigInt = typeof BigInt !== "undefined" && BigInt;
var hasBigints = function hasNativeBigInts() {
  return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
};
var hasBigInts = hasBigints();
if (hasBigInts) {
  var bigIntValueOf = BigInt.prototype.valueOf;
  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf.call(value);
      return true;
    } catch (e2) {
    }
    return false;
  };
  isBigint.exports = function isBigInt2(value) {
    if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
      return false;
    }
    if (typeof value === "bigint") {
      return true;
    }
    return tryBigInt(value);
  };
} else {
  isBigint.exports = function isBigInt2(value) {
    return false;
  };
}
var isBigintExports = isBigint.exports;
var isString2 = isString$2;
var isNumber$1 = isNumberObject;
var isBoolean2 = isBooleanObject;
var isSymbol = isSymbolExports;
var isBigInt = isBigintExports;
var whichBoxedPrimitive$1 = function whichBoxedPrimitive(value) {
  if (value == null || typeof value !== "object" && typeof value !== "function") {
    return null;
  }
  if (isString2(value)) {
    return "String";
  }
  if (isNumber$1(value)) {
    return "Number";
  }
  if (isBoolean2(value)) {
    return "Boolean";
  }
  if (isSymbol(value)) {
    return "Symbol";
  }
  if (isBigInt(value)) {
    return "BigInt";
  }
};
var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported;
if (!$WeakMap) {
  exported = function isWeakMap3(x2) {
    return false;
  };
}
var $mapHas$2 = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
if (!exported && !$mapHas$2) {
  exported = function isWeakMap3(x2) {
    return false;
  };
}
var isWeakmap = exported || function isWeakMap(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas$2.call(x2, $mapHas$2);
    if ($setHas$2) {
      try {
        $setHas$2.call(x2, $setHas$2);
      } catch (e2) {
        return true;
      }
    }
    return x2 instanceof $WeakMap;
  } catch (e2) {
  }
  return false;
};
var isWeakset = { exports: {} };
var GetIntrinsic$1 = getIntrinsic;
var callBound$3 = callBound$c;
var $WeakSet = GetIntrinsic$1("%WeakSet%", true);
var $setHas$1 = callBound$3("WeakSet.prototype.has", true);
if ($setHas$1) {
  var $mapHas$1 = callBound$3("WeakMap.prototype.has", true);
  isWeakset.exports = function isWeakSet2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $setHas$1(x2, $setHas$1);
      if ($mapHas$1) {
        try {
          $mapHas$1(x2, $mapHas$1);
        } catch (e2) {
          return true;
        }
      }
      return x2 instanceof $WeakSet;
    } catch (e2) {
    }
    return false;
  };
} else {
  isWeakset.exports = function isWeakSet2(x2) {
    return false;
  };
}
var isWeaksetExports = isWeakset.exports;
var isMap$1 = isMap$3;
var isSet$1 = isSet$3;
var isWeakMap2 = isWeakmap;
var isWeakSet = isWeaksetExports;
var whichCollection$1 = function whichCollection(value) {
  if (value && typeof value === "object") {
    if (isMap$1(value)) {
      return "Map";
    }
    if (isSet$1(value)) {
      return "Set";
    }
    if (isWeakMap2(value)) {
      return "WeakMap";
    }
    if (isWeakSet(value)) {
      return "WeakSet";
    }
  }
  return false;
};
var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e2) {
    return false;
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$1 = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]";
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]";
var hasToStringTag$1 = typeof Symbol === "function" && !!Symbol.toStringTag;
var isIE68 = !(0 in [,]);
var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === "object") {
  var all = document.all;
  if (toStr$1.call(all) === toStr$1.call(document.all)) {
    isDDA = function isDocumentDotAll2(value) {
      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
        try {
          var str = toStr$1.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
        } catch (e2) {
        }
      }
      return false;
    };
  }
}
var isCallable$1 = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e2) {
    if (e2 !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable2(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (hasToStringTag$1) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass2 = toStr$1.call(value);
  if (strClass2 !== fnClass && strClass2 !== genClass && !/^\[object HTML/.test(strClass2)) {
    return false;
  }
  return tryFunctionObject(value);
};
var isCallable3 = isCallable$1;
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray2(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};
var forEachString = function forEachString2(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};
var forEachObject = function forEachObject2(object, iterator, receiver) {
  for (var k2 in object) {
    if (hasOwnProperty.call(object, k2)) {
      if (receiver == null) {
        iterator(object[k2], k2, object);
      } else {
        iterator.call(receiver, object[k2], k2, object);
      }
    }
  }
};
var forEach$1 = function forEach(list, iterator, thisArg) {
  if (!isCallable3(iterator)) {
    throw new TypeError("iterator must be a function");
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr.call(list) === "[object Array]") {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === "string") {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};
var forEach_1 = forEach$1;
var possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
];
var possibleNames = possibleTypedArrayNames;
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$1 = function availableTypedArrays() {
  var out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g$1[possibleNames[i]] === "function") {
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};
var forEach2 = forEach_1;
var availableTypedArrays2 = availableTypedArrays$1;
var callBind = callBindExports;
var callBound$2 = callBound$c;
var gOPD = gopd$1;
var $toString = callBound$2("Object.prototype.toString");
var hasToStringTag = shams();
var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays2();
var $slice = callBound$2("String.prototype.slice");
var getPrototypeOf$1 = Object.getPrototypeOf;
var $indexOf = callBound$2("Array.prototype.indexOf", true) || function indexOf2(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf$1) {
  forEach2(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf$1(arr);
      var descriptor = gOPD(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      cache["$" + typedArray] = callBind(descriptor.get);
    }
  });
} else {
  forEach2(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    var fn = arr.slice || arr.set;
    if (fn) {
      cache["$" + typedArray] = callBind(fn);
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var found = false;
  forEach2(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(getter, typedArray) {
      if (!found) {
        try {
          if ("$" + getter(value) === typedArray) {
            found = $slice(typedArray, 1);
          }
        } catch (e2) {
        }
      }
    }
  );
  return found;
};
var trySlices = function tryAllSlices(value) {
  var found = false;
  forEach2(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(getter, name) {
      if (!found) {
        try {
          getter(value);
          found = $slice(name, 1);
        } catch (e2) {
        }
      }
    }
  );
  return found;
};
var whichTypedArray$1 = function whichTypedArray(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (!hasToStringTag) {
    var tag = $slice($toString(value), 8, -1);
    if ($indexOf(typedArrays, tag) > -1) {
      return tag;
    }
    if (tag !== "Object") {
      return false;
    }
    return trySlices(value);
  }
  if (!gOPD) {
    return null;
  }
  return tryTypedArrays(value);
};
var callBound$1 = callBound$c;
var $byteLength = callBound$1("ArrayBuffer.prototype.byteLength", true);
var isArrayBuffer$1 = isArrayBuffer$2;
var arrayBufferByteLength = function byteLength(ab2) {
  if (!isArrayBuffer$1(ab2)) {
    return NaN;
  }
  return $byteLength ? $byteLength(ab2) : ab2.byteLength;
};
var assign3 = object_assign;
var callBound = callBound$c;
var flags2 = regexp_prototype_flags;
var GetIntrinsic2 = getIntrinsic;
var getIterator = esGetIteratorExports;
var getSideChannel2 = sideChannel;
var is$1 = objectIs;
var isArguments4 = isArguments$2;
var isArray = isarray;
var isArrayBuffer4 = isArrayBuffer$2;
var isDate = isDateObject;
var isRegex3 = isRegex$1;
var isSharedArrayBuffer3 = isSharedArrayBuffer$1;
var objectKeys = objectKeys$2;
var whichBoxedPrimitive2 = whichBoxedPrimitive$1;
var whichCollection2 = whichCollection$1;
var whichTypedArray2 = whichTypedArray$1;
var byteLength2 = arrayBufferByteLength;
var sabByteLength = callBound("SharedArrayBuffer.prototype.byteLength", true);
var $getTime = callBound("Date.prototype.getTime");
var gPO = Object.getPrototypeOf;
var $objToString = callBound("Object.prototype.toString");
var $Set = GetIntrinsic2("%Set%", true);
var $mapHas = callBound("Map.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSize = callBound("Map.prototype.size", true);
var $setAdd = callBound("Set.prototype.add", true);
var $setDelete = callBound("Set.prototype.delete", true);
var $setHas = callBound("Set.prototype.has", true);
var $setSize = callBound("Set.prototype.size", true);
function setHasEqualElement(set2, val1, opts, channel2) {
  var i = getIterator(set2);
  var result2;
  while ((result2 = i.next()) && !result2.done) {
    if (internalDeepEqual(val1, result2.value, opts, channel2)) {
      $setDelete(set2, result2.value);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives(prim) {
  if (typeof prim === "undefined") {
    return null;
  }
  if (typeof prim === "object") {
    return void 0;
  }
  if (typeof prim === "symbol") {
    return false;
  }
  if (typeof prim === "string" || typeof prim === "number") {
    return +prim === +prim;
  }
  return true;
}
function mapMightHaveLoosePrim(a, b, prim, item, opts, channel2) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = $mapGet(b, altValue);
  var looseOpts = assign3({}, opts, { strict: false });
  if (typeof curB === "undefined" && !$mapHas(b, altValue) || !internalDeepEqual(item, curB, looseOpts, channel2)) {
    return false;
  }
  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel2);
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  return $setHas(b, altValue) && !$setHas(a, altValue);
}
function mapHasEqualEntry(set2, map, key1, item1, opts, channel2) {
  var i = getIterator(set2);
  var result2;
  var key2;
  while ((result2 = i.next()) && !result2.done) {
    key2 = result2.value;
    if (
      // eslint-disable-next-line no-use-before-define
      internalDeepEqual(key1, key2, opts, channel2) && internalDeepEqual(item1, $mapGet(map, key2), opts, channel2)
    ) {
      $setDelete(set2, key2);
      return true;
    }
  }
  return false;
}
function internalDeepEqual(actual, expected, options, channel2) {
  var opts = options || {};
  if (opts.strict ? is$1(actual, expected) : actual === expected) {
    return true;
  }
  var actualBoxed = whichBoxedPrimitive2(actual);
  var expectedBoxed = whichBoxedPrimitive2(expected);
  if (actualBoxed !== expectedBoxed) {
    return false;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? is$1(actual, expected) : actual == expected;
  }
  var hasActual = channel2.has(actual);
  var hasExpected = channel2.has(expected);
  var sentinel;
  if (hasActual && hasExpected) {
    if (channel2.get(actual) === channel2.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }
  if (!hasActual) {
    channel2.set(actual, sentinel);
  }
  if (!hasExpected) {
    channel2.set(expected, sentinel);
  }
  return objEquiv(actual, expected, opts, channel2);
}
function isBuffer(x2) {
  if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
    return false;
  }
  if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
    return false;
  }
  if (x2.length > 0 && typeof x2[0] !== "number") {
    return false;
  }
  return !!(x2.constructor && x2.constructor.isBuffer && x2.constructor.isBuffer(x2));
}
function setEquiv(a, b, opts, channel2) {
  if ($setSize(a) !== $setSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set2;
  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === "object") {
      if (!set2) {
        set2 = new $Set();
      }
      $setAdd(set2, resultA.value);
    } else if (!$setHas(b, resultA.value)) {
      if (opts.strict) {
        return false;
      }
      if (!setMightHaveLoosePrim(a, b, resultA.value)) {
        return false;
      }
      if (!set2) {
        set2 = new $Set();
      }
      $setAdd(set2, resultA.value);
    }
  }
  if (set2) {
    while ((resultB = iB.next()) && !resultB.done) {
      if (resultB.value && typeof resultB.value === "object") {
        if (!setHasEqualElement(set2, resultB.value, opts.strict, channel2)) {
          return false;
        }
      } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set2, resultB.value, opts.strict, channel2)) {
        return false;
      }
    }
    return $setSize(set2) === 0;
  }
  return true;
}
function mapEquiv(a, b, opts, channel2) {
  if ($mapSize(a) !== $mapSize(b)) {
    return false;
  }
  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set2;
  var key;
  var item1;
  var item2;
  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];
    if (key && typeof key === "object") {
      if (!set2) {
        set2 = new $Set();
      }
      $setAdd(set2, key);
    } else {
      item2 = $mapGet(b, key);
      if (typeof item2 === "undefined" && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts, channel2)) {
        if (opts.strict) {
          return false;
        }
        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel2)) {
          return false;
        }
        if (!set2) {
          set2 = new $Set();
        }
        $setAdd(set2, key);
      }
    }
  }
  if (set2) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];
      if (key && typeof key === "object") {
        if (!mapHasEqualEntry(set2, a, key, item2, opts, channel2)) {
          return false;
        }
      } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel2)) && !mapHasEqualEntry(set2, a, key, item2, assign3({}, opts, { strict: false }), channel2)) {
        return false;
      }
    }
    return $setSize(set2) === 0;
  }
  return true;
}
function objEquiv(a, b, opts, channel2) {
  var i, key;
  if (typeof a !== typeof b) {
    return false;
  }
  if (a == null || b == null) {
    return false;
  }
  if ($objToString(a) !== $objToString(b)) {
    return false;
  }
  if (isArguments4(a) !== isArguments4(b)) {
    return false;
  }
  var aIsArray = isArray(a);
  var bIsArray = isArray(b);
  if (aIsArray !== bIsArray) {
    return false;
  }
  var aIsError = a instanceof Error;
  var bIsError = b instanceof Error;
  if (aIsError !== bIsError) {
    return false;
  }
  if (aIsError || bIsError) {
    if (a.name !== b.name || a.message !== b.message) {
      return false;
    }
  }
  var aIsRegex = isRegex3(a);
  var bIsRegex = isRegex3(b);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags2(a) !== flags2(b))) {
    return false;
  }
  var aIsDate = isDate(a);
  var bIsDate = isDate(b);
  if (aIsDate !== bIsDate) {
    return false;
  }
  if (aIsDate || bIsDate) {
    if ($getTime(a) !== $getTime(b)) {
      return false;
    }
  }
  if (opts.strict && gPO && gPO(a) !== gPO(b)) {
    return false;
  }
  var aWhich = whichTypedArray2(a);
  var bWhich = whichTypedArray2(b);
  if (aWhich !== bWhich) {
    return false;
  }
  if (aWhich || bWhich) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var aIsArrayBuffer = isArrayBuffer4(a);
  var bIsArrayBuffer = isArrayBuffer4(b);
  if (aIsArrayBuffer !== bIsArrayBuffer) {
    return false;
  }
  if (aIsArrayBuffer || bIsArrayBuffer) {
    if (byteLength2(a) !== byteLength2(b)) {
      return false;
    }
    return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel2);
  }
  var aIsSAB = isSharedArrayBuffer3(a);
  var bIsSAB = isSharedArrayBuffer3(b);
  if (aIsSAB !== bIsSAB) {
    return false;
  }
  if (aIsSAB || bIsSAB) {
    if (sabByteLength(a) !== sabByteLength(b)) {
      return false;
    }
    return typeof Uint8Array === "function" && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel2);
  }
  if (typeof a !== typeof b) {
    return false;
  }
  var ka2 = objectKeys(a);
  var kb2 = objectKeys(b);
  if (ka2.length !== kb2.length) {
    return false;
  }
  ka2.sort();
  kb2.sort();
  for (i = ka2.length - 1; i >= 0; i--) {
    if (ka2[i] != kb2[i]) {
      return false;
    }
  }
  for (i = ka2.length - 1; i >= 0; i--) {
    key = ka2[i];
    if (!internalDeepEqual(a[key], b[key], opts, channel2)) {
      return false;
    }
  }
  var aCollection = whichCollection2(a);
  var bCollection = whichCollection2(b);
  if (aCollection !== bCollection) {
    return false;
  }
  if (aCollection === "Set" || bCollection === "Set") {
    return setEquiv(a, b, opts, channel2);
  }
  if (aCollection === "Map") {
    return mapEquiv(a, b, opts, channel2);
  }
  return true;
}
var deepEqual = function deepEqual2(a, b, opts) {
  return internalDeepEqual(a, b, opts, getSideChannel2());
};
const equal = /* @__PURE__ */ getDefaultExportFromCjs(deepEqual);
var __defProp$d = Object.defineProperty;
var __name$d = (target, value) => __defProp$d(target, "name", { value, configurable: true });
var _GeojsonEquality = class _GeojsonEquality2 {
  constructor(opts) {
    this.direction = false;
    this.compareProperties = true;
    var _a, _b, _c;
    this.precision = 10 ** -((_a = opts == null ? void 0 : opts.precision) != null ? _a : 17);
    this.direction = (_b = opts == null ? void 0 : opts.direction) != null ? _b : false;
    this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;
  }
  compare(g1, g2) {
    if (g1.type !== g2.type) {
      return false;
    }
    if (!sameLength(g1, g2)) {
      return false;
    }
    switch (g1.type) {
      case "Point":
        return this.compareCoord(g1.coordinates, g2.coordinates);
      case "LineString":
        return this.compareLine(g1.coordinates, g2.coordinates);
      case "Polygon":
        return this.comparePolygon(g1, g2);
      case "GeometryCollection":
        return this.compareGeometryCollection(g1, g2);
      case "Feature":
        return this.compareFeature(g1, g2);
      case "FeatureCollection":
        return this.compareFeatureCollection(g1, g2);
      default:
        if (g1.type.startsWith("Multi")) {
          const g1s = explode$1(g1);
          const g2s = explode$1(
            g2
          );
          return g1s.every(
            (g1part) => g2s.some((g2part) => this.compare(g1part, g2part))
          );
        }
    }
    return false;
  }
  compareCoord(c1, c2) {
    return c1.length === c2.length && c1.every((c, i) => Math.abs(c - c2[i]) < this.precision);
  }
  compareLine(path1, path2, ind = 0, isPoly = false) {
    if (!sameLength(path1, path2)) {
      return false;
    }
    const p1 = path1;
    let p2 = path2;
    if (isPoly && !this.compareCoord(p1[0], p2[0])) {
      const startIndex = this.fixStartIndex(p2, p1);
      if (!startIndex) {
        return false;
      } else {
        p2 = startIndex;
      }
    }
    const sameDirection = this.compareCoord(p1[ind], p2[ind]);
    if (this.direction || sameDirection) {
      return this.comparePath(p1, p2);
    } else {
      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
        return this.comparePath(p1.slice().reverse(), p2);
      }
      return false;
    }
  }
  fixStartIndex(sourcePath, targetPath) {
    let correctPath, ind = -1;
    for (let i = 0; i < sourcePath.length; i++) {
      if (this.compareCoord(sourcePath[i], targetPath[0])) {
        ind = i;
        break;
      }
    }
    if (ind >= 0) {
      correctPath = [].concat(
        sourcePath.slice(ind, sourcePath.length),
        sourcePath.slice(1, ind + 1)
      );
    }
    return correctPath;
  }
  comparePath(p1, p2) {
    return p1.every((c, i) => this.compareCoord(c, p2[i]));
  }
  comparePolygon(g1, g2) {
    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);
      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);
      return holes1.every(
        (h1) => holes2.some((h2) => this.compareLine(h1, h2, 1, true))
      );
    }
    return false;
  }
  compareGeometryCollection(g1, g2) {
    return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g3, i) => this.compare(g3, g2.geometries[i]));
  }
  compareFeature(g1, g2) {
    return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);
  }
  compareFeatureCollection(g1, g2) {
    return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f2, i) => this.compare(f2, g2.features[i]));
  }
  compareBBox(g1, g2) {
    return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);
  }
};
__name$d(_GeojsonEquality, "GeojsonEquality");
function sameLength(g1, g2) {
  return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
}
__name$d(sameLength, "sameLength");
function explode$1(g2) {
  return g2.coordinates.map((part) => ({
    type: g2.type.replace("Multi", ""),
    coordinates: part
  }));
}
__name$d(explode$1, "explode");
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var areaFactors = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  nauticalmiles: 29155334959812285e-23,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function feature(geom, properties, options = {}) {
  const feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
__name$d(feature, "feature");
function geometry(type2, coordinates, _options = {}) {
  switch (type2) {
    case "Point":
      return point(coordinates).geometry;
    case "LineString":
      return lineString(coordinates).geometry;
    case "Polygon":
      return polygon(coordinates).geometry;
    case "MultiPoint":
      return multiPoint(coordinates).geometry;
    case "MultiLineString":
      return multiLineString(coordinates).geometry;
    case "MultiPolygon":
      return multiPolygon(coordinates).geometry;
    default:
      throw new Error(type2 + " is invalid");
  }
}
__name$d(geometry, "geometry");
function point(coordinates, properties, options = {}) {
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  const geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
__name$d(point, "point");
function points(coordinates, properties, options = {}) {
  return featureCollection(
    coordinates.map((coords) => {
      return point(coords, properties);
    }),
    options
  );
}
__name$d(points, "points");
function polygon(coordinates, properties, options = {}) {
  for (const ring of coordinates) {
    if (ring.length < 4) {
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    }
    if (ring[ring.length - 1].length !== ring[0].length) {
      throw new Error("First and last Position are not equivalent.");
    }
    for (let j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  const geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
__name$d(polygon, "polygon");
function polygons(coordinates, properties, options = {}) {
  return featureCollection(
    coordinates.map((coords) => {
      return polygon(coords, properties);
    }),
    options
  );
}
__name$d(polygons, "polygons");
function lineString(coordinates, properties, options = {}) {
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  const geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
__name$d(lineString, "lineString");
function lineStrings(coordinates, properties, options = {}) {
  return featureCollection(
    coordinates.map((coords) => {
      return lineString(coords, properties);
    }),
    options
  );
}
__name$d(lineStrings, "lineStrings");
function featureCollection(features, options = {}) {
  const fc2 = { type: "FeatureCollection" };
  if (options.id) {
    fc2.id = options.id;
  }
  if (options.bbox) {
    fc2.bbox = options.bbox;
  }
  fc2.features = features;
  return fc2;
}
__name$d(featureCollection, "featureCollection");
function multiLineString(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties, options);
}
__name$d(multiLineString, "multiLineString");
function multiPoint(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiPoint",
    coordinates
  };
  return feature(geom, properties, options);
}
__name$d(multiPoint, "multiPoint");
function multiPolygon(coordinates, properties, options = {}) {
  const geom = {
    type: "MultiPolygon",
    coordinates
  };
  return feature(geom, properties, options);
}
__name$d(multiPolygon, "multiPolygon");
function geometryCollection(geometries, properties, options = {}) {
  const geom = {
    type: "GeometryCollection",
    geometries
  };
  return feature(geom, properties, options);
}
__name$d(geometryCollection, "geometryCollection");
function round(num, precision = 0) {
  if (precision && !(precision >= 0)) {
    throw new Error("precision must be a positive number");
  }
  const multiplier = Math.pow(10, precision || 0);
  return Math.round(num * multiplier) / multiplier;
}
__name$d(round, "round");
function radiansToLength(radians, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
__name$d(radiansToLength, "radiansToLength");
function lengthToRadians(distance2, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
__name$d(lengthToRadians, "lengthToRadians");
function lengthToDegrees(distance2, units) {
  return radiansToDegrees(lengthToRadians(distance2, units));
}
__name$d(lengthToDegrees, "lengthToDegrees");
function bearingToAzimuth(bearing) {
  let angle = bearing % 360;
  if (angle < 0) {
    angle += 360;
  }
  return angle;
}
__name$d(bearingToAzimuth, "bearingToAzimuth");
function radiansToDegrees(radians) {
  const degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}
__name$d(radiansToDegrees, "radiansToDegrees");
function degreesToRadians(degrees) {
  const radians = degrees % 360;
  return radians * Math.PI / 180;
}
__name$d(degreesToRadians, "degreesToRadians");
function convertLength(length, originalUnit = "kilometers", finalUnit = "kilometers") {
  if (!(length >= 0)) {
    throw new Error("length must be a positive number");
  }
  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
__name$d(convertLength, "convertLength");
function convertArea(area, originalUnit = "meters", finalUnit = "kilometers") {
  if (!(area >= 0)) {
    throw new Error("area must be a positive number");
  }
  const startFactor = areaFactors[originalUnit];
  if (!startFactor) {
    throw new Error("invalid original units");
  }
  const finalFactor = areaFactors[finalUnit];
  if (!finalFactor) {
    throw new Error("invalid final units");
  }
  return area / startFactor * finalFactor;
}
__name$d(convertArea, "convertArea");
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
__name$d(isNumber, "isNumber");
function isObject(input) {
  return input !== null && typeof input === "object" && !Array.isArray(input);
}
__name$d(isObject, "isObject");
function validateBBox(bbox2) {
  if (!bbox2) {
    throw new Error("bbox is required");
  }
  if (!Array.isArray(bbox2)) {
    throw new Error("bbox must be an Array");
  }
  if (bbox2.length !== 4 && bbox2.length !== 6) {
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  }
  bbox2.forEach((num) => {
    if (!isNumber(num)) {
      throw new Error("bbox must only contain numbers");
    }
  });
}
__name$d(validateBBox, "validateBBox");
function validateId(id2) {
  if (!id2) {
    throw new Error("id is required");
  }
  if (["string", "number"].indexOf(typeof id2) === -1) {
    throw new Error("id must be a number or a string");
  }
}
__name$d(validateId, "validateId");
var __defProp$c = Object.defineProperty;
var __name$c = (target, value) => __defProp$c(target, "name", { value, configurable: true });
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
__name$c(getCoord, "getCoord");
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
__name$c(getCoords, "getCoords");
function containsNumber(coordinates) {
  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {
    return true;
  }
  if (Array.isArray(coordinates[0]) && coordinates[0].length) {
    return containsNumber(coordinates[0]);
  }
  throw new Error("coordinates must only contain numbers");
}
__name$c(containsNumber, "containsNumber");
function geojsonType(value, type2, name) {
  if (!type2 || !name) {
    throw new Error("type and name required");
  }
  if (!value || value.type !== type2) {
    throw new Error(
      "Invalid input to " + name + ": must be a " + type2 + ", given " + value.type
    );
  }
}
__name$c(geojsonType, "geojsonType");
function featureOf(feature2, type2, name) {
  if (!feature2) {
    throw new Error("No feature passed");
  }
  if (!name) {
    throw new Error(".featureOf() requires a name");
  }
  if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
    throw new Error(
      "Invalid input to " + name + ", Feature with geometry required"
    );
  }
  if (!feature2.geometry || feature2.geometry.type !== type2) {
    throw new Error(
      "Invalid input to " + name + ": must be a " + type2 + ", given " + feature2.geometry.type
    );
  }
}
__name$c(featureOf, "featureOf");
function collectionOf(featureCollection2, type2, name) {
  if (!featureCollection2) {
    throw new Error("No featureCollection passed");
  }
  if (!name) {
    throw new Error(".collectionOf() requires a name");
  }
  if (!featureCollection2 || featureCollection2.type !== "FeatureCollection") {
    throw new Error(
      "Invalid input to " + name + ", FeatureCollection required"
    );
  }
  for (const feature2 of featureCollection2.features) {
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error(
        "Invalid input to " + name + ", Feature with geometry required"
      );
    }
    if (!feature2.geometry || feature2.geometry.type !== type2) {
      throw new Error(
        "Invalid input to " + name + ": must be a " + type2 + ", given " + feature2.geometry.type
      );
    }
  }
}
__name$c(collectionOf, "collectionOf");
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
__name$c(getGeom, "getGeom");
function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }
  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }
  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }
  return geojson.type;
}
__name$c(getType, "getType");
var __defProp$b = Object.defineProperty;
var __name$b = (target, value) => __defProp$b(target, "name", { value, configurable: true });
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null)
    return;
  var j, k2, l2, geometry2, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type2 = geojson.type, isFeatureCollection = type2 === "FeatureCollection", isFeature = type2 === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry2 = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry2 === null)
        continue;
      coords = geometry2.coordinates;
      var geomType = geometry2.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint")
              multiFeatureIndex++;
          }
          if (geomType === "LineString")
            multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k2 = 0; k2 < coords[j].length - wrapShrink; k2++) {
              if (callback(
                coords[j][k2],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString")
              multiFeatureIndex++;
            if (geomType === "Polygon")
              geometryIndex++;
          }
          if (geomType === "Polygon")
            multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k2 = 0; k2 < coords[j].length; k2++) {
              for (l2 = 0; l2 < coords[j][k2].length - wrapShrink; l2++) {
                if (callback(
                  coords[j][k2][l2],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry2.geometries.length; j++)
            if (coordEach(geometry2.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
__name$b(coordEach, "coordEach");
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
      if (coordIndex === 0 && initialValue === void 0)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}
__name$b(coordReduce, "coordReduce");
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false)
          break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}
__name$b(propEach, "propEach");
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function(currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}
__name$b(propReduce, "propReduce");
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false)
        break;
    }
  }
}
__name$b(featureEach, "featureEach");
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function(currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === void 0)
      previousValue = currentFeature;
    else
      previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}
__name$b(featureReduce, "featureReduce");
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function(coord) {
    coords.push(coord);
  });
  return coords;
}
__name$b(coordAll, "coordAll");
function geomEach(geojson, callback) {
  var i, j, g2, geometry2, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g2 = 0; g2 < stopG; g2++) {
      geometry2 = isGeometryCollection ? geometryMaybeCollection.geometries[g2] : geometryMaybeCollection;
      if (geometry2 === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry2.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry2,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry2.geometries.length; j++) {
            if (callback(
              geometry2.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
__name$b(geomEach, "geomEach");
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        );
    }
  );
  return previousValue;
}
__name$b(geomReduce, "geomReduce");
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry2, featureIndex, properties, bbox2, id2) {
    var type2 = geometry2 === null ? null : geometry2.type;
    switch (type2) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry2, properties, { bbox: bbox2, id: id2 }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type2) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry2.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry2.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
__name$b(flattenEach, "flattenEach");
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function(currentFeature, featureIndex, multiFeatureIndex) {
      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}
__name$b(flattenReduce, "flattenReduce");
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry)
      return;
    var type2 = feature2.geometry.type;
    if (type2 === "Point" || type2 === "MultiPoint")
      return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
__name$b(segmentEach, "segmentEach");
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}
__name$b(segmentReduce, "segmentReduce");
function lineEach(geojson, callback) {
  if (!geojson)
    throw new Error("geojson is required");
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    if (feature2.geometry === null)
      return;
    var type2 = feature2.geometry.type;
    var coords = feature2.geometry.coordinates;
    switch (type2) {
      case "LineString":
        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
          if (callback(
            lineString(coords[geometryIndex], feature2.properties),
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
        }
        break;
    }
  });
}
__name$b(lineEach, "lineEach");
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}
__name$b(lineReduce, "lineReduce");
function findSegment(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0)
        segmentIndex = coords.length + segmentIndex - 1;
      return lineString(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return lineString(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}
__name$b(findSegment, "findSegment");
function findPoint(geojson, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;
  var properties = options.properties;
  var geometry2;
  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry2 = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry2 = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry2 = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (geometry2 === null)
    return null;
  var coords = geometry2.coordinates;
  switch (geometry2.type) {
    case "Point":
      return point(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return point(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0)
        coordIndex = coords.length + coordIndex;
      return point(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0)
        geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return point(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return point(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return point(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}
__name$b(findPoint, "findPoint");
function isPlainObject$1(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function isAction(action) {
  return isPlainObject$1(action) && "type" in action && typeof action.type === "string";
}
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
function die(error, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap2(value) || isSet2(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap2(thing) ? 2 : isSet2(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t2 = getArchtype(thing);
  if (t2 === 2)
    thing.set(propOrOldValue, value);
  else if (t2 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is2(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function isMap2(target) {
  return target instanceof Map;
}
function isSet2(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap2(base)) {
    return new Map(base);
  }
  if (isSet2(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys3 = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys3.length; i++) {
      const key = keys3[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result2, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result2 !== void 0 && result2 !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result2)) {
      result2 = finalize(scope, result2);
      if (!scope.parent_)
        maybeFreeze(scope, result2);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result2,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result2 = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result2 !== NOTHING ? result2 : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result2 = state.copy_;
    let resultEach = result2;
    let isSet22 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result2);
      result2.clear();
      isSet22 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result2, key, childValue, path, isSet22)
    );
    maybeFreeze(rootScope, result2, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray2 = Array.isArray(base);
  const state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray2) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is2(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result2;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result2 = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result2, scope);
      } else if (!base || typeof base !== "object") {
        result2 = recipe(base);
        if (result2 === void 0)
          result2 = base;
        if (result2 === NOTHING)
          result2 = void 0;
        if (this.autoFreeze_)
          freeze(result2, true);
        if (patchListener) {
          const p2 = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result2, p2, ip);
          patchListener(p2, ip);
        }
        return result2;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result2 = this.produce(base, recipe, (p2, ip) => {
        patches = p2;
        inversePatches = ip;
      });
      return [result2, patches, inversePatches];
    };
    if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap2(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet2(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer$1 = new Immer2();
var produce = immer$1.produce;
immer$1.produceWithPatches.bind(
  immer$1
);
immer$1.setAutoFreeze.bind(immer$1);
immer$1.setUseStrictShallowCopy.bind(immer$1);
immer$1.applyPatches.bind(immer$1);
immer$1.createDraft.bind(immer$1);
immer$1.finishDraft.bind(immer$1);
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a;
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l2 = length; i < l2; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result2;
    if (cacheNode.s === TERMINATED) {
      result2 = cacheNode.v;
    } else {
      result2 = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result2)) {
          result2 = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result2 === "object" && result2 !== null || typeof result2 === "function";
        lastResult = needsWeakRef ? new Ref(result2) : result2;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result2;
    return result2;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);
var createDraftSafeSelectorCreator = (...args) => {
  const createSelector2 = createSelectorCreator(...args);
  const createDraftSafeSelector2 = Object.assign((...args2) => {
    const selector = createSelector2(...args2);
    const wrappedSelector = (value, ...rest) => selector(isDraft(value) ? current(value) : value, ...rest);
    Object.assign(wrappedSelector, selector);
    return wrappedSelector;
  }, {
    withTypes: () => createDraftSafeSelector2
  });
  return createDraftSafeSelector2;
};
var createDraftSafeSelector = createDraftSafeSelectorCreator(weakMapMemoize);
function createAction(type2, prepareAction) {
  function actionCreator(...args) {
    return {
      type: type2,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type2}`;
  actionCreator.type = type2;
  actionCreator.match = (action) => isAction(action) && action.type === type2;
  return actionCreator;
}
function isFSA(action) {
  return isAction(action) && Object.keys(action).every(isValidKey);
}
function isValidKey(key) {
  return ["type", "payload", "error", "meta"].indexOf(key) > -1;
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
  let id2 = "";
  let i = size;
  while (i--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
function getInitialEntityState() {
  return {
    ids: [],
    entities: {}
  };
}
function createInitialStateFactory(stateAdapter) {
  function getInitialState(additionalState = {}, entities) {
    const state = Object.assign(getInitialEntityState(), additionalState);
    return entities ? stateAdapter.setAll(state, entities) : state;
  }
  return {
    getInitialState
  };
}
function createSelectorsFactory() {
  function getSelectors(selectState, options = {}) {
    const {
      createSelector: createSelector2 = createDraftSafeSelector
    } = options;
    const selectIds = (state) => state.ids;
    const selectEntities = (state) => state.entities;
    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id2) => entities[id2]));
    const selectId = (_, id2) => id2;
    const selectById = (entities, id2) => entities[id2];
    const selectTotal = createSelector2(selectIds, (ids) => ids.length);
    if (!selectState) {
      return {
        selectIds,
        selectEntities,
        selectAll,
        selectTotal,
        selectById: createSelector2(selectEntities, selectId, selectById)
      };
    }
    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);
    return {
      selectIds: createSelector2(selectState, selectIds),
      selectEntities: selectGlobalizedEntities,
      selectAll: createSelector2(selectState, selectAll),
      selectTotal: createSelector2(selectState, selectTotal),
      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)
    };
  }
  return {
    getSelectors
  };
}
var isDraftTyped = isDraft;
function createSingleArgumentStateOperator(mutator) {
  const operator = createStateOperator((_, state) => mutator(state));
  return function operation(state) {
    return operator(state, void 0);
  };
}
function createStateOperator(mutator) {
  return function operation(state, arg) {
    function isPayloadActionArgument(arg2) {
      return isFSA(arg2);
    }
    const runMutator = (draft) => {
      if (isPayloadActionArgument(arg)) {
        mutator(arg.payload, draft);
      } else {
        mutator(arg, draft);
      }
    };
    if (isDraftTyped(state)) {
      runMutator(state);
      return state;
    }
    return produce(state, runMutator);
  };
}
function selectIdValue(entity, selectId) {
  const key = selectId(entity);
  return key;
}
function ensureEntitiesArray(entities) {
  if (!Array.isArray(entities)) {
    entities = Object.values(entities);
  }
  return entities;
}
function getCurrent(value) {
  return isDraft(value) ? current(value) : value;
}
function splitAddedUpdatedEntities(newEntities, selectId, state) {
  newEntities = ensureEntitiesArray(newEntities);
  const existingIdsArray = getCurrent(state.ids);
  const existingIds = new Set(existingIdsArray);
  const added = [];
  const updated = [];
  for (const entity of newEntities) {
    const id2 = selectIdValue(entity, selectId);
    if (existingIds.has(id2)) {
      updated.push({
        id: id2,
        changes: entity
      });
    } else {
      added.push(entity);
    }
  }
  return [added, updated, existingIdsArray];
}
function createUnsortedStateAdapter(selectId) {
  function addOneMutably(entity, state) {
    const key = selectIdValue(entity, selectId);
    if (key in state.entities) {
      return;
    }
    state.ids.push(key);
    state.entities[key] = entity;
  }
  function addManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    for (const entity of newEntities) {
      addOneMutably(entity, state);
    }
  }
  function setOneMutably(entity, state) {
    const key = selectIdValue(entity, selectId);
    if (!(key in state.entities)) {
      state.ids.push(key);
    }
    state.entities[key] = entity;
  }
  function setManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    for (const entity of newEntities) {
      setOneMutably(entity, state);
    }
  }
  function setAllMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    state.ids = [];
    state.entities = {};
    addManyMutably(newEntities, state);
  }
  function removeOneMutably(key, state) {
    return removeManyMutably([key], state);
  }
  function removeManyMutably(keys3, state) {
    let didMutate = false;
    keys3.forEach((key) => {
      if (key in state.entities) {
        delete state.entities[key];
        didMutate = true;
      }
    });
    if (didMutate) {
      state.ids = state.ids.filter((id2) => id2 in state.entities);
    }
  }
  function removeAllMutably(state) {
    Object.assign(state, {
      ids: [],
      entities: {}
    });
  }
  function takeNewKey(keys3, update, state) {
    const original3 = state.entities[update.id];
    if (original3 === void 0) {
      return false;
    }
    const updated = Object.assign({}, original3, update.changes);
    const newKey = selectIdValue(updated, selectId);
    const hasNewKey = newKey !== update.id;
    if (hasNewKey) {
      keys3[update.id] = newKey;
      delete state.entities[update.id];
    }
    state.entities[newKey] = updated;
    return hasNewKey;
  }
  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }
  function updateManyMutably(updates, state) {
    const newKeys = {};
    const updatesPerEntity = {};
    updates.forEach((update) => {
      var _a;
      if (update.id in state.entities) {
        updatesPerEntity[update.id] = {
          id: update.id,
          // Spreads ignore falsy values, so this works even if there isn't
          // an existing update already at this key
          changes: {
            ...(_a = updatesPerEntity[update.id]) == null ? void 0 : _a.changes,
            ...update.changes
          }
        };
      }
    });
    updates = Object.values(updatesPerEntity);
    const didMutateEntities = updates.length > 0;
    if (didMutateEntities) {
      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;
      if (didMutateIds) {
        state.ids = Object.values(state.entities).map((e2) => selectIdValue(e2, selectId));
      }
    }
  }
  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }
  function upsertManyMutably(newEntities, state) {
    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }
  return {
    removeAll: createSingleArgumentStateOperator(removeAllMutably),
    addOne: createStateOperator(addOneMutably),
    addMany: createStateOperator(addManyMutably),
    setOne: createStateOperator(setOneMutably),
    setMany: createStateOperator(setManyMutably),
    setAll: createStateOperator(setAllMutably),
    updateOne: createStateOperator(updateOneMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    upsertMany: createStateOperator(upsertManyMutably),
    removeOne: createStateOperator(removeOneMutably),
    removeMany: createStateOperator(removeManyMutably)
  };
}
function findInsertIndex(sortedItems, item, comparisonFunction) {
  let lowIndex = 0;
  let highIndex = sortedItems.length;
  while (lowIndex < highIndex) {
    let middleIndex = lowIndex + highIndex >>> 1;
    const currentItem = sortedItems[middleIndex];
    const res = comparisonFunction(item, currentItem);
    if (res >= 0) {
      lowIndex = middleIndex + 1;
    } else {
      highIndex = middleIndex;
    }
  }
  return lowIndex;
}
function insert(sortedItems, item, comparisonFunction) {
  const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);
  sortedItems.splice(insertAtIndex, 0, item);
  return sortedItems;
}
function createSortedStateAdapter(selectId, comparer) {
  const {
    removeOne,
    removeMany,
    removeAll
  } = createUnsortedStateAdapter(selectId);
  function addOneMutably(entity, state) {
    return addManyMutably([entity], state);
  }
  function addManyMutably(newEntities, state, existingIds) {
    newEntities = ensureEntitiesArray(newEntities);
    const existingKeys = new Set(existingIds ?? getCurrent(state.ids));
    const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));
    if (models.length !== 0) {
      mergeFunction(state, models);
    }
  }
  function setOneMutably(entity, state) {
    return setManyMutably([entity], state);
  }
  function setManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    if (newEntities.length !== 0) {
      for (const item of newEntities) {
        delete state.entities[selectId(item)];
      }
      mergeFunction(state, newEntities);
    }
  }
  function setAllMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    state.entities = {};
    state.ids = [];
    addManyMutably(newEntities, state, []);
  }
  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }
  function updateManyMutably(updates, state) {
    let appliedUpdates = false;
    let replacedIds = false;
    for (let update of updates) {
      const entity = state.entities[update.id];
      if (!entity) {
        continue;
      }
      appliedUpdates = true;
      Object.assign(entity, update.changes);
      const newId = selectId(entity);
      if (update.id !== newId) {
        replacedIds = true;
        delete state.entities[update.id];
        const oldIndex = state.ids.indexOf(update.id);
        state.ids[oldIndex] = newId;
        state.entities[newId] = entity;
      }
    }
    if (appliedUpdates) {
      mergeFunction(state, [], appliedUpdates, replacedIds);
    }
  }
  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }
  function upsertManyMutably(newEntities, state) {
    const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);
    if (updated.length) {
      updateManyMutably(updated, state);
    }
    if (added.length) {
      addManyMutably(added, state, existingIdsArray);
    }
  }
  function areArraysEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] === b[i]) {
        continue;
      }
      return false;
    }
    return true;
  }
  const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {
    const currentEntities = getCurrent(state.entities);
    const currentIds = getCurrent(state.ids);
    const stateEntities = state.entities;
    let ids = currentIds;
    if (replacedIds) {
      ids = new Set(currentIds);
    }
    let sortedEntities = [];
    for (const id2 of ids) {
      const entity = currentEntities[id2];
      if (entity) {
        sortedEntities.push(entity);
      }
    }
    const wasPreviouslyEmpty = sortedEntities.length === 0;
    for (const item of addedItems) {
      stateEntities[selectId(item)] = item;
      if (!wasPreviouslyEmpty) {
        insert(sortedEntities, item, comparer);
      }
    }
    if (wasPreviouslyEmpty) {
      sortedEntities = addedItems.slice().sort(comparer);
    } else if (appliedUpdates) {
      sortedEntities.sort(comparer);
    }
    const newSortedIds = sortedEntities.map(selectId);
    if (!areArraysEqual(currentIds, newSortedIds)) {
      state.ids = newSortedIds;
    }
  };
  return {
    removeOne,
    removeMany,
    removeAll,
    addOne: createStateOperator(addOneMutably),
    updateOne: createStateOperator(updateOneMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    setOne: createStateOperator(setOneMutably),
    setMany: createStateOperator(setManyMutably),
    setAll: createStateOperator(setAllMutably),
    addMany: createStateOperator(addManyMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertMany: createStateOperator(upsertManyMutably)
  };
}
function createEntityAdapter(options = {}) {
  const {
    selectId,
    sortComparer
  } = {
    sortComparer: false,
    selectId: (instance) => instance.id,
    ...options
  };
  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
  const stateFactory = createInitialStateFactory(stateAdapter);
  const selectorsFactory = createSelectorsFactory();
  return {
    selectId,
    sortComparer,
    ...stateFactory,
    ...selectorsFactory,
    ...stateAdapter
  };
}
var assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new Error(formatProdErrorMessage(32));
  }
};
var alm = "listenerMiddleware";
var getListenerEntryPropsFrom = (options) => {
  let {
    type: type2,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options;
  if (type2) {
    predicate = createAction(type2).match;
  } else if (actionCreator) {
    type2 = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) ;
  else {
    throw new Error(formatProdErrorMessage(21));
  }
  assertFunction(effect);
  return {
    predicate,
    type: type2,
    effect
  };
};
var createListenerEntry = Object.assign((options) => {
  const {
    type: type2,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options);
  const id2 = nanoid();
  const entry = {
    id: id2,
    effect,
    type: type2,
    predicate,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(formatProdErrorMessage(22));
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
var addListener = Object.assign(createAction(`${alm}/add`), {
  withTypes: () => addListener
});
createAction(`${alm}/removeAll`);
var removeListener = Object.assign(createAction(`${alm}/remove`), {
  withTypes: () => removeListener
});
function formatProdErrorMessage(code) {
  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
}
var define_import_meta_env_default$1 = { BASE_URL: "/", MODE: "development", DEV: false, PROD: true, SSR: false };
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState2;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((define_import_meta_env_default$1 ? "development" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState2 = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e = reactExports;
function h$1(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var k$1 = "function" === typeof Object.is ? Object.is : h$1, l$3 = e.useState, m = e.useEffect, n$2 = e.useLayoutEffect, p$3 = e.useDebugValue;
function q$1(a, b) {
  var d = b(), f2 = l$3({ inst: { value: d, getSnapshot: b } }), c = f2[0].inst, g2 = f2[1];
  n$2(function() {
    c.value = d;
    c.getSnapshot = b;
    r$2(c) && g2({ inst: c });
  }, [a, d, b]);
  m(function() {
    r$2(c) && g2({ inst: c });
    return a(function() {
      r$2(c) && g2({ inst: c });
    });
  }, [a]);
  p$3(d);
  return d;
}
function r$2(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var d = b();
    return !k$1(a, d);
  } catch (f2) {
    return true;
  }
}
function t$3(a, b) {
  return b();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$3 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u$3;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h = reactExports, n$1 = shimExports;
function p$2(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var q = "function" === typeof Object.is ? Object.is : p$2, r$1 = n$1.useSyncExternalStore, t$2 = h.useRef, u$2 = h.useEffect, v$1 = h.useMemo, w$2 = h.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b, e2, l2, g2) {
  var c = t$2(null);
  if (null === c.current) {
    var f2 = { hasValue: false, value: null };
    c.current = f2;
  } else f2 = c.current;
  c = v$1(function() {
    function a2(a3) {
      if (!c2) {
        c2 = true;
        d2 = a3;
        a3 = l2(a3);
        if (void 0 !== g2 && f2.hasValue) {
          var b2 = f2.value;
          if (g2(b2, a3)) return k2 = b2;
        }
        return k2 = a3;
      }
      b2 = k2;
      if (q(d2, a3)) return b2;
      var e3 = l2(a3);
      if (void 0 !== g2 && g2(b2, e3)) return b2;
      d2 = a3;
      return k2 = e3;
    }
    var c2 = false, d2, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a2(b());
    }, null === m2 ? void 0 : function() {
      return a2(m2());
    }];
  }, [b, e2, l2, g2]);
  var d = r$1(a, c[0], c[1]);
  u$2(function() {
    f2.hasValue = true;
    f2.value = d;
  }, [d]);
  w$2(d);
  return d;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
var define_import_meta_env_default = { BASE_URL: "/", MODE: "development", DEV: false, PROD: true, SSR: false };
const { useDebugValue } = ReactExports;
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = false;
const identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if ((define_import_meta_env_default ? "development" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice2 = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice2);
  return slice2;
}
const immerImpl = (initializer) => (set2, get, store) => {
  store.setState = (updater, replace, ...a) => {
    const nextState = typeof updater === "function" ? produce(updater) : updater;
    return set2(nextState, replace, ...a);
  };
  return initializer(store.setState, get, store);
};
const immer = immerImpl;
function useFirstMountState() {
  var isFirst = reactExports.useRef(true);
  if (isFirst.current) {
    isFirst.current = false;
    return true;
  }
  return isFirst.current;
}
var useUpdateEffect = function(effect, deps) {
  var isFirstMount = useFirstMountState();
  reactExports.useEffect(function() {
    if (!isFirstMount) {
      return effect();
    }
  }, deps);
};
var __defProp$a = Object.defineProperty;
var __name$a = (target, value) => __defProp$a(target, "name", { value, configurable: true });
function destination(origin, distance2, bearing, options = {}) {
  const coordinates1 = getCoord(origin);
  const longitude1 = degreesToRadians(coordinates1[0]);
  const latitude1 = degreesToRadians(coordinates1[1]);
  const bearingRad = degreesToRadians(bearing);
  const radians = lengthToRadians(distance2, options.units);
  const latitude2 = Math.asin(
    Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)
  );
  const longitude2 = longitude1 + Math.atan2(
    Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),
    Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2)
  );
  const lng = radiansToDegrees(longitude2);
  const lat = radiansToDegrees(latitude2);
  return point([lng, lat], options.properties);
}
__name$a(destination, "destination");
var __defProp$9 = Object.defineProperty;
var __name$9 = (target, value) => __defProp$9(target, "name", { value, configurable: true });
function circle(center2, radius, options = {}) {
  const steps = options.steps || 64;
  const properties = options.properties ? options.properties : !Array.isArray(center2) && center2.type === "Feature" && center2.properties ? center2.properties : {};
  const coordinates = [];
  for (let i = 0; i < steps; i++) {
    coordinates.push(
      destination(center2, radius, i * -360 / steps, options).geometry.coordinates
    );
  }
  coordinates.push(coordinates[0]);
  return polygon([coordinates], properties);
}
__name$9(circle, "circle");
var __defProp$8 = Object.defineProperty;
var __name$8 = (target, value) => __defProp$8(target, "name", { value, configurable: true });
function explode(geojson) {
  const points2 = [];
  if (geojson.type === "FeatureCollection") {
    featureEach(geojson, function(feature2) {
      coordEach(feature2, function(coord) {
        points2.push(point(coord, feature2.properties));
      });
    });
  } else if (geojson.type === "Feature") {
    coordEach(geojson, function(coord) {
      points2.push(point(coord, geojson.properties));
    });
  } else {
    coordEach(geojson, function(coord) {
      points2.push(point(coord));
    });
  }
  return featureCollection(points2);
}
__name$8(explode, "explode");
var __defProp$7 = Object.defineProperty;
var __name$7 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
function bbox(geojson, options = {}) {
  if (geojson.bbox != null && true !== options.recompute) {
    return geojson.bbox;
  }
  const result2 = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, (coord) => {
    if (result2[0] > coord[0]) {
      result2[0] = coord[0];
    }
    if (result2[1] > coord[1]) {
      result2[1] = coord[1];
    }
    if (result2[2] < coord[0]) {
      result2[2] = coord[0];
    }
    if (result2[3] < coord[1]) {
      result2[3] = coord[1];
    }
  });
  return result2;
}
__name$7(bbox, "bbox");
var __defProp$6 = Object.defineProperty;
var __name$6 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
function center(geojson, options = {}) {
  const ext = bbox(geojson);
  const x2 = (ext[0] + ext[2]) / 2;
  const y2 = (ext[1] + ext[3]) / 2;
  return point([x2, y2], options.properties, options);
}
__name$6(center, "center");
var turf_center_default = center;
var __defProp$5 = Object.defineProperty;
var __name$5 = (target, value) => __defProp$5(target, "name", { value, configurable: true });
function clone(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
__name$5(clone, "clone");
function cloneFeature(geojson) {
  const cloned = { type: "Feature" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  if (geojson.geometry == null) {
    cloned.geometry = null;
  } else {
    cloned.geometry = cloneGeometry(geojson.geometry);
  }
  return cloned;
}
__name$5(cloneFeature, "cloneFeature");
function cloneProperties(properties) {
  const cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach((key) => {
    const value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map((item) => {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
__name$5(cloneProperties, "cloneProperties");
function cloneFeatureCollection(geojson) {
  const cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach((key) => {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map((feature2) => {
    return cloneFeature(feature2);
  });
  return cloned;
}
__name$5(cloneFeatureCollection, "cloneFeatureCollection");
function cloneGeometry(geometry2) {
  const geom = { type: geometry2.type };
  if (geometry2.bbox) {
    geom.bbox = geometry2.bbox;
  }
  if (geometry2.type === "GeometryCollection") {
    geom.geometries = geometry2.geometries.map((g2) => {
      return cloneGeometry(g2);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry2.coordinates);
  return geom;
}
__name$5(cloneGeometry, "cloneGeometry");
function deepSlice(coords) {
  const cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map((coord) => {
    return deepSlice(coord);
  });
}
__name$5(deepSlice, "deepSlice");
var __defProp$4 = Object.defineProperty;
var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
function distance(from, to, options = {}) {
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(
    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    options.units
  );
}
__name$4(distance, "distance");
var __defProp$3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
function nearestPoint(targetPoint, points2, options = {}) {
  if (!targetPoint)
    throw new Error("targetPoint is required");
  if (!points2)
    throw new Error("points is required");
  let minDist = Infinity;
  let bestFeatureIndex = 0;
  featureEach(points2, (pt, featureIndex) => {
    const distanceToPoint = distance(targetPoint, pt, options);
    if (distanceToPoint < minDist) {
      bestFeatureIndex = featureIndex;
      minDist = distanceToPoint;
    }
  });
  const nearestPoint2 = clone(points2.features[bestFeatureIndex]);
  return __spreadProps(__spreadValues({}, nearestPoint2), {
    properties: __spreadProps(__spreadValues({}, nearestPoint2.properties), {
      featureIndex: bestFeatureIndex,
      distanceToPoint: minDist
    })
  });
}
__name$3(nearestPoint, "nearestPoint");
function pointInPolygon(p2, polygon2) {
  var i = 0;
  var ii2 = 0;
  var k2 = 0;
  var f2 = 0;
  var u1 = 0;
  var v1 = 0;
  var u2 = 0;
  var v2 = 0;
  var currentP = null;
  var nextP = null;
  var x2 = p2[0];
  var y2 = p2[1];
  var numContours = polygon2.length;
  for (i; i < numContours; i++) {
    ii2 = 0;
    var contourLen = polygon2[i].length - 1;
    var contour = polygon2[i];
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x2;
    v1 = currentP[1] - y2;
    for (ii2; ii2 < contourLen; ii2++) {
      nextP = contour[ii2 + 1];
      v2 = nextP[1] - y2;
      if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
        currentP = nextP;
        v1 = v2;
        u1 = currentP[0] - x2;
        continue;
      }
      u2 = nextP[0] - p2[0];
      if (v2 > 0 && v1 <= 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 > 0) {
          k2 = k2 + 1;
        } else if (f2 === 0) {
          return 0;
        }
      } else if (v1 > 0 && v2 <= 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 < 0) {
          k2 = k2 + 1;
        } else if (f2 === 0) {
          return 0;
        }
      } else if (v2 === 0 && v1 < 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 === 0) {
          return 0;
        }
      } else if (v1 === 0 && v2 < 0) {
        f2 = u1 * v2 - u2 * v1;
        if (f2 === 0) {
          return 0;
        }
      } else if (v1 === 0 && v2 === 0) {
        if (u2 <= 0 && u1 >= 0) {
          return 0;
        } else if (u1 <= 0 && u2 >= 0) {
          return 0;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u2;
    }
  }
  if (k2 % 2 === 0) {
    return false;
  }
  return true;
}
var __defProp$2 = Object.defineProperty;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
function booleanPointInPolygon(point2, polygon2, options = {}) {
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon2) {
    throw new Error("polygon is required");
  }
  const pt = getCoord(point2);
  const geom = getGeom(polygon2);
  const type2 = geom.type;
  const bbox2 = polygon2.bbox;
  let polys = geom.coordinates;
  if (bbox2 && inBBox(pt, bbox2) === false) {
    return false;
  }
  if (type2 === "Polygon") {
    polys = [polys];
  }
  let result2 = false;
  for (var i = 0; i < polys.length; ++i) {
    const polyResult = pointInPolygon(pt, polys[i]);
    if (polyResult === 0)
      return options.ignoreBoundary ? false : true;
    else if (polyResult)
      result2 = true;
  }
  return result2;
}
__name$2(booleanPointInPolygon, "booleanPointInPolygon");
function inBBox(pt, bbox2) {
  return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
}
__name$2(inBBox, "inBBox");
var __defProp$1 = Object.defineProperty;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
function pointOnFeature(geojson) {
  const fc2 = normalize(geojson);
  const cent = center(fc2);
  let onSurface = false;
  let i = 0;
  while (!onSurface && i < fc2.features.length) {
    const geom = fc2.features[i].geometry;
    let x2, y2, x1, y1, x22, y22;
    let onLine = false;
    if (geom.type === "Point") {
      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
        onSurface = true;
      }
    } else if (geom.type === "MultiPoint") {
      let onMultiPoint = false;
      let k2 = 0;
      while (!onMultiPoint && k2 < geom.coordinates.length) {
        if (cent.geometry.coordinates[0] === geom.coordinates[k2][0] && cent.geometry.coordinates[1] === geom.coordinates[k2][1]) {
          onSurface = true;
          onMultiPoint = true;
        }
        k2++;
      }
    } else if (geom.type === "LineString") {
      let k2 = 0;
      while (!onLine && k2 < geom.coordinates.length - 1) {
        x2 = cent.geometry.coordinates[0];
        y2 = cent.geometry.coordinates[1];
        x1 = geom.coordinates[k2][0];
        y1 = geom.coordinates[k2][1];
        x22 = geom.coordinates[k2 + 1][0];
        y22 = geom.coordinates[k2 + 1][1];
        if (pointOnSegment(x2, y2, x1, y1, x22, y22)) {
          onLine = true;
          onSurface = true;
        }
        k2++;
      }
    } else if (geom.type === "MultiLineString") {
      let j = 0;
      while (j < geom.coordinates.length) {
        onLine = false;
        let k2 = 0;
        const line = geom.coordinates[j];
        while (!onLine && k2 < line.length - 1) {
          x2 = cent.geometry.coordinates[0];
          y2 = cent.geometry.coordinates[1];
          x1 = line[k2][0];
          y1 = line[k2][1];
          x22 = line[k2 + 1][0];
          y22 = line[k2 + 1][1];
          if (pointOnSegment(x2, y2, x1, y1, x22, y22)) {
            onLine = true;
            onSurface = true;
          }
          k2++;
        }
        j++;
      }
    } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
      if (booleanPointInPolygon(cent, geom)) {
        onSurface = true;
      }
    }
    i++;
  }
  if (onSurface) {
    return cent;
  } else {
    const vertices = featureCollection([]);
    for (let f2 = 0; f2 < fc2.features.length; f2++) {
      vertices.features = vertices.features.concat(
        explode(fc2.features[f2]).features
      );
    }
    return point(nearestPoint(cent, vertices).geometry.coordinates);
  }
}
__name$1(pointOnFeature, "pointOnFeature");
function normalize(geojson) {
  if (geojson.type !== "FeatureCollection") {
    if (geojson.type !== "Feature") {
      return featureCollection([feature(geojson)]);
    }
    return featureCollection([geojson]);
  }
  return geojson;
}
__name$1(normalize, "normalize");
function pointOnSegment(x2, y2, x1, y1, x22, y22) {
  const ab2 = Math.sqrt((x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1));
  const ap = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  const pb2 = Math.sqrt((x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2));
  return ab2 === ap + pb2;
}
__name$1(pointOnSegment, "pointOnSegment");
var geojsonValidation = {};
(function(exports) {
  const definitions = {};
  function isFunction2(object) {
    return typeof object === "function";
  }
  function isObject2(object) {
    return object === Object(object);
  }
  function _done(trace, message) {
    let valid = false;
    if (typeof message === "string") {
      message = [message];
    } else if (Object.prototype.toString.call(message) === "[object Array]") {
      if (message.length === 0) {
        valid = true;
      }
    } else {
      valid = true;
    }
    if (trace) {
      return message;
    } else {
      return valid;
    }
  }
  function _customDefinitions(type2, object) {
    let errors;
    if (isFunction2(definitions[type2])) {
      try {
        errors = definitions[type2](object);
      } catch (e2) {
        errors = ["Problem with custom definition for " + type2 + ": " + e2];
      }
      if (typeof result === "string") {
        errors = [errors];
      }
      if (Object.prototype.toString.call(errors) === "[object Array]") {
        return errors;
      }
    }
    return [];
  }
  exports.define = (type2, definition) => {
    if (type2 in allTypes && isFunction2(definition)) {
      definitions[type2] = definition;
      return true;
    } else {
      return false;
    }
  };
  exports.isPosition = (position, trace = false) => {
    let errors = [];
    if (Array.isArray(position)) {
      if (position.length <= 1) {
        errors.push("Position must be at least two elements");
      }
      position.forEach((pos, index) => {
        if (typeof pos !== "number") {
          errors.push("Position must only contain numbers. Item " + pos + " at index " + index + " is invalid.");
        }
      });
    } else {
      errors.push("Position must be an array");
    }
    errors = errors.concat(_customDefinitions("Position", position));
    return _done(trace, errors);
  };
  exports.isGeoJSONObject = exports.valid = (geoJSONObject, trace = false) => {
    if (!isObject2(geoJSONObject)) {
      return _done(trace, ["must be a JSON Object"]);
    } else {
      let errors = [];
      if ("type" in geoJSONObject) {
        if (nonGeoTypes[geoJSONObject.type]) {
          return nonGeoTypes[geoJSONObject.type](geoJSONObject, trace);
        } else if (geoTypes[geoJSONObject.type]) {
          return geoTypes[geoJSONObject.type](geoJSONObject, trace);
        } else {
          errors.push('type must be one of: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection", "Feature", or "FeatureCollection"');
        }
      } else {
        errors.push('must have a member with the name "type"');
      }
      errors = errors.concat(_customDefinitions("GeoJSONObject", geoJSONObject));
      return _done(trace, errors);
    }
  };
  exports.isGeometryObject = (geometryObject, trace = false) => {
    if (!isObject2(geometryObject)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("type" in geometryObject) {
      if (geoTypes[geometryObject.type]) {
        return geoTypes[geometryObject.type](geometryObject, trace);
      } else {
        errors.push('type must be one of: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon" or "GeometryCollection"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    errors = errors.concat(_customDefinitions("GeometryObject", geometryObject));
    return _done(trace, errors);
  };
  exports.isPoint = (point2, trace = false) => {
    if (!isObject2(point2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in point2) {
      const t2 = exports.isBbox(point2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in point2) {
      if (point2.type !== "Point") {
        errors.push('type must be "Point"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("coordinates" in point2) {
      const t2 = exports.isPosition(point2.coordinates, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    } else {
      errors.push('must have a member with the name "coordinates"');
    }
    errors = errors.concat(_customDefinitions("Point", point2));
    return _done(trace, errors);
  };
  exports.isMultiPointCoor = (coordinates, trace = false) => {
    let errors = [];
    if (Array.isArray(coordinates)) {
      coordinates.forEach((val, index) => {
        const t2 = exports.isPosition(val, true);
        if (t2.length) {
          t2[0] = "at " + index + ": ".concat(t2[0]);
          errors = errors.concat(t2);
        }
      });
    } else {
      errors.push("coordinates must be an array");
    }
    return _done(trace, errors);
  };
  exports.isMultiPoint = (multiPoint2, trace = false) => {
    if (!isObject2(multiPoint2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in multiPoint2) {
      const t2 = exports.isBbox(multiPoint2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in multiPoint2) {
      if (multiPoint2.type !== "MultiPoint") {
        errors.push('type must be "MultiPoint"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("coordinates" in multiPoint2) {
      const t2 = exports.isMultiPointCoor(multiPoint2.coordinates, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    } else {
      errors.push('must have a member with the name "coordinates"');
    }
    errors = errors.concat(_customDefinitions("MultiPoint", multiPoint2));
    return _done(trace, errors);
  };
  exports.isLineStringCoor = (coordinates, trace = false) => {
    let errors = [];
    if (Array.isArray(coordinates)) {
      if (coordinates.length > 1) {
        coordinates.forEach((val, index) => {
          const t2 = exports.isPosition(val, true);
          if (t2.length) {
            t2[0] = "at " + index + ": ".concat(t2[0]);
            errors = errors.concat(t2);
          }
        });
      } else {
        errors.push("coordinates must have at least two elements");
      }
    } else {
      errors.push("coordinates must be an array");
    }
    return _done(trace, errors);
  };
  exports.isLineString = (lineString2, trace = false) => {
    if (!isObject2(lineString2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in lineString2) {
      const t2 = exports.isBbox(lineString2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in lineString2) {
      if (lineString2.type !== "LineString") {
        errors.push('type must be "LineString"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("coordinates" in lineString2) {
      const t2 = exports.isLineStringCoor(lineString2.coordinates, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    } else {
      errors.push('must have a member with the name "coordinates"');
    }
    errors = errors.concat(_customDefinitions("LineString", lineString2));
    return _done(trace, errors);
  };
  exports.isMultiLineStringCoor = (coordinates, trace = false) => {
    let errors = [];
    if (Array.isArray(coordinates)) {
      coordinates.forEach((val, index) => {
        const t2 = exports.isLineStringCoor(val, true);
        if (t2.length) {
          t2[0] = "at " + index + ": ".concat(t2[0]);
          errors = errors.concat(t2);
        }
      });
    } else {
      errors.push("coordinates must be an array");
    }
    return _done(trace, errors);
  };
  exports.isMultiLineString = (multilineString, trace = false) => {
    if (!isObject2(multilineString)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in multilineString) {
      const t2 = exports.isBbox(multilineString.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in multilineString) {
      if (multilineString.type !== "MultiLineString") {
        errors.push('type must be "MultiLineString"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("coordinates" in multilineString) {
      const t2 = exports.isMultiLineStringCoor(multilineString.coordinates, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    } else {
      errors.push('must have a member with the name "coordinates"');
    }
    errors = errors.concat(_customDefinitions("MultiPoint", multilineString));
    return _done(trace, errors);
  };
  function _linearRingCoor(coordinates, trace) {
    let errors = [];
    if (Array.isArray(coordinates)) {
      coordinates.forEach((val, index) => {
        const t2 = exports.isPosition(val, true);
        if (t2.length) {
          t2[0] = "at " + index + ": ".concat(t2[0]);
          errors = errors.concat(t2);
        }
      });
      if (coordinates[0].toString() !== coordinates[coordinates.length - 1].toString()) {
        errors.push("The first and last positions must be equivalent");
      }
      if (coordinates.length < 4) {
        errors.push("coordinates must have at least four positions");
      }
    } else {
      errors.push("coordinates must be an array");
    }
    return _done(trace, errors);
  }
  exports.isPolygonCoor = (coordinates, trace = false) => {
    let errors = [];
    if (Array.isArray(coordinates)) {
      coordinates.forEach((val, index) => {
        const t2 = _linearRingCoor(val, true);
        if (t2.length) {
          t2[0] = "at " + index + ": ".concat(t2[0]);
          errors = errors.concat(t2);
        }
      });
    } else {
      errors.push("coordinates must be an array");
    }
    return _done(trace, errors);
  };
  exports.isPolygon = (polygon2, trace = false) => {
    if (!isObject2(polygon2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in polygon2) {
      const t2 = exports.isBbox(polygon2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in polygon2) {
      if (polygon2.type !== "Polygon") {
        errors.push('type must be "Polygon"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("coordinates" in polygon2) {
      const t2 = exports.isPolygonCoor(polygon2.coordinates, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    } else {
      errors.push('must have a member with the name "coordinates"');
    }
    errors = errors.concat(_customDefinitions("Polygon", polygon2));
    return _done(trace, errors);
  };
  exports.isMultiPolygonCoor = (coordinates, trace = false) => {
    let errors = [];
    if (Array.isArray(coordinates)) {
      coordinates.forEach((val, index) => {
        const t2 = exports.isPolygonCoor(val, true);
        if (t2.length) {
          t2[0] = "at " + index + ": ".concat(t2[0]);
          errors = errors.concat(t2);
        }
      });
    } else {
      errors.push("coordinates must be an array");
    }
    return _done(trace, errors);
  };
  exports.isMultiPolygon = (multiPolygon2, trace = false) => {
    if (!isObject2(multiPolygon2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in multiPolygon2) {
      const t2 = exports.isBbox(multiPolygon2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in multiPolygon2) {
      if (multiPolygon2.type !== "MultiPolygon") {
        errors.push('type must be "MultiPolygon"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("coordinates" in multiPolygon2) {
      const t2 = exports.isMultiPolygonCoor(multiPolygon2.coordinates, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    } else {
      errors.push('must have a member with the name "coordinates"');
    }
    errors = errors.concat(_customDefinitions("MultiPolygon", multiPolygon2));
    return _done(trace, errors);
  };
  exports.isGeometryCollection = (geometryCollection2, trace = false) => {
    if (!isObject2(geometryCollection2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in geometryCollection2) {
      const t2 = exports.isBbox(geometryCollection2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in geometryCollection2) {
      if (geometryCollection2.type !== "GeometryCollection") {
        errors.push('type must be "GeometryCollection"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("geometries" in geometryCollection2) {
      if (Array.isArray(geometryCollection2.geometries)) {
        geometryCollection2.geometries.forEach((val, index) => {
          const t2 = exports.isGeometryObject(val, true);
          if (t2.length) {
            t2[0] = "at " + index + ": ".concat(t2[0]);
            errors = errors.concat(t2);
          }
        });
      } else {
        errors.push('"geometries" must be an array');
      }
    } else {
      errors.push('must have a member with the name "geometries"');
    }
    errors = errors.concat(_customDefinitions("GeometryCollection", geometryCollection2));
    return _done(trace, errors);
  };
  exports.isFeature = (feature2, trace = false) => {
    if (!isObject2(feature2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in feature2) {
      const t2 = exports.isBbox(feature2.bbox, true);
      if (t2.length) {
        errors = errors.concat(t2);
      }
    }
    if ("type" in feature2) {
      if (feature2.type !== "Feature") {
        errors.push('type must be "Feature"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if (!("properties" in feature2)) {
      errors.push('must have a member with the name "properties"');
    }
    if ("geometry" in feature2) {
      if (feature2.geometry !== null) {
        const t2 = exports.isGeometryObject(feature2.geometry, true);
        if (t2.length) {
          errors = errors.concat(t2);
        }
      }
    } else {
      errors.push('must have a member with the name "geometry"');
    }
    errors = errors.concat(_customDefinitions("Feature", feature2));
    return _done(trace, errors);
  };
  exports.isFeatureCollection = (featureCollection2, trace = false) => {
    if (!isObject2(featureCollection2)) {
      return _done(trace, ["must be a JSON Object"]);
    }
    let errors = [];
    if ("bbox" in featureCollection2) {
      const t2 = exports.isBbox(featureCollection2.bbox, true);
      if (t2.length) {
        errors = t2;
      }
    }
    if ("type" in featureCollection2) {
      if (featureCollection2.type !== "FeatureCollection") {
        errors.push('type must be "FeatureCollection"');
      }
    } else {
      errors.push('must have a member with the name "type"');
    }
    if ("features" in featureCollection2) {
      if (Array.isArray(featureCollection2.features)) {
        featureCollection2.features.forEach((val, index) => {
          const t2 = exports.isFeature(val, true);
          if (t2.length) {
            t2[0] = "at " + index + ": ".concat(t2[0]);
            errors = errors.concat(t2);
          }
        });
      } else {
        errors.push('"Features" must be an array');
      }
    } else {
      errors.push('must have a member with the name "Features"');
    }
    errors = errors.concat(_customDefinitions("FeatureCollection", featureCollection2));
    return _done(trace, errors);
  };
  exports.isBbox = (bbox2, trace = false) => {
    let errors = [];
    if (Array.isArray(bbox2)) {
      if (bbox2.length % 2 !== 0) {
        errors.push("bbox, must be a 2*n array");
      }
    } else {
      errors.push("bbox must be an array");
    }
    errors = errors.concat(_customDefinitions("Bbox", bbox2));
    return _done(trace, errors);
  };
  const nonGeoTypes = {
    "Feature": exports.isFeature,
    "FeatureCollection": exports.isFeatureCollection
  };
  const geoTypes = {
    "Point": exports.isPoint,
    "MultiPoint": exports.isMultiPoint,
    "LineString": exports.isLineString,
    "MultiLineString": exports.isMultiLineString,
    "Polygon": exports.isPolygon,
    "MultiPolygon": exports.isMultiPolygon,
    "GeometryCollection": exports.isGeometryCollection
  };
  const allTypes = {
    "Feature": exports.isFeature,
    "FeatureCollection": exports.isFeatureCollection,
    "Point": exports.isPoint,
    "MultiPoint": exports.isMultiPoint,
    "LineString": exports.isLineString,
    "MultiLineString": exports.isMultiLineString,
    "Polygon": exports.isPolygon,
    "MultiPolygon": exports.isMultiPolygon,
    "GeometryCollection": exports.isGeometryCollection,
    "Bbox": exports.isBbox,
    "Position": exports.isPosition,
    "GeoJSON": exports.isGeoJSONObject,
    "GeometryObject": exports.isGeometryObject
  };
  exports.allTypes = allTypes;
})(geojsonValidation);
const MarkerIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=";
const MarkerIcon2x = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAMAAAAhFXfZAAAC91BMVEVMaXEzeak2f7I4g7g3g7cua5gzeKg8hJo3grY4g7c3grU0gLI2frE0daAubJc2gbQwd6QzeKk2gLMtd5sxdKIua5g1frA2f7IydaM0e6w2fq41fK01eqo3grgubJgta5cxdKI1f7AydaQydaMxc6EubJgvbJkwcZ4ubZkwcJwubZgubJcydqUydKIxapgubJctbJcubZcubJcvbJYubJcvbZkubJctbJctbZcubJg2f7AubJcrbZcubJcubJcua5g3grY0fq8ubJcubJdEkdEwhsw6i88vhswuhcsuhMtBjMgthMsrg8srgss6is8qgcs8i9A9iMYtg8spgcoogMo7hcMngMonf8olfso4gr8kfck5iM8jfMk4iM8he8k1fro7itAgesk2hs8eecgzfLcofssdeMg0hc4cd8g2hcsxeLQbdsgZdcgxeLImfcszhM0vda4xgckzhM4xg84wf8Yxgs4udKsvfcQucqhUndROmdM1fK0wcZ8vb5w0eqpQm9MzeKhXoNVcpdYydKNWn9VZotVKltJFjsIwcJ1Rms9OlslLmtH///8+kc9epdYzd6dbo9VHkMM2f7FHmNBClM8ydqVcpNY9hro3gLM9hLczealQmcw3fa46f7A8gLMxc6I3eagyc6FIldJMl9JSnNRSntNNl9JPnNJFi75UnM9ZodVKksg8kM45jc09e6ZHltFBk883gbRBh7pDk9EwcaBzn784g7dKkcY2i81Om9M7j85Llc81is09g7Q4grY/j9A0eqxKmdFFltBEjcXf6fFImdBCiLxJl9FGlNFBi78yiMxVndEvbpo6js74+vx+psPP3+o/ks5HkcpGmNCjwdZCkNDM3ehYoNJEls+lxNkxh8xHks0+jdC1zd5Lg6r+/v/H2ufz9/o3jM3t8/edvdM/k89Th61OiLBSjbZklbaTt9BfptdjmL1AicBHj8hGk9FAgK1dkLNTjLRekrdClc/k7fM0icy0y9tgp9c4jc2NtM9Dlc8zicxeXZn3AAAAQ3RSTlMAHDdTb4yPA+LtnEQmC4L2EmHqB7XA0d0sr478x4/Yd5i1zOfyPkf1sLVq4Nh3FvjxopQ2/STNuFzUwFIwxKaejILpIBEV9wAABhVJREFUeF6s1NdyFEcYBeBeoQIhRAkLlRDGrhIgY3BJL8CVeKzuyXFzzjkn5ZxzzuScg3PO8cKzu70JkO0LfxdTU//pM9vTu7Xgf6KqOVTb9X7toRrVEfBf1HTVjZccrT/2by1VV928Yty9ZbVuucdz90frG8DBjl9pVApbOstvmMuvVgaNXSfAAd6pGxpy6yxf5ph43pS/4f3uoaGm2rdu72S9xzOvMymkZFq/ptDrk90mhW7e4zl7HLzhxGWPR20xmSxJ/VqldG5m9XhaVOA1DadsNh3Pu5L2N6QtPO/32JpqQBVVk20oy/Pi2s23WEvyfHbe1thadVQttvm7Llf65gGmXK67XtupyoM7HQhmXdLS8oGWJNeOJ3C5fG5XCEJnkez3/oFdsvgJ4l2ANZwhrJKk/7OSXa+3Vw2WJMlKnGkobouYk6T0TyX30klOUnTD9HJ5qpckL3EW/w4XF3Xd0FGywXUrstrclVsqz5Pd/sXFYyDnPdrLcQODmGOK47IZb4CmibmMn+MYRzFZ5jg33ZL/EJrWcszHmANy3ARBK/IXtciJy8VsitPSdE3uuHxzougojcUdr8/32atnz/ev3f/K5wtpxUTpcaI45zusVDpYtZi+jg0oU9b3x74h7+n9ABvYEZeKaVq0sh0AtLKsFtqNBdeT0MrSzwwlq9+x6xAO4tgOtSzbCjrNQQiNvQUbUEubvzBUeGw26yDCsRHCoLkTHDa7IdOLIThs/gHvChszh2CimE8peRs47cxANI0lYNB5y1DljpOF0IhzBDPOZnDOqYYbeGKECbPzWnXludPphw5c2YBq5zlwXphIbO4VDCZ0gnPfUO1TwZoYwAs2ExPCedAu9DAjfQUjzITQb3jNj0KG2Sgt6BHaQUdYzWz+XmBktOHwanXjaSTcwwziBcuMOtwBmqPrTOxFQR/DRKKPqyur0aiW6cULYsx6tBm0jXpR/AUWR6HRq9WVW6MRhIq5jLyjbaCTDCijyYJNpCajdyobP/eTw0iexBAKkJ3gA5KcQb2zBXsIBckn+xVv8jkZSaEFHE+jFEleAEfayRU0MouNoBmB/L50Ai/HSLIHxcrpCvnhSQAuakKp2C/YbCylJjXRVy/z3+Kv/RrNcCo+WUzlVEhzKffnTQnxeN9fWF88fiNCUdSTsaufaChKWInHeysygfpIqagoakW+vV20J8uyl6TyNKEZWV4oRSPyCkWpgOLSbkCObT8o2r6tlG58HQquf6O0v50tB7JM7F4EORd2dx/K0w/KHsVkLPaoYrwgP/y7krr3SSMA4zj+OBgmjYkxcdIJQyQRKgg2viX9Hddi9UBb29LrKR7CVVEEEXWojUkXNyfTNDE14W9gbHJNuhjDettN3ZvbOvdOqCD3Jp/9l+/wJE+9PkYGjx/fqkys3S2rMozM/o2106rfMUINo6hVqz+eu/hd1c4xTg0TAfy5kV+4UG6+IthHTU9woWmxuKNbTfuCSfovBCxq7EtHqvYL4Sm6F8GVxsSXHMQ07TOi1DKtZxjWaaIyi4CXWjxPccUw8WVbMYY5wxC1mzEyXMJWkllpRloi+Kkoq69sxBTlElF6aAxYUbjXNlhlDZilDnM4U5SlN5biRsRHnbx3mbeWjEh4mEyiuJDl5XcWVmX5GvNkFgLWZM5qwsop4/AWfLhU1cR7k1VVvcYCWRkOI6Xy5gmnphCYIkvzuNYzHzosq2oNk2RtSs8khfUOfHIDgR6ysYBaMpl4uEgk2U/oJTs9AaTSwma7dT69geAE2ZpEjUsn2ieJNHeKfrI3EcAGJ2ZaNgVuC8EBctCLc57P5u5led6IOBkIYkuQMrmmjChs4VkfOerHqSBkPzZlhe06RslZ3zMjk2sscqKwY0RcjKK+LWbzd7KiHhkncs/siFJ+V5eXxD34B8nVuJEpGJNmxN2gH3vSvp7J70tF+D1Ej8qUJD1TkErAND2GZwTFg/LubvmgiBG3SOvdlsqFQrkEzJCL1rstlnVFROixZoDDSuXQFHESwVGlcuQcMb/b42NgjLowh5MTDFE3vNB5qStRIErdCQEh6pLPR92anSUb/wAIhldAaDMpGgAAAABJRU5ErkJggg==";
const MarkerShadowIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC";
var __defProp2 = Object.defineProperty;
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
function flip(geojson, options) {
  var _a;
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  const mutate = (_a = options.mutate) != null ? _a : false;
  if (!geojson)
    throw new Error("geojson is required");
  if (mutate === false || mutate === void 0)
    geojson = clone(geojson);
  coordEach(geojson, function(coord) {
    var x2 = coord[0];
    var y2 = coord[1];
    coord[0] = y2;
    coord[1] = x2;
  });
  return geojson;
}
__name(flip, "flip");
var turf_flip_default = flip;
(() => {
  var _a2, _b;
  var Wl = Object.create;
  var lr = Object.defineProperty;
  var Ql = Object.getOwnPropertyDescriptor;
  var th2 = Object.getOwnPropertyNames;
  var eh2 = Object.getPrototypeOf, ih2 = Object.prototype.hasOwnProperty;
  var S2 = (t2, e2) => () => (e2 || t2((e2 = { exports: {} }).exports, e2), e2.exports);
  var rh2 = (t2, e2, i, r2) => {
    if (e2 && typeof e2 == "object" || typeof e2 == "function") for (let n2 of th2(e2)) !ih2.call(t2, n2) && n2 !== i && lr(t2, n2, { get: () => e2[n2], enumerable: !(r2 = Ql(e2, n2)) || r2.enumerable });
    return t2;
  };
  var xt = (t2, e2, i) => (i = t2 != null ? Wl(eh2(t2)) : {}, rh2(e2 || !t2 || !t2.__esModule ? lr(i, "default", { value: t2, enumerable: true }) : i, t2));
  var cr = S2((w_, ur) => {
    function sh2() {
      this.__data__ = [], this.size = 0;
    }
    ur.exports = sh2;
  });
  var he2 = S2((C_, pr) => {
    function ah2(t2, e2) {
      return t2 === e2 || t2 !== t2 && e2 !== e2;
    }
    pr.exports = ah2;
  });
  var ue2 = S2((E_, fr) => {
    var oh2 = he2();
    function lh2(t2, e2) {
      for (var i = t2.length; i--; ) if (oh2(t2[i][0], e2)) return i;
      return -1;
    }
    fr.exports = lh2;
  });
  var gr = S2((P_, dr) => {
    var hh2 = ue2(), uh2 = Array.prototype, ch2 = uh2.splice;
    function ph2(t2) {
      var e2 = this.__data__, i = hh2(e2, t2);
      if (i < 0) return false;
      var r2 = e2.length - 1;
      return i == r2 ? e2.pop() : ch2.call(e2, i, 1), --this.size, true;
    }
    dr.exports = ph2;
  });
  var _r = S2((S_, mr) => {
    var fh2 = ue2();
    function dh2(t2) {
      var e2 = this.__data__, i = fh2(e2, t2);
      return i < 0 ? void 0 : e2[i][1];
    }
    mr.exports = dh2;
  });
  var Lr = S2((B_, yr) => {
    var gh2 = ue2();
    function mh2(t2) {
      return gh2(this.__data__, t2) > -1;
    }
    yr.exports = mh2;
  });
  var vr = S2((T_, br) => {
    var _h = ue2();
    function yh2(t2, e2) {
      var i = this.__data__, r2 = _h(i, t2);
      return r2 < 0 ? (++this.size, i.push([t2, e2])) : i[r2][1] = e2, this;
    }
    br.exports = yh2;
  });
  var ce2 = S2((R_, kr) => {
    var Lh2 = cr(), bh2 = gr(), vh2 = _r(), kh2 = Lr(), Mh2 = vr();
    function Kt(t2) {
      var e2 = -1, i = t2 == null ? 0 : t2.length;
      for (this.clear(); ++e2 < i; ) {
        var r2 = t2[e2];
        this.set(r2[0], r2[1]);
      }
    }
    Kt.prototype.clear = Lh2;
    Kt.prototype.delete = bh2;
    Kt.prototype.get = vh2;
    Kt.prototype.has = kh2;
    Kt.prototype.set = Mh2;
    kr.exports = Kt;
  });
  var xr = S2((D_, Mr) => {
    var xh2 = ce2();
    function wh2() {
      this.__data__ = new xh2(), this.size = 0;
    }
    Mr.exports = wh2;
  });
  var Cr = S2((O_, wr) => {
    function Ch2(t2) {
      var e2 = this.__data__, i = e2.delete(t2);
      return this.size = e2.size, i;
    }
    wr.exports = Ch2;
  });
  var Pr = S2((A_, Er) => {
    function Eh2(t2) {
      return this.__data__.get(t2);
    }
    Er.exports = Eh2;
  });
  var Br = S2((I_, Sr) => {
    function Ph2(t2) {
      return this.__data__.has(t2);
    }
    Sr.exports = Ph2;
  });
  var oi2 = S2((G_, Tr) => {
    var Sh2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    Tr.exports = Sh2;
  });
  var Gt = S2((q_, Rr) => {
    var Bh2 = oi2(), Th2 = typeof self == "object" && self && self.Object === Object && self, Rh2 = Bh2 || Th2 || Function("return this")();
    Rr.exports = Rh2;
  });
  var Oe2 = S2((N_, Dr) => {
    var Dh2 = Gt(), Oh2 = Dh2.Symbol;
    Dr.exports = Oh2;
  });
  var Gr = S2((z_, Ir) => {
    var Or = Oe2(), Ar = Object.prototype, Ah2 = Ar.hasOwnProperty, Ih2 = Ar.toString, pe2 = Or ? Or.toStringTag : void 0;
    function Gh2(t2) {
      var e2 = Ah2.call(t2, pe2), i = t2[pe2];
      try {
        t2[pe2] = void 0;
        var r2 = true;
      } catch {
      }
      var n2 = Ih2.call(t2);
      return r2 && (e2 ? t2[pe2] = i : delete t2[pe2]), n2;
    }
    Ir.exports = Gh2;
  });
  var Nr = S2((F_, qr) => {
    var qh2 = Object.prototype, Nh2 = qh2.toString;
    function zh2(t2) {
      return Nh2.call(t2);
    }
    qr.exports = zh2;
  });
  var Ht = S2((V_, Vr) => {
    var zr = Oe2(), Fh2 = Gr(), Vh2 = Nr(), Uh2 = "[object Null]", jh2 = "[object Undefined]", Fr = zr ? zr.toStringTag : void 0;
    function Kh2(t2) {
      return t2 == null ? t2 === void 0 ? jh2 : Uh2 : Fr && Fr in Object(t2) ? Fh2(t2) : Vh2(t2);
    }
    Vr.exports = Kh2;
  });
  var Bt = S2((U_, Ur) => {
    function Hh2(t2) {
      var e2 = typeof t2;
      return t2 != null && (e2 == "object" || e2 == "function");
    }
    Ur.exports = Hh2;
  });
  var Ae2 = S2((j_, jr) => {
    var Xh2 = Ht(), Yh2 = Bt(), Jh2 = "[object AsyncFunction]", $h2 = "[object Function]", Zh2 = "[object GeneratorFunction]", Wh2 = "[object Proxy]";
    function Qh2(t2) {
      if (!Yh2(t2)) return false;
      var e2 = Xh2(t2);
      return e2 == $h2 || e2 == Zh2 || e2 == Jh2 || e2 == Wh2;
    }
    jr.exports = Qh2;
  });
  var Hr = S2((K_, Kr) => {
    var tu = Gt(), eu = tu["__core-js_shared__"];
    Kr.exports = eu;
  });
  var Jr = S2((H_, Yr) => {
    var li2 = Hr(), Xr = function() {
      var t2 = /[^.]+$/.exec(li2 && li2.keys && li2.keys.IE_PROTO || "");
      return t2 ? "Symbol(src)_1." + t2 : "";
    }();
    function iu(t2) {
      return !!Xr && Xr in t2;
    }
    Yr.exports = iu;
  });
  var Zr = S2((X_, $r) => {
    var ru = Function.prototype, nu = ru.toString;
    function su(t2) {
      if (t2 != null) {
        try {
          return nu.call(t2);
        } catch {
        }
        try {
          return t2 + "";
        } catch {
        }
      }
      return "";
    }
    $r.exports = su;
  });
  var Qr = S2((Y_, Wr) => {
    var au = Ae2(), ou = Jr(), lu = Bt(), hu = Zr(), uu = /[\\^$.*+?()[\]{}|]/g, cu = /^\[object .+?Constructor\]$/, pu = Function.prototype, fu = Object.prototype, du = pu.toString, gu = fu.hasOwnProperty, mu = RegExp("^" + du.call(gu).replace(uu, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function _u(t2) {
      if (!lu(t2) || ou(t2)) return false;
      var e2 = au(t2) ? mu : cu;
      return e2.test(hu(t2));
    }
    Wr.exports = _u;
  });
  var en = S2((J_, tn) => {
    function yu(t2, e2) {
      return t2 == null ? void 0 : t2[e2];
    }
    tn.exports = yu;
  });
  var Ie2 = S2(($_, rn) => {
    var Lu = Qr(), bu = en();
    function vu(t2, e2) {
      var i = bu(t2, e2);
      return Lu(i) ? i : void 0;
    }
    rn.exports = vu;
  });
  var hi2 = S2((Z_, nn) => {
    var ku = Ie2(), Mu = Gt(), xu = ku(Mu, "Map");
    nn.exports = xu;
  });
  var fe2 = S2((W_, sn) => {
    var wu = Ie2(), Cu = wu(Object, "create");
    sn.exports = Cu;
  });
  var ln = S2((Q_, on) => {
    var an = fe2();
    function Eu() {
      this.__data__ = an ? an(null) : {}, this.size = 0;
    }
    on.exports = Eu;
  });
  var un = S2((ty, hn) => {
    function Pu(t2) {
      var e2 = this.has(t2) && delete this.__data__[t2];
      return this.size -= e2 ? 1 : 0, e2;
    }
    hn.exports = Pu;
  });
  var pn = S2((ey, cn) => {
    var Su = fe2(), Bu = "__lodash_hash_undefined__", Tu = Object.prototype, Ru = Tu.hasOwnProperty;
    function Du(t2) {
      var e2 = this.__data__;
      if (Su) {
        var i = e2[t2];
        return i === Bu ? void 0 : i;
      }
      return Ru.call(e2, t2) ? e2[t2] : void 0;
    }
    cn.exports = Du;
  });
  var dn = S2((iy, fn) => {
    var Ou = fe2(), Au = Object.prototype, Iu = Au.hasOwnProperty;
    function Gu(t2) {
      var e2 = this.__data__;
      return Ou ? e2[t2] !== void 0 : Iu.call(e2, t2);
    }
    fn.exports = Gu;
  });
  var mn = S2((ry, gn) => {
    var qu = fe2(), Nu = "__lodash_hash_undefined__";
    function zu(t2, e2) {
      var i = this.__data__;
      return this.size += this.has(t2) ? 0 : 1, i[t2] = qu && e2 === void 0 ? Nu : e2, this;
    }
    gn.exports = zu;
  });
  var yn = S2((ny, _n) => {
    var Fu = ln(), Vu = un(), Uu = pn(), ju = dn(), Ku = mn();
    function Xt(t2) {
      var e2 = -1, i = t2 == null ? 0 : t2.length;
      for (this.clear(); ++e2 < i; ) {
        var r2 = t2[e2];
        this.set(r2[0], r2[1]);
      }
    }
    Xt.prototype.clear = Fu;
    Xt.prototype.delete = Vu;
    Xt.prototype.get = Uu;
    Xt.prototype.has = ju;
    Xt.prototype.set = Ku;
    _n.exports = Xt;
  });
  var vn = S2((sy, bn) => {
    var Ln = yn(), Hu = ce2(), Xu = hi2();
    function Yu() {
      this.size = 0, this.__data__ = { hash: new Ln(), map: new (Xu || Hu)(), string: new Ln() };
    }
    bn.exports = Yu;
  });
  var Mn = S2((ay, kn) => {
    function Ju(t2) {
      var e2 = typeof t2;
      return e2 == "string" || e2 == "number" || e2 == "symbol" || e2 == "boolean" ? t2 !== "__proto__" : t2 === null;
    }
    kn.exports = Ju;
  });
  var de2 = S2((oy, xn) => {
    var $u = Mn();
    function Zu(t2, e2) {
      var i = t2.__data__;
      return $u(e2) ? i[typeof e2 == "string" ? "string" : "hash"] : i.map;
    }
    xn.exports = Zu;
  });
  var Cn = S2((ly, wn) => {
    var Wu = de2();
    function Qu(t2) {
      var e2 = Wu(this, t2).delete(t2);
      return this.size -= e2 ? 1 : 0, e2;
    }
    wn.exports = Qu;
  });
  var Pn = S2((hy, En) => {
    var tc2 = de2();
    function ec2(t2) {
      return tc2(this, t2).get(t2);
    }
    En.exports = ec2;
  });
  var Bn = S2((uy, Sn) => {
    var ic2 = de2();
    function rc2(t2) {
      return ic2(this, t2).has(t2);
    }
    Sn.exports = rc2;
  });
  var Rn = S2((cy, Tn) => {
    var nc2 = de2();
    function sc2(t2, e2) {
      var i = nc2(this, t2), r2 = i.size;
      return i.set(t2, e2), this.size += i.size == r2 ? 0 : 1, this;
    }
    Tn.exports = sc2;
  });
  var ui2 = S2((py, Dn) => {
    var ac2 = vn(), oc2 = Cn(), lc2 = Pn(), hc2 = Bn(), uc2 = Rn();
    function Yt(t2) {
      var e2 = -1, i = t2 == null ? 0 : t2.length;
      for (this.clear(); ++e2 < i; ) {
        var r2 = t2[e2];
        this.set(r2[0], r2[1]);
      }
    }
    Yt.prototype.clear = ac2;
    Yt.prototype.delete = oc2;
    Yt.prototype.get = lc2;
    Yt.prototype.has = hc2;
    Yt.prototype.set = uc2;
    Dn.exports = Yt;
  });
  var An = S2((fy, On) => {
    var cc2 = ce2(), pc2 = hi2(), fc2 = ui2(), dc2 = 200;
    function gc2(t2, e2) {
      var i = this.__data__;
      if (i instanceof cc2) {
        var r2 = i.__data__;
        if (!pc2 || r2.length < dc2 - 1) return r2.push([t2, e2]), this.size = ++i.size, this;
        i = this.__data__ = new fc2(r2);
      }
      return i.set(t2, e2), this.size = i.size, this;
    }
    On.exports = gc2;
  });
  var Gn = S2((dy, In) => {
    var mc2 = ce2(), _c = xr(), yc2 = Cr(), Lc2 = Pr(), bc2 = Br(), vc2 = An();
    function Jt(t2) {
      var e2 = this.__data__ = new mc2(t2);
      this.size = e2.size;
    }
    Jt.prototype.clear = _c;
    Jt.prototype.delete = yc2;
    Jt.prototype.get = Lc2;
    Jt.prototype.has = bc2;
    Jt.prototype.set = vc2;
    In.exports = Jt;
  });
  var ci2 = S2((gy, qn) => {
    var kc2 = Ie2(), Mc2 = function() {
      try {
        var t2 = kc2(Object, "defineProperty");
        return t2({}, "", {}), t2;
      } catch {
      }
    }();
    qn.exports = Mc2;
  });
  var Ge2 = S2((my, zn) => {
    var Nn = ci2();
    function xc2(t2, e2, i) {
      e2 == "__proto__" && Nn ? Nn(t2, e2, { configurable: true, enumerable: true, value: i, writable: true }) : t2[e2] = i;
    }
    zn.exports = xc2;
  });
  var pi2 = S2((_y, Fn) => {
    var wc2 = Ge2(), Cc2 = he2();
    function Ec2(t2, e2, i) {
      (i !== void 0 && !Cc2(t2[e2], i) || i === void 0 && !(e2 in t2)) && wc2(t2, e2, i);
    }
    Fn.exports = Ec2;
  });
  var Un = S2((yy, Vn) => {
    function Pc2(t2) {
      return function(e2, i, r2) {
        for (var n2 = -1, s2 = Object(e2), a = r2(e2), o = a.length; o--; ) {
          var l2 = a[t2 ? o : ++n2];
          if (i(s2[l2], l2, s2) === false) break;
        }
        return e2;
      };
    }
    Vn.exports = Pc2;
  });
  var Kn = S2((Ly, jn) => {
    var Sc2 = Un(), Bc2 = Sc2();
    jn.exports = Bc2;
  });
  var $n = S2((ge2, $t) => {
    var Tc2 = Gt(), Jn = typeof ge2 == "object" && ge2 && !ge2.nodeType && ge2, Hn = Jn && typeof $t == "object" && $t && !$t.nodeType && $t, Rc2 = Hn && Hn.exports === Jn, Xn = Rc2 ? Tc2.Buffer : void 0, Yn = Xn ? Xn.allocUnsafe : void 0;
    function Dc2(t2, e2) {
      if (e2) return t2.slice();
      var i = t2.length, r2 = Yn ? Yn(i) : new t2.constructor(i);
      return t2.copy(r2), r2;
    }
    $t.exports = Dc2;
  });
  var Wn = S2((by, Zn) => {
    var Oc2 = Gt(), Ac2 = Oc2.Uint8Array;
    Zn.exports = Ac2;
  });
  var es = S2((vy, ts) => {
    var Qn = Wn();
    function Ic2(t2) {
      var e2 = new t2.constructor(t2.byteLength);
      return new Qn(e2).set(new Qn(t2)), e2;
    }
    ts.exports = Ic2;
  });
  var rs = S2((ky, is3) => {
    var Gc2 = es();
    function qc2(t2, e2) {
      var i = e2 ? Gc2(t2.buffer) : t2.buffer;
      return new t2.constructor(i, t2.byteOffset, t2.length);
    }
    is3.exports = qc2;
  });
  var ss = S2((My, ns) => {
    function Nc2(t2, e2) {
      var i = -1, r2 = t2.length;
      for (e2 || (e2 = Array(r2)); ++i < r2; ) e2[i] = t2[i];
      return e2;
    }
    ns.exports = Nc2;
  });
  var ls = S2((xy, os) => {
    var zc2 = Bt(), as = Object.create, Fc2 = /* @__PURE__ */ function() {
      function t2() {
      }
      return function(e2) {
        if (!zc2(e2)) return {};
        if (as) return as(e2);
        t2.prototype = e2;
        var i = new t2();
        return t2.prototype = void 0, i;
      };
    }();
    os.exports = Fc2;
  });
  var us = S2((wy, hs) => {
    function Vc2(t2, e2) {
      return function(i) {
        return t2(e2(i));
      };
    }
    hs.exports = Vc2;
  });
  var fi2 = S2((Cy, cs) => {
    var Uc2 = us(), jc2 = Uc2(Object.getPrototypeOf, Object);
    cs.exports = jc2;
  });
  var di2 = S2((Ey, ps) => {
    var Kc2 = Object.prototype;
    function Hc2(t2) {
      var e2 = t2 && t2.constructor, i = typeof e2 == "function" && e2.prototype || Kc2;
      return t2 === i;
    }
    ps.exports = Hc2;
  });
  var ds = S2((Py, fs) => {
    var Xc2 = ls(), Yc2 = fi2(), Jc2 = di2();
    function $c2(t2) {
      return typeof t2.constructor == "function" && !Jc2(t2) ? Xc2(Yc2(t2)) : {};
    }
    fs.exports = $c2;
  });
  var qt = S2((Sy, gs) => {
    function Zc2(t2) {
      return t2 != null && typeof t2 == "object";
    }
    gs.exports = Zc2;
  });
  var _s = S2((By, ms) => {
    var Wc2 = Ht(), Qc2 = qt(), tp = "[object Arguments]";
    function ep(t2) {
      return Qc2(t2) && Wc2(t2) == tp;
    }
    ms.exports = ep;
  });
  var gi2 = S2((Ty, bs) => {
    var ys = _s(), ip = qt(), Ls = Object.prototype, rp = Ls.hasOwnProperty, np = Ls.propertyIsEnumerable, sp = ys(/* @__PURE__ */ function() {
      return arguments;
    }()) ? ys : function(t2) {
      return ip(t2) && rp.call(t2, "callee") && !np.call(t2, "callee");
    };
    bs.exports = sp;
  });
  var Zt = S2((Ry, vs) => {
    var ap = Array.isArray;
    vs.exports = ap;
  });
  var mi2 = S2((Dy, ks) => {
    var op = 9007199254740991;
    function lp(t2) {
      return typeof t2 == "number" && t2 > -1 && t2 % 1 == 0 && t2 <= op;
    }
    ks.exports = lp;
  });
  var qe2 = S2((Oy, Ms) => {
    var hp = Ae2(), up = mi2();
    function cp(t2) {
      return t2 != null && up(t2.length) && !hp(t2);
    }
    Ms.exports = cp;
  });
  var ws = S2((Ay, xs) => {
    var pp = qe2(), fp = qt();
    function dp(t2) {
      return fp(t2) && pp(t2);
    }
    xs.exports = dp;
  });
  var Es = S2((Iy, Cs) => {
    function gp() {
      return false;
    }
    Cs.exports = gp;
  });
  var _i = S2((me2, Wt) => {
    var mp = Gt(), _p = Es(), Bs = typeof me2 == "object" && me2 && !me2.nodeType && me2, Ps = Bs && typeof Wt == "object" && Wt && !Wt.nodeType && Wt, yp = Ps && Ps.exports === Bs, Ss = yp ? mp.Buffer : void 0, Lp = Ss ? Ss.isBuffer : void 0, bp = Lp || _p;
    Wt.exports = bp;
  });
  var Ds = S2((Gy, Rs) => {
    var vp = Ht(), kp = fi2(), Mp = qt(), xp = "[object Object]", wp = Function.prototype, Cp = Object.prototype, Ts = wp.toString, Ep = Cp.hasOwnProperty, Pp = Ts.call(Object);
    function Sp(t2) {
      if (!Mp(t2) || vp(t2) != xp) return false;
      var e2 = kp(t2);
      if (e2 === null) return true;
      var i = Ep.call(e2, "constructor") && e2.constructor;
      return typeof i == "function" && i instanceof i && Ts.call(i) == Pp;
    }
    Rs.exports = Sp;
  });
  var As = S2((qy, Os) => {
    var Bp = Ht(), Tp = mi2(), Rp = qt(), Dp = "[object Arguments]", Op = "[object Array]", Ap = "[object Boolean]", Ip = "[object Date]", Gp = "[object Error]", qp = "[object Function]", Np = "[object Map]", zp = "[object Number]", Fp = "[object Object]", Vp = "[object RegExp]", Up = "[object Set]", jp = "[object String]", Kp = "[object WeakMap]", Hp = "[object ArrayBuffer]", Xp = "[object DataView]", Yp = "[object Float32Array]", Jp = "[object Float64Array]", $p = "[object Int8Array]", Zp = "[object Int16Array]", Wp = "[object Int32Array]", Qp = "[object Uint8Array]", tf2 = "[object Uint8ClampedArray]", ef2 = "[object Uint16Array]", rf2 = "[object Uint32Array]", Y2 = {};
    Y2[Yp] = Y2[Jp] = Y2[$p] = Y2[Zp] = Y2[Wp] = Y2[Qp] = Y2[tf2] = Y2[ef2] = Y2[rf2] = true;
    Y2[Dp] = Y2[Op] = Y2[Hp] = Y2[Ap] = Y2[Xp] = Y2[Ip] = Y2[Gp] = Y2[qp] = Y2[Np] = Y2[zp] = Y2[Fp] = Y2[Vp] = Y2[Up] = Y2[jp] = Y2[Kp] = false;
    function nf2(t2) {
      return Rp(t2) && Tp(t2.length) && !!Y2[Bp(t2)];
    }
    Os.exports = nf2;
  });
  var Gs = S2((Ny, Is) => {
    function sf2(t2) {
      return function(e2) {
        return t2(e2);
      };
    }
    Is.exports = sf2;
  });
  var Ns = S2((_e, Qt) => {
    var af2 = oi2(), qs = typeof _e == "object" && _e && !_e.nodeType && _e, ye = qs && typeof Qt == "object" && Qt && !Qt.nodeType && Qt, of2 = ye && ye.exports === qs, yi2 = of2 && af2.process, lf2 = function() {
      try {
        var t2 = ye && ye.require && ye.require("util").types;
        return t2 || yi2 && yi2.binding && yi2.binding("util");
      } catch {
      }
    }();
    Qt.exports = lf2;
  });
  var Li2 = S2((zy, Vs) => {
    var hf = As(), uf2 = Gs(), zs = Ns(), Fs = zs && zs.isTypedArray, cf2 = Fs ? uf2(Fs) : hf;
    Vs.exports = cf2;
  });
  var bi2 = S2((Fy, Us) => {
    function pf2(t2, e2) {
      if (!(e2 === "constructor" && typeof t2[e2] == "function") && e2 != "__proto__") return t2[e2];
    }
    Us.exports = pf2;
  });
  var Ks = S2((Vy, js) => {
    var ff2 = Ge2(), df2 = he2(), gf = Object.prototype, mf2 = gf.hasOwnProperty;
    function _f(t2, e2, i) {
      var r2 = t2[e2];
      (!(mf2.call(t2, e2) && df2(r2, i)) || i === void 0 && !(e2 in t2)) && ff2(t2, e2, i);
    }
    js.exports = _f;
  });
  var Xs = S2((Uy, Hs) => {
    var yf2 = Ks(), Lf2 = Ge2();
    function bf2(t2, e2, i, r2) {
      var n2 = !i;
      i || (i = {});
      for (var s2 = -1, a = e2.length; ++s2 < a; ) {
        var o = e2[s2], l2 = r2 ? r2(i[o], t2[o], o, i, t2) : void 0;
        l2 === void 0 && (l2 = t2[o]), n2 ? Lf2(i, o, l2) : yf2(i, o, l2);
      }
      return i;
    }
    Hs.exports = bf2;
  });
  var Js = S2((jy, Ys) => {
    function vf2(t2, e2) {
      for (var i = -1, r2 = Array(t2); ++i < t2; ) r2[i] = e2(i);
      return r2;
    }
    Ys.exports = vf2;
  });
  var vi2 = S2((Ky, $s) => {
    var kf = 9007199254740991, Mf2 = /^(?:0|[1-9]\d*)$/;
    function xf2(t2, e2) {
      var i = typeof t2;
      return e2 = e2 ?? kf, !!e2 && (i == "number" || i != "symbol" && Mf2.test(t2)) && t2 > -1 && t2 % 1 == 0 && t2 < e2;
    }
    $s.exports = xf2;
  });
  var Ws = S2((Hy, Zs) => {
    var wf2 = Js(), Cf2 = gi2(), Ef2 = Zt(), Pf2 = _i(), Sf2 = vi2(), Bf2 = Li2(), Tf2 = Object.prototype, Rf2 = Tf2.hasOwnProperty;
    function Df2(t2, e2) {
      var i = Ef2(t2), r2 = !i && Cf2(t2), n2 = !i && !r2 && Pf2(t2), s2 = !i && !r2 && !n2 && Bf2(t2), a = i || r2 || n2 || s2, o = a ? wf2(t2.length, String) : [], l2 = o.length;
      for (var u2 in t2) (e2 || Rf2.call(t2, u2)) && !(a && (u2 == "length" || n2 && (u2 == "offset" || u2 == "parent") || s2 && (u2 == "buffer" || u2 == "byteLength" || u2 == "byteOffset") || Sf2(u2, l2))) && o.push(u2);
      return o;
    }
    Zs.exports = Df2;
  });
  var ta2 = S2((Xy, Qs) => {
    function Of2(t2) {
      var e2 = [];
      if (t2 != null) for (var i in Object(t2)) e2.push(i);
      return e2;
    }
    Qs.exports = Of2;
  });
  var ia2 = S2((Yy, ea2) => {
    var Af2 = Bt(), If2 = di2(), Gf2 = ta2(), qf2 = Object.prototype, Nf2 = qf2.hasOwnProperty;
    function zf2(t2) {
      if (!Af2(t2)) return Gf2(t2);
      var e2 = If2(t2), i = [];
      for (var r2 in t2) r2 == "constructor" && (e2 || !Nf2.call(t2, r2)) || i.push(r2);
      return i;
    }
    ea2.exports = zf2;
  });
  var ki2 = S2((Jy, ra2) => {
    var Ff2 = Ws(), Vf2 = ia2(), Uf2 = qe2();
    function jf(t2) {
      return Uf2(t2) ? Ff2(t2, true) : Vf2(t2);
    }
    ra2.exports = jf;
  });
  var sa2 = S2(($y, na2) => {
    var Kf2 = Xs(), Hf2 = ki2();
    function Xf2(t2) {
      return Kf2(t2, Hf2(t2));
    }
    na2.exports = Xf2;
  });
  var ca2 = S2((Zy, ua2) => {
    var aa2 = pi2(), Yf2 = $n(), Jf2 = rs(), $f2 = ss(), Zf2 = ds(), oa2 = gi2(), la2 = Zt(), Wf2 = ws(), Qf2 = _i(), td2 = Ae2(), ed2 = Bt(), id2 = Ds(), rd2 = Li2(), ha2 = bi2(), nd2 = sa2();
    function sd2(t2, e2, i, r2, n2, s2, a) {
      var o = ha2(t2, i), l2 = ha2(e2, i), u2 = a.get(l2);
      if (u2) {
        aa2(t2, i, u2);
        return;
      }
      var f2 = s2 ? s2(o, l2, i + "", t2, e2, a) : void 0, d = f2 === void 0;
      if (d) {
        var P2 = la2(l2), E2 = !P2 && Qf2(l2), T2 = !P2 && !E2 && rd2(l2);
        f2 = l2, P2 || E2 || T2 ? la2(o) ? f2 = o : Wf2(o) ? f2 = $f2(o) : E2 ? (d = false, f2 = Yf2(l2, true)) : T2 ? (d = false, f2 = Jf2(l2, true)) : f2 = [] : id2(l2) || oa2(l2) ? (f2 = o, oa2(o) ? f2 = nd2(o) : (!ed2(o) || td2(o)) && (f2 = Zf2(l2))) : d = false;
      }
      d && (a.set(l2, f2), n2(f2, l2, r2, s2, a), a.delete(l2)), aa2(t2, i, f2);
    }
    ua2.exports = sd2;
  });
  var da2 = S2((Wy, fa2) => {
    var ad2 = Gn(), od2 = pi2(), ld2 = Kn(), hd2 = ca2(), ud2 = Bt(), cd2 = ki2(), pd2 = bi2();
    function pa2(t2, e2, i, r2, n2) {
      t2 !== e2 && ld2(e2, function(s2, a) {
        if (n2 || (n2 = new ad2()), ud2(s2)) hd2(t2, e2, a, i, pa2, r2, n2);
        else {
          var o = r2 ? r2(pd2(t2, a), s2, a + "", t2, e2, n2) : void 0;
          o === void 0 && (o = s2), od2(t2, a, o);
        }
      }, cd2);
    }
    fa2.exports = pa2;
  });
  var Mi2 = S2((Qy, ga) => {
    function fd2(t2) {
      return t2;
    }
    ga.exports = fd2;
  });
  var _a = S2((tL, ma2) => {
    function dd2(t2, e2, i) {
      switch (i.length) {
        case 0:
          return t2.call(e2);
        case 1:
          return t2.call(e2, i[0]);
        case 2:
          return t2.call(e2, i[0], i[1]);
        case 3:
          return t2.call(e2, i[0], i[1], i[2]);
      }
      return t2.apply(e2, i);
    }
    ma2.exports = dd2;
  });
  var ba2 = S2((eL, La2) => {
    var gd2 = _a(), ya2 = Math.max;
    function md2(t2, e2, i) {
      return e2 = ya2(e2 === void 0 ? t2.length - 1 : e2, 0), function() {
        for (var r2 = arguments, n2 = -1, s2 = ya2(r2.length - e2, 0), a = Array(s2); ++n2 < s2; ) a[n2] = r2[e2 + n2];
        n2 = -1;
        for (var o = Array(e2 + 1); ++n2 < e2; ) o[n2] = r2[n2];
        return o[e2] = i(a), gd2(t2, this, o);
      };
    }
    La2.exports = md2;
  });
  var ka2 = S2((iL, va2) => {
    function _d(t2) {
      return function() {
        return t2;
      };
    }
    va2.exports = _d;
  });
  var wa2 = S2((rL, xa2) => {
    var yd2 = ka2(), Ma2 = ci2(), Ld2 = Mi2(), bd2 = Ma2 ? function(t2, e2) {
      return Ma2(t2, "toString", { configurable: true, enumerable: false, value: yd2(e2), writable: true });
    } : Ld2;
    xa2.exports = bd2;
  });
  var Ea2 = S2((nL, Ca2) => {
    var vd2 = 800, kd2 = 16, Md2 = Date.now;
    function xd2(t2) {
      var e2 = 0, i = 0;
      return function() {
        var r2 = Md2(), n2 = kd2 - (r2 - i);
        if (i = r2, n2 > 0) {
          if (++e2 >= vd2) return arguments[0];
        } else e2 = 0;
        return t2.apply(void 0, arguments);
      };
    }
    Ca2.exports = xd2;
  });
  var Sa2 = S2((sL, Pa2) => {
    var wd2 = wa2(), Cd2 = Ea2(), Ed2 = Cd2(wd2);
    Pa2.exports = Ed2;
  });
  var Ta2 = S2((aL, Ba2) => {
    var Pd2 = Mi2(), Sd2 = ba2(), Bd2 = Sa2();
    function Td2(t2, e2) {
      return Bd2(Sd2(t2, e2, Pd2), t2 + "");
    }
    Ba2.exports = Td2;
  });
  var Da2 = S2((oL, Ra2) => {
    var Rd2 = he2(), Dd2 = qe2(), Od2 = vi2(), Ad2 = Bt();
    function Id2(t2, e2, i) {
      if (!Ad2(i)) return false;
      var r2 = typeof e2;
      return (r2 == "number" ? Dd2(i) && Od2(e2, i.length) : r2 == "string" && e2 in i) ? Rd2(i[e2], t2) : false;
    }
    Ra2.exports = Id2;
  });
  var Aa2 = S2((lL, Oa2) => {
    var Gd2 = Ta2(), qd2 = Da2();
    function Nd2(t2) {
      return Gd2(function(e2, i) {
        var r2 = -1, n2 = i.length, s2 = n2 > 1 ? i[n2 - 1] : void 0, a = n2 > 2 ? i[2] : void 0;
        for (s2 = t2.length > 3 && typeof s2 == "function" ? (n2--, s2) : void 0, a && qd2(i[0], i[1], a) && (s2 = n2 < 3 ? void 0 : s2, n2 = 1), e2 = Object(e2); ++r2 < n2; ) {
          var o = i[r2];
          o && t2(e2, o, r2, s2);
        }
        return e2;
      });
    }
    Oa2.exports = Nd2;
  });
  var Ne2 = S2((hL, Ia2) => {
    var zd2 = da2(), Fd2 = Aa2(), Vd2 = Fd2(function(t2, e2, i) {
      zd2(t2, e2, i);
    });
    Ia2.exports = Vd2;
  });
  var ze = S2((_b2, _o) => {
    var kg2 = Ht(), Mg2 = qt(), xg2 = "[object Symbol]";
    function wg2(t2) {
      return typeof t2 == "symbol" || Mg2(t2) && kg2(t2) == xg2;
    }
    _o.exports = wg2;
  });
  var Lo = S2((yb2, yo) => {
    var Cg2 = Zt(), Eg2 = ze(), Pg2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Sg2 = /^\w*$/;
    function Bg2(t2, e2) {
      if (Cg2(t2)) return false;
      var i = typeof t2;
      return i == "number" || i == "symbol" || i == "boolean" || t2 == null || Eg2(t2) ? true : Sg2.test(t2) || !Pg2.test(t2) || e2 != null && t2 in Object(e2);
    }
    yo.exports = Bg2;
  });
  var ko = S2((Lb2, vo) => {
    var bo = ui2(), Tg2 = "Expected a function";
    function xi2(t2, e2) {
      if (typeof t2 != "function" || e2 != null && typeof e2 != "function") throw new TypeError(Tg2);
      var i = function() {
        var r2 = arguments, n2 = e2 ? e2.apply(this, r2) : r2[0], s2 = i.cache;
        if (s2.has(n2)) return s2.get(n2);
        var a = t2.apply(this, r2);
        return i.cache = s2.set(n2, a) || s2, a;
      };
      return i.cache = new (xi2.Cache || bo)(), i;
    }
    xi2.Cache = bo;
    vo.exports = xi2;
  });
  var xo = S2((bb2, Mo) => {
    var Rg2 = ko(), Dg2 = 500;
    function Og2(t2) {
      var e2 = Rg2(t2, function(r2) {
        return i.size === Dg2 && i.clear(), r2;
      }), i = e2.cache;
      return e2;
    }
    Mo.exports = Og2;
  });
  var Co = S2((vb2, wo) => {
    var Ag2 = xo(), Ig2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Gg2 = /\\(\\)?/g, qg2 = Ag2(function(t2) {
      var e2 = [];
      return t2.charCodeAt(0) === 46 && e2.push(""), t2.replace(Ig2, function(i, r2, n2, s2) {
        e2.push(n2 ? s2.replace(Gg2, "$1") : r2 || i);
      }), e2;
    });
    wo.exports = qg2;
  });
  var Po = S2((kb2, Eo) => {
    function Ng2(t2, e2) {
      for (var i = -1, r2 = t2 == null ? 0 : t2.length, n2 = Array(r2); ++i < r2; ) n2[i] = e2(t2[i], i, t2);
      return n2;
    }
    Eo.exports = Ng2;
  });
  var Oo = S2((Mb2, Do) => {
    var So = Oe2(), zg2 = Po(), Fg2 = Zt(), Vg2 = ze(), Ug2 = 1 / 0, Bo = So ? So.prototype : void 0, To = Bo ? Bo.toString : void 0;
    function Ro(t2) {
      if (typeof t2 == "string") return t2;
      if (Fg2(t2)) return zg2(t2, Ro) + "";
      if (Vg2(t2)) return To ? To.call(t2) : "";
      var e2 = t2 + "";
      return e2 == "0" && 1 / t2 == -Ug2 ? "-0" : e2;
    }
    Do.exports = Ro;
  });
  var Io = S2((xb2, Ao) => {
    var jg2 = Oo();
    function Kg2(t2) {
      return t2 == null ? "" : jg2(t2);
    }
    Ao.exports = Kg2;
  });
  var qo = S2((wb2, Go) => {
    var Hg2 = Zt(), Xg2 = Lo(), Yg2 = Co(), Jg2 = Io();
    function $g2(t2, e2) {
      return Hg2(t2) ? t2 : Xg2(t2, e2) ? [t2] : Yg2(Jg2(t2));
    }
    Go.exports = $g2;
  });
  var zo = S2((Cb2, No) => {
    var Zg2 = ze(), Wg2 = 1 / 0;
    function Qg2(t2) {
      if (typeof t2 == "string" || Zg2(t2)) return t2;
      var e2 = t2 + "";
      return e2 == "0" && 1 / t2 == -Wg2 ? "-0" : e2;
    }
    No.exports = Qg2;
  });
  var Vo = S2((Eb2, Fo) => {
    var tm = qo(), em = zo();
    function im(t2, e2) {
      e2 = tm(e2, t2);
      for (var i = 0, r2 = e2.length; t2 != null && i < r2; ) t2 = t2[em(e2[i++])];
      return i && i == r2 ? t2 : void 0;
    }
    Fo.exports = im;
  });
  var Le2 = S2((Pb2, Uo) => {
    var rm = Vo();
    function nm(t2, e2, i) {
      var r2 = t2 == null ? void 0 : rm(t2, e2);
      return r2 === void 0 ? i : r2;
    }
    Uo.exports = nm;
  });
  var Qo = S2((Ti2, Ri2) => {
    (function(t2, e2) {
      typeof Ti2 == "object" && typeof Ri2 < "u" ? Ri2.exports = e2() : (t2 = t2 || self).RBush = e2();
    })(Ti2, function() {
      function t2(_, x2, b, R2, D2) {
        (function O2(A2, q2, h2, c, p2) {
          for (; c > h2; ) {
            if (c - h2 > 600) {
              var y2 = c - h2 + 1, g2 = q2 - h2 + 1, k2 = Math.log(y2), C2 = 0.5 * Math.exp(2 * k2 / 3), m2 = 0.5 * Math.sqrt(k2 * C2 * (y2 - C2) / y2) * (g2 - y2 / 2 < 0 ? -1 : 1), v2 = Math.max(h2, Math.floor(q2 - g2 * C2 / y2 + m2)), w2 = Math.min(c, Math.floor(q2 + (y2 - g2) * C2 / y2 + m2));
              O2(A2, q2, v2, w2, p2);
            }
            var M2 = A2[q2], B2 = h2, I2 = c;
            for (e2(A2, h2, q2), p2(A2[c], M2) > 0 && e2(A2, h2, c); B2 < I2; ) {
              for (e2(A2, B2, I2), B2++, I2--; p2(A2[B2], M2) < 0; ) B2++;
              for (; p2(A2[I2], M2) > 0; ) I2--;
            }
            p2(A2[h2], M2) === 0 ? e2(A2, h2, I2) : e2(A2, ++I2, c), I2 <= q2 && (h2 = I2 + 1), q2 <= I2 && (c = I2 - 1);
          }
        })(_, x2, b || 0, R2 || _.length - 1, D2 || i);
      }
      function e2(_, x2, b) {
        var R2 = _[x2];
        _[x2] = _[b], _[b] = R2;
      }
      function i(_, x2) {
        return _ < x2 ? -1 : _ > x2 ? 1 : 0;
      }
      var r2 = function(_) {
        _ === void 0 && (_ = 9), this._maxEntries = Math.max(4, _), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function n2(_, x2, b) {
        if (!b) return x2.indexOf(_);
        for (var R2 = 0; R2 < x2.length; R2++) if (b(_, x2[R2])) return R2;
        return -1;
      }
      function s2(_, x2) {
        a(_, 0, _.children.length, x2, _);
      }
      function a(_, x2, b, R2, D2) {
        D2 || (D2 = T2(null)), D2.minX = 1 / 0, D2.minY = 1 / 0, D2.maxX = -1 / 0, D2.maxY = -1 / 0;
        for (var O2 = x2; O2 < b; O2++) {
          var A2 = _.children[O2];
          o(D2, _.leaf ? R2(A2) : A2);
        }
        return D2;
      }
      function o(_, x2) {
        return _.minX = Math.min(_.minX, x2.minX), _.minY = Math.min(_.minY, x2.minY), _.maxX = Math.max(_.maxX, x2.maxX), _.maxY = Math.max(_.maxY, x2.maxY), _;
      }
      function l2(_, x2) {
        return _.minX - x2.minX;
      }
      function u2(_, x2) {
        return _.minY - x2.minY;
      }
      function f2(_) {
        return (_.maxX - _.minX) * (_.maxY - _.minY);
      }
      function d(_) {
        return _.maxX - _.minX + (_.maxY - _.minY);
      }
      function P2(_, x2) {
        return _.minX <= x2.minX && _.minY <= x2.minY && x2.maxX <= _.maxX && x2.maxY <= _.maxY;
      }
      function E2(_, x2) {
        return x2.minX <= _.maxX && x2.minY <= _.maxY && x2.maxX >= _.minX && x2.maxY >= _.minY;
      }
      function T2(_) {
        return { children: _, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function G2(_, x2, b, R2, D2) {
        for (var O2 = [x2, b]; O2.length; ) if (!((b = O2.pop()) - (x2 = O2.pop()) <= R2)) {
          var A2 = x2 + Math.ceil((b - x2) / R2 / 2) * R2;
          t2(_, A2, x2, b, D2), O2.push(x2, A2, A2, b);
        }
      }
      return r2.prototype.all = function() {
        return this._all(this.data, []);
      }, r2.prototype.search = function(_) {
        var x2 = this.data, b = [];
        if (!E2(_, x2)) return b;
        for (var R2 = this.toBBox, D2 = []; x2; ) {
          for (var O2 = 0; O2 < x2.children.length; O2++) {
            var A2 = x2.children[O2], q2 = x2.leaf ? R2(A2) : A2;
            E2(_, q2) && (x2.leaf ? b.push(A2) : P2(_, q2) ? this._all(A2, b) : D2.push(A2));
          }
          x2 = D2.pop();
        }
        return b;
      }, r2.prototype.collides = function(_) {
        var x2 = this.data;
        if (!E2(_, x2)) return false;
        for (var b = []; x2; ) {
          for (var R2 = 0; R2 < x2.children.length; R2++) {
            var D2 = x2.children[R2], O2 = x2.leaf ? this.toBBox(D2) : D2;
            if (E2(_, O2)) {
              if (x2.leaf || P2(_, O2)) return true;
              b.push(D2);
            }
          }
          x2 = b.pop();
        }
        return false;
      }, r2.prototype.load = function(_) {
        if (!_ || !_.length) return this;
        if (_.length < this._minEntries) {
          for (var x2 = 0; x2 < _.length; x2++) this.insert(_[x2]);
          return this;
        }
        var b = this._build(_.slice(), 0, _.length - 1, 0);
        if (this.data.children.length) if (this.data.height === b.height) this._splitRoot(this.data, b);
        else {
          if (this.data.height < b.height) {
            var R2 = this.data;
            this.data = b, b = R2;
          }
          this._insert(b, this.data.height - b.height - 1, true);
        }
        else this.data = b;
        return this;
      }, r2.prototype.insert = function(_) {
        return _ && this._insert(_, this.data.height - 1), this;
      }, r2.prototype.clear = function() {
        return this.data = T2([]), this;
      }, r2.prototype.remove = function(_, x2) {
        if (!_) return this;
        for (var b, R2, D2, O2 = this.data, A2 = this.toBBox(_), q2 = [], h2 = []; O2 || q2.length; ) {
          if (O2 || (O2 = q2.pop(), R2 = q2[q2.length - 1], b = h2.pop(), D2 = true), O2.leaf) {
            var c = n2(_, O2.children, x2);
            if (c !== -1) return O2.children.splice(c, 1), q2.push(O2), this._condense(q2), this;
          }
          D2 || O2.leaf || !P2(O2, A2) ? R2 ? (b++, O2 = R2.children[b], D2 = false) : O2 = null : (q2.push(O2), h2.push(b), b = 0, R2 = O2, O2 = O2.children[0]);
        }
        return this;
      }, r2.prototype.toBBox = function(_) {
        return _;
      }, r2.prototype.compareMinX = function(_, x2) {
        return _.minX - x2.minX;
      }, r2.prototype.compareMinY = function(_, x2) {
        return _.minY - x2.minY;
      }, r2.prototype.toJSON = function() {
        return this.data;
      }, r2.prototype.fromJSON = function(_) {
        return this.data = _, this;
      }, r2.prototype._all = function(_, x2) {
        for (var b = []; _; ) _.leaf ? x2.push.apply(x2, _.children) : b.push.apply(b, _.children), _ = b.pop();
        return x2;
      }, r2.prototype._build = function(_, x2, b, R2) {
        var D2, O2 = b - x2 + 1, A2 = this._maxEntries;
        if (O2 <= A2) return s2(D2 = T2(_.slice(x2, b + 1)), this.toBBox), D2;
        R2 || (R2 = Math.ceil(Math.log(O2) / Math.log(A2)), A2 = Math.ceil(O2 / Math.pow(A2, R2 - 1))), (D2 = T2([])).leaf = false, D2.height = R2;
        var q2 = Math.ceil(O2 / A2), h2 = q2 * Math.ceil(Math.sqrt(A2));
        G2(_, x2, b, h2, this.compareMinX);
        for (var c = x2; c <= b; c += h2) {
          var p2 = Math.min(c + h2 - 1, b);
          G2(_, c, p2, q2, this.compareMinY);
          for (var y2 = c; y2 <= p2; y2 += q2) {
            var g2 = Math.min(y2 + q2 - 1, p2);
            D2.children.push(this._build(_, y2, g2, R2 - 1));
          }
        }
        return s2(D2, this.toBBox), D2;
      }, r2.prototype._chooseSubtree = function(_, x2, b, R2) {
        for (; R2.push(x2), !x2.leaf && R2.length - 1 !== b; ) {
          for (var D2 = 1 / 0, O2 = 1 / 0, A2 = void 0, q2 = 0; q2 < x2.children.length; q2++) {
            var h2 = x2.children[q2], c = f2(h2), p2 = (y2 = _, g2 = h2, (Math.max(g2.maxX, y2.maxX) - Math.min(g2.minX, y2.minX)) * (Math.max(g2.maxY, y2.maxY) - Math.min(g2.minY, y2.minY)) - c);
            p2 < O2 ? (O2 = p2, D2 = c < D2 ? c : D2, A2 = h2) : p2 === O2 && c < D2 && (D2 = c, A2 = h2);
          }
          x2 = A2 || x2.children[0];
        }
        var y2, g2;
        return x2;
      }, r2.prototype._insert = function(_, x2, b) {
        var R2 = b ? _ : this.toBBox(_), D2 = [], O2 = this._chooseSubtree(R2, this.data, x2, D2);
        for (O2.children.push(_), o(O2, R2); x2 >= 0 && D2[x2].children.length > this._maxEntries; ) this._split(D2, x2), x2--;
        this._adjustParentBBoxes(R2, D2, x2);
      }, r2.prototype._split = function(_, x2) {
        var b = _[x2], R2 = b.children.length, D2 = this._minEntries;
        this._chooseSplitAxis(b, D2, R2);
        var O2 = this._chooseSplitIndex(b, D2, R2), A2 = T2(b.children.splice(O2, b.children.length - O2));
        A2.height = b.height, A2.leaf = b.leaf, s2(b, this.toBBox), s2(A2, this.toBBox), x2 ? _[x2 - 1].children.push(A2) : this._splitRoot(b, A2);
      }, r2.prototype._splitRoot = function(_, x2) {
        this.data = T2([_, x2]), this.data.height = _.height + 1, this.data.leaf = false, s2(this.data, this.toBBox);
      }, r2.prototype._chooseSplitIndex = function(_, x2, b) {
        for (var R2, D2, O2, A2, q2, h2, c, p2 = 1 / 0, y2 = 1 / 0, g2 = x2; g2 <= b - x2; g2++) {
          var k2 = a(_, 0, g2, this.toBBox), C2 = a(_, g2, b, this.toBBox), m2 = (D2 = k2, O2 = C2, A2 = void 0, q2 = void 0, h2 = void 0, c = void 0, A2 = Math.max(D2.minX, O2.minX), q2 = Math.max(D2.minY, O2.minY), h2 = Math.min(D2.maxX, O2.maxX), c = Math.min(D2.maxY, O2.maxY), Math.max(0, h2 - A2) * Math.max(0, c - q2)), v2 = f2(k2) + f2(C2);
          m2 < p2 ? (p2 = m2, R2 = g2, y2 = v2 < y2 ? v2 : y2) : m2 === p2 && v2 < y2 && (y2 = v2, R2 = g2);
        }
        return R2 || b - x2;
      }, r2.prototype._chooseSplitAxis = function(_, x2, b) {
        var R2 = _.leaf ? this.compareMinX : l2, D2 = _.leaf ? this.compareMinY : u2;
        this._allDistMargin(_, x2, b, R2) < this._allDistMargin(_, x2, b, D2) && _.children.sort(R2);
      }, r2.prototype._allDistMargin = function(_, x2, b, R2) {
        _.children.sort(R2);
        for (var D2 = this.toBBox, O2 = a(_, 0, x2, D2), A2 = a(_, b - x2, b, D2), q2 = d(O2) + d(A2), h2 = x2; h2 < b - x2; h2++) {
          var c = _.children[h2];
          o(O2, _.leaf ? D2(c) : c), q2 += d(O2);
        }
        for (var p2 = b - x2 - 1; p2 >= x2; p2--) {
          var y2 = _.children[p2];
          o(A2, _.leaf ? D2(y2) : y2), q2 += d(A2);
        }
        return q2;
      }, r2.prototype._adjustParentBBoxes = function(_, x2, b) {
        for (var R2 = b; R2 >= 0; R2--) o(x2[R2], _);
      }, r2.prototype._condense = function(_) {
        for (var x2 = _.length - 1, b = void 0; x2 >= 0; x2--) _[x2].children.length === 0 ? x2 > 0 ? (b = _[x2 - 1].children).splice(b.indexOf(_[x2]), 1) : this.clear() : s2(_[x2], this.toBBox);
      }, r2;
    });
  });
  var Gi2 = S2((z2) => {
    Object.defineProperty(z2, "__esModule", { value: true });
    z2.earthRadius = 63710088e-1;
    z2.factors = { centimeters: z2.earthRadius * 100, centimetres: z2.earthRadius * 100, degrees: z2.earthRadius / 111325, feet: z2.earthRadius * 3.28084, inches: z2.earthRadius * 39.37, kilometers: z2.earthRadius / 1e3, kilometres: z2.earthRadius / 1e3, meters: z2.earthRadius, metres: z2.earthRadius, miles: z2.earthRadius / 1609.344, millimeters: z2.earthRadius * 1e3, millimetres: z2.earthRadius * 1e3, nauticalmiles: z2.earthRadius / 1852, radians: 1, yards: z2.earthRadius * 1.0936 };
    z2.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: 1 / 1e3, kilometres: 1 / 1e3, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / z2.earthRadius, yards: 1.0936133 };
    z2.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 };
    function Ot(t2, e2, i) {
      i === void 0 && (i = {});
      var r2 = { type: "Feature" };
      return (i.id === 0 || i.id) && (r2.id = i.id), i.bbox && (r2.bbox = i.bbox), r2.properties = e2 || {}, r2.geometry = t2, r2;
    }
    z2.feature = Ot;
    function ym(t2, e2, i) {
      switch (t2) {
        case "Point":
          return Di2(e2).geometry;
        case "LineString":
          return Ai2(e2).geometry;
        case "Polygon":
          return Oi2(e2).geometry;
        case "MultiPoint":
          return el2(e2).geometry;
        case "MultiLineString":
          return tl2(e2).geometry;
        case "MultiPolygon":
          return il2(e2).geometry;
        default:
          throw new Error(t2 + " is invalid");
      }
    }
    z2.geometry = ym;
    function Di2(t2, e2, i) {
      if (i === void 0 && (i = {}), !t2) throw new Error("coordinates is required");
      if (!Array.isArray(t2)) throw new Error("coordinates must be an Array");
      if (t2.length < 2) throw new Error("coordinates must be at least 2 numbers long");
      if (!Ve2(t2[0]) || !Ve2(t2[1])) throw new Error("coordinates must contain numbers");
      var r2 = { type: "Point", coordinates: t2 };
      return Ot(r2, e2, i);
    }
    z2.point = Di2;
    function Lm(t2, e2, i) {
      return i === void 0 && (i = {}), Ue2(t2.map(function(r2) {
        return Di2(r2, e2);
      }), i);
    }
    z2.points = Lm;
    function Oi2(t2, e2, i) {
      i === void 0 && (i = {});
      for (var r2 = 0, n2 = t2; r2 < n2.length; r2++) {
        var s2 = n2[r2];
        if (s2.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        for (var a = 0; a < s2[s2.length - 1].length; a++) if (s2[s2.length - 1][a] !== s2[0][a]) throw new Error("First and last Position are not equivalent.");
      }
      var o = { type: "Polygon", coordinates: t2 };
      return Ot(o, e2, i);
    }
    z2.polygon = Oi2;
    function bm(t2, e2, i) {
      return i === void 0 && (i = {}), Ue2(t2.map(function(r2) {
        return Oi2(r2, e2);
      }), i);
    }
    z2.polygons = bm;
    function Ai2(t2, e2, i) {
      if (i === void 0 && (i = {}), t2.length < 2) throw new Error("coordinates must be an array of two or more positions");
      var r2 = { type: "LineString", coordinates: t2 };
      return Ot(r2, e2, i);
    }
    z2.lineString = Ai2;
    function vm(t2, e2, i) {
      return i === void 0 && (i = {}), Ue2(t2.map(function(r2) {
        return Ai2(r2, e2);
      }), i);
    }
    z2.lineStrings = vm;
    function Ue2(t2, e2) {
      e2 === void 0 && (e2 = {});
      var i = { type: "FeatureCollection" };
      return e2.id && (i.id = e2.id), e2.bbox && (i.bbox = e2.bbox), i.features = t2, i;
    }
    z2.featureCollection = Ue2;
    function tl2(t2, e2, i) {
      i === void 0 && (i = {});
      var r2 = { type: "MultiLineString", coordinates: t2 };
      return Ot(r2, e2, i);
    }
    z2.multiLineString = tl2;
    function el2(t2, e2, i) {
      i === void 0 && (i = {});
      var r2 = { type: "MultiPoint", coordinates: t2 };
      return Ot(r2, e2, i);
    }
    z2.multiPoint = el2;
    function il2(t2, e2, i) {
      i === void 0 && (i = {});
      var r2 = { type: "MultiPolygon", coordinates: t2 };
      return Ot(r2, e2, i);
    }
    z2.multiPolygon = il2;
    function km(t2, e2, i) {
      i === void 0 && (i = {});
      var r2 = { type: "GeometryCollection", geometries: t2 };
      return Ot(r2, e2, i);
    }
    z2.geometryCollection = km;
    function Mm(t2, e2) {
      if (e2 === void 0 && (e2 = 0), e2 && !(e2 >= 0)) throw new Error("precision must be a positive number");
      var i = Math.pow(10, e2 || 0);
      return Math.round(t2 * i) / i;
    }
    z2.round = Mm;
    function rl2(t2, e2) {
      e2 === void 0 && (e2 = "kilometers");
      var i = z2.factors[e2];
      if (!i) throw new Error(e2 + " units is invalid");
      return t2 * i;
    }
    z2.radiansToLength = rl2;
    function Ii2(t2, e2) {
      e2 === void 0 && (e2 = "kilometers");
      var i = z2.factors[e2];
      if (!i) throw new Error(e2 + " units is invalid");
      return t2 / i;
    }
    z2.lengthToRadians = Ii2;
    function xm(t2, e2) {
      return nl2(Ii2(t2, e2));
    }
    z2.lengthToDegrees = xm;
    function wm(t2) {
      var e2 = t2 % 360;
      return e2 < 0 && (e2 += 360), e2;
    }
    z2.bearingToAzimuth = wm;
    function nl2(t2) {
      var e2 = t2 % (2 * Math.PI);
      return e2 * 180 / Math.PI;
    }
    z2.radiansToDegrees = nl2;
    function Cm(t2) {
      var e2 = t2 % 360;
      return e2 * Math.PI / 180;
    }
    z2.degreesToRadians = Cm;
    function Em(t2, e2, i) {
      if (e2 === void 0 && (e2 = "kilometers"), i === void 0 && (i = "kilometers"), !(t2 >= 0)) throw new Error("length must be a positive number");
      return rl2(Ii2(t2, e2), i);
    }
    z2.convertLength = Em;
    function Pm(t2, e2, i) {
      if (e2 === void 0 && (e2 = "meters"), i === void 0 && (i = "kilometers"), !(t2 >= 0)) throw new Error("area must be a positive number");
      var r2 = z2.areaFactors[e2];
      if (!r2) throw new Error("invalid original units");
      var n2 = z2.areaFactors[i];
      if (!n2) throw new Error("invalid final units");
      return t2 / r2 * n2;
    }
    z2.convertArea = Pm;
    function Ve2(t2) {
      return !isNaN(t2) && t2 !== null && !Array.isArray(t2);
    }
    z2.isNumber = Ve2;
    function Sm(t2) {
      return !!t2 && t2.constructor === Object;
    }
    z2.isObject = Sm;
    function Bm(t2) {
      if (!t2) throw new Error("bbox is required");
      if (!Array.isArray(t2)) throw new Error("bbox must be an Array");
      if (t2.length !== 4 && t2.length !== 6) throw new Error("bbox must be an Array of 4 or 6 numbers");
      t2.forEach(function(e2) {
        if (!Ve2(e2)) throw new Error("bbox must only contain numbers");
      });
    }
    z2.validateBBox = Bm;
    function Tm(t2) {
      if (!t2) throw new Error("id is required");
      if (["string", "number"].indexOf(typeof t2) === -1) throw new Error("id must be a number or a string");
    }
    z2.validateId = Tm;
  });
  var Ni2 = S2((Q2) => {
    Object.defineProperty(Q2, "__esModule", { value: true });
    var nt = Gi2();
    function Ce2(t2, e2, i) {
      if (t2 !== null) for (var r2, n2, s2, a, o, l2, u2, f2 = 0, d = 0, P2, E2 = t2.type, T2 = E2 === "FeatureCollection", G2 = E2 === "Feature", _ = T2 ? t2.features.length : 1, x2 = 0; x2 < _; x2++) {
        u2 = T2 ? t2.features[x2].geometry : G2 ? t2.geometry : t2, P2 = u2 ? u2.type === "GeometryCollection" : false, o = P2 ? u2.geometries.length : 1;
        for (var b = 0; b < o; b++) {
          var R2 = 0, D2 = 0;
          if (a = P2 ? u2.geometries[b] : u2, a !== null) {
            l2 = a.coordinates;
            var O2 = a.type;
            switch (f2 = i && (O2 === "Polygon" || O2 === "MultiPolygon") ? 1 : 0, O2) {
              case null:
                break;
              case "Point":
                if (e2(l2, d, x2, R2, D2) === false) return false;
                d++, R2++;
                break;
              case "LineString":
              case "MultiPoint":
                for (r2 = 0; r2 < l2.length; r2++) {
                  if (e2(l2[r2], d, x2, R2, D2) === false) return false;
                  d++, O2 === "MultiPoint" && R2++;
                }
                O2 === "LineString" && R2++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (r2 = 0; r2 < l2.length; r2++) {
                  for (n2 = 0; n2 < l2[r2].length - f2; n2++) {
                    if (e2(l2[r2][n2], d, x2, R2, D2) === false) return false;
                    d++;
                  }
                  O2 === "MultiLineString" && R2++, O2 === "Polygon" && D2++;
                }
                O2 === "Polygon" && R2++;
                break;
              case "MultiPolygon":
                for (r2 = 0; r2 < l2.length; r2++) {
                  for (D2 = 0, n2 = 0; n2 < l2[r2].length; n2++) {
                    for (s2 = 0; s2 < l2[r2][n2].length - f2; s2++) {
                      if (e2(l2[r2][n2][s2], d, x2, R2, D2) === false) return false;
                      d++;
                    }
                    D2++;
                  }
                  R2++;
                }
                break;
              case "GeometryCollection":
                for (r2 = 0; r2 < a.geometries.length; r2++) if (Ce2(a.geometries[r2], e2, i) === false) return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
    }
    function Rm(t2, e2, i, r2) {
      var n2 = i;
      return Ce2(t2, function(s2, a, o, l2, u2) {
        a === 0 && i === void 0 ? n2 = s2 : n2 = e2(n2, s2, a, o, l2, u2);
      }, r2), n2;
    }
    function sl2(t2, e2) {
      var i;
      switch (t2.type) {
        case "FeatureCollection":
          for (i = 0; i < t2.features.length && e2(t2.features[i].properties, i) !== false; i++) ;
          break;
        case "Feature":
          e2(t2.properties, 0);
          break;
      }
    }
    function Dm(t2, e2, i) {
      var r2 = i;
      return sl2(t2, function(n2, s2) {
        s2 === 0 && i === void 0 ? r2 = n2 : r2 = e2(r2, n2, s2);
      }), r2;
    }
    function al2(t2, e2) {
      if (t2.type === "Feature") e2(t2, 0);
      else if (t2.type === "FeatureCollection") for (var i = 0; i < t2.features.length && e2(t2.features[i], i) !== false; i++) ;
    }
    function Om(t2, e2, i) {
      var r2 = i;
      return al2(t2, function(n2, s2) {
        s2 === 0 && i === void 0 ? r2 = n2 : r2 = e2(r2, n2, s2);
      }), r2;
    }
    function Am(t2) {
      var e2 = [];
      return Ce2(t2, function(i) {
        e2.push(i);
      }), e2;
    }
    function qi2(t2, e2) {
      var i, r2, n2, s2, a, o, l2, u2, f2, d, P2 = 0, E2 = t2.type === "FeatureCollection", T2 = t2.type === "Feature", G2 = E2 ? t2.features.length : 1;
      for (i = 0; i < G2; i++) {
        for (o = E2 ? t2.features[i].geometry : T2 ? t2.geometry : t2, u2 = E2 ? t2.features[i].properties : T2 ? t2.properties : {}, f2 = E2 ? t2.features[i].bbox : T2 ? t2.bbox : void 0, d = E2 ? t2.features[i].id : T2 ? t2.id : void 0, l2 = o ? o.type === "GeometryCollection" : false, a = l2 ? o.geometries.length : 1, n2 = 0; n2 < a; n2++) {
          if (s2 = l2 ? o.geometries[n2] : o, s2 === null) {
            if (e2(null, P2, u2, f2, d) === false) return false;
            continue;
          }
          switch (s2.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon": {
              if (e2(s2, P2, u2, f2, d) === false) return false;
              break;
            }
            case "GeometryCollection": {
              for (r2 = 0; r2 < s2.geometries.length; r2++) if (e2(s2.geometries[r2], P2, u2, f2, d) === false) return false;
              break;
            }
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
        P2++;
      }
    }
    function Im(t2, e2, i) {
      var r2 = i;
      return qi2(t2, function(n2, s2, a, o, l2) {
        s2 === 0 && i === void 0 ? r2 = n2 : r2 = e2(r2, n2, s2, a, o, l2);
      }), r2;
    }
    function je2(t2, e2) {
      qi2(t2, function(i, r2, n2, s2, a) {
        var o = i === null ? null : i.type;
        switch (o) {
          case null:
          case "Point":
          case "LineString":
          case "Polygon":
            return e2(nt.feature(i, n2, { bbox: s2, id: a }), r2, 0) === false ? false : void 0;
        }
        var l2;
        switch (o) {
          case "MultiPoint":
            l2 = "Point";
            break;
          case "MultiLineString":
            l2 = "LineString";
            break;
          case "MultiPolygon":
            l2 = "Polygon";
            break;
        }
        for (var u2 = 0; u2 < i.coordinates.length; u2++) {
          var f2 = i.coordinates[u2], d = { type: l2, coordinates: f2 };
          if (e2(nt.feature(d, n2), r2, u2) === false) return false;
        }
      });
    }
    function Gm(t2, e2, i) {
      var r2 = i;
      return je2(t2, function(n2, s2, a) {
        s2 === 0 && a === 0 && i === void 0 ? r2 = n2 : r2 = e2(r2, n2, s2, a);
      }), r2;
    }
    function ol2(t2, e2) {
      je2(t2, function(i, r2, n2) {
        var s2 = 0;
        if (i.geometry) {
          var a = i.geometry.type;
          if (!(a === "Point" || a === "MultiPoint")) {
            var o, l2 = 0, u2 = 0, f2 = 0;
            if (Ce2(i, function(d, P2, E2, T2, G2) {
              if (o === void 0 || r2 > l2 || T2 > u2 || G2 > f2) {
                o = d, l2 = r2, u2 = T2, f2 = G2, s2 = 0;
                return;
              }
              var _ = nt.lineString([o, d], i.properties);
              if (e2(_, r2, n2, G2, s2) === false) return false;
              s2++, o = d;
            }) === false) return false;
          }
        }
      });
    }
    function qm(t2, e2, i) {
      var r2 = i, n2 = false;
      return ol2(t2, function(s2, a, o, l2, u2) {
        n2 === false && i === void 0 ? r2 = s2 : r2 = e2(r2, s2, a, o, l2, u2), n2 = true;
      }), r2;
    }
    function ll2(t2, e2) {
      if (!t2) throw new Error("geojson is required");
      je2(t2, function(i, r2, n2) {
        if (i.geometry !== null) {
          var s2 = i.geometry.type, a = i.geometry.coordinates;
          switch (s2) {
            case "LineString":
              if (e2(i, r2, n2, 0, 0) === false) return false;
              break;
            case "Polygon":
              for (var o = 0; o < a.length; o++) if (e2(nt.lineString(a[o], i.properties), r2, n2, o) === false) return false;
              break;
          }
        }
      });
    }
    function Nm(t2, e2, i) {
      var r2 = i;
      return ll2(t2, function(n2, s2, a, o) {
        s2 === 0 && i === void 0 ? r2 = n2 : r2 = e2(r2, n2, s2, a, o);
      }), r2;
    }
    function zm(t2, e2) {
      if (e2 = e2 || {}, !nt.isObject(e2)) throw new Error("options is invalid");
      var i = e2.featureIndex || 0, r2 = e2.multiFeatureIndex || 0, n2 = e2.geometryIndex || 0, s2 = e2.segmentIndex || 0, a = e2.properties, o;
      switch (t2.type) {
        case "FeatureCollection":
          i < 0 && (i = t2.features.length + i), a = a || t2.features[i].properties, o = t2.features[i].geometry;
          break;
        case "Feature":
          a = a || t2.properties, o = t2.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          o = t2;
          break;
        default:
          throw new Error("geojson is invalid");
      }
      if (o === null) return null;
      var l2 = o.coordinates;
      switch (o.type) {
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
          return s2 < 0 && (s2 = l2.length + s2 - 1), nt.lineString([l2[s2], l2[s2 + 1]], a, e2);
        case "Polygon":
          return n2 < 0 && (n2 = l2.length + n2), s2 < 0 && (s2 = l2[n2].length + s2 - 1), nt.lineString([l2[n2][s2], l2[n2][s2 + 1]], a, e2);
        case "MultiLineString":
          return r2 < 0 && (r2 = l2.length + r2), s2 < 0 && (s2 = l2[r2].length + s2 - 1), nt.lineString([l2[r2][s2], l2[r2][s2 + 1]], a, e2);
        case "MultiPolygon":
          return r2 < 0 && (r2 = l2.length + r2), n2 < 0 && (n2 = l2[r2].length + n2), s2 < 0 && (s2 = l2[r2][n2].length - s2 - 1), nt.lineString([l2[r2][n2][s2], l2[r2][n2][s2 + 1]], a, e2);
      }
      throw new Error("geojson is invalid");
    }
    function Fm(t2, e2) {
      if (e2 = e2 || {}, !nt.isObject(e2)) throw new Error("options is invalid");
      var i = e2.featureIndex || 0, r2 = e2.multiFeatureIndex || 0, n2 = e2.geometryIndex || 0, s2 = e2.coordIndex || 0, a = e2.properties, o;
      switch (t2.type) {
        case "FeatureCollection":
          i < 0 && (i = t2.features.length + i), a = a || t2.features[i].properties, o = t2.features[i].geometry;
          break;
        case "Feature":
          a = a || t2.properties, o = t2.geometry;
          break;
        case "Point":
        case "MultiPoint":
          return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
          o = t2;
          break;
        default:
          throw new Error("geojson is invalid");
      }
      if (o === null) return null;
      var l2 = o.coordinates;
      switch (o.type) {
        case "Point":
          return nt.point(l2, a, e2);
        case "MultiPoint":
          return r2 < 0 && (r2 = l2.length + r2), nt.point(l2[r2], a, e2);
        case "LineString":
          return s2 < 0 && (s2 = l2.length + s2), nt.point(l2[s2], a, e2);
        case "Polygon":
          return n2 < 0 && (n2 = l2.length + n2), s2 < 0 && (s2 = l2[n2].length + s2), nt.point(l2[n2][s2], a, e2);
        case "MultiLineString":
          return r2 < 0 && (r2 = l2.length + r2), s2 < 0 && (s2 = l2[r2].length + s2), nt.point(l2[r2][s2], a, e2);
        case "MultiPolygon":
          return r2 < 0 && (r2 = l2.length + r2), n2 < 0 && (n2 = l2[r2].length + n2), s2 < 0 && (s2 = l2[r2][n2].length - s2), nt.point(l2[r2][n2][s2], a, e2);
      }
      throw new Error("geojson is invalid");
    }
    Q2.coordAll = Am;
    Q2.coordEach = Ce2;
    Q2.coordReduce = Rm;
    Q2.featureEach = al2;
    Q2.featureReduce = Om;
    Q2.findPoint = Fm;
    Q2.findSegment = zm;
    Q2.flattenEach = je2;
    Q2.flattenReduce = Gm;
    Q2.geomEach = qi2;
    Q2.geomReduce = Im;
    Q2.lineEach = ll2;
    Q2.lineReduce = Nm;
    Q2.propEach = sl2;
    Q2.propReduce = Dm;
    Q2.segmentEach = ol2;
    Q2.segmentReduce = qm;
  });
  var hl2 = S2((Fi2) => {
    Object.defineProperty(Fi2, "__esModule", { value: true });
    var Vm = Ni2();
    function zi2(t2) {
      var e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      return Vm.coordEach(t2, function(i) {
        e2[0] > i[0] && (e2[0] = i[0]), e2[1] > i[1] && (e2[1] = i[1]), e2[2] < i[0] && (e2[2] = i[0]), e2[3] < i[1] && (e2[3] = i[1]);
      }), e2;
    }
    zi2.default = zi2;
    Fi2.default = zi2;
  });
  var Ui2 = S2((Ev, Vi2) => {
    var kt = Qo(), cl2 = Gi2(), pl2 = Ni2(), re2 = hl2().default, Um = pl2.featureEach;
    pl2.coordEach;
    cl2.polygon;
    var ul2 = cl2.featureCollection;
    function fl2(t2) {
      var e2 = new kt(t2);
      return e2.insert = function(i) {
        if (i.type !== "Feature") throw new Error("invalid feature");
        return i.bbox = i.bbox ? i.bbox : re2(i), kt.prototype.insert.call(this, i);
      }, e2.load = function(i) {
        var r2 = [];
        return Array.isArray(i) ? i.forEach(function(n2) {
          if (n2.type !== "Feature") throw new Error("invalid features");
          n2.bbox = n2.bbox ? n2.bbox : re2(n2), r2.push(n2);
        }) : Um(i, function(n2) {
          if (n2.type !== "Feature") throw new Error("invalid features");
          n2.bbox = n2.bbox ? n2.bbox : re2(n2), r2.push(n2);
        }), kt.prototype.load.call(this, r2);
      }, e2.remove = function(i, r2) {
        if (i.type !== "Feature") throw new Error("invalid feature");
        return i.bbox = i.bbox ? i.bbox : re2(i), kt.prototype.remove.call(this, i, r2);
      }, e2.clear = function() {
        return kt.prototype.clear.call(this);
      }, e2.search = function(i) {
        var r2 = kt.prototype.search.call(this, this.toBBox(i));
        return ul2(r2);
      }, e2.collides = function(i) {
        return kt.prototype.collides.call(this, this.toBBox(i));
      }, e2.all = function() {
        var i = kt.prototype.all.call(this);
        return ul2(i);
      }, e2.toJSON = function() {
        return kt.prototype.toJSON.call(this);
      }, e2.fromJSON = function(i) {
        return kt.prototype.fromJSON.call(this, i);
      }, e2.toBBox = function(i) {
        var r2;
        if (i.bbox) r2 = i.bbox;
        else if (Array.isArray(i) && i.length === 4) r2 = i;
        else if (Array.isArray(i) && i.length === 6) r2 = [i[0], i[1], i[3], i[4]];
        else if (i.type === "Feature") r2 = re2(i);
        else if (i.type === "FeatureCollection") r2 = re2(i);
        else throw new Error("invalid geojson");
        return { minX: r2[0], minY: r2[1], maxX: r2[2], maxY: r2[3] };
      }, e2;
    }
    Vi2.exports = fl2;
    Vi2.exports.default = fl2;
  });
  Array.prototype.findIndex = Array.prototype.findIndex || function(t2) {
    if (this === null) throw new TypeError("Array.prototype.findIndex called on null or undefined");
    if (typeof t2 != "function") throw new TypeError("callback must be a function");
    for (var e2 = Object(this), i = e2.length >>> 0, r2 = arguments[1], n2 = 0; n2 < i; n2++) if (t2.call(r2, e2[n2], n2, e2)) return n2;
    return -1;
  };
  Array.prototype.find = Array.prototype.find || function(t2) {
    if (this === null) throw new TypeError("Array.prototype.find called on null or undefined");
    if (typeof t2 != "function") throw new TypeError("callback must be a function");
    for (var e2 = Object(this), i = e2.length >>> 0, r2 = arguments[1], n2 = 0; n2 < i; n2++) {
      var s2 = e2[n2];
      if (t2.call(r2, s2, n2, e2)) return s2;
    }
  };
  typeof Object.assign != "function" && (Object.assign = function(t2) {
    if (t2 == null) throw new TypeError("Cannot convert undefined or null to object");
    t2 = Object(t2);
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i = arguments[e2];
      if (i != null) for (var r2 in i) Object.prototype.hasOwnProperty.call(i, r2) && (t2[r2] = i[r2]);
    }
    return t2;
  });
  (function(t2) {
    t2.forEach(function(e2) {
      e2.hasOwnProperty("remove") || Object.defineProperty(e2, "remove", { configurable: true, enumerable: true, writable: true, value: function() {
        this.parentNode.removeChild(this);
      } });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
  Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", { value: function(t2, e2) {
    if (this == null) throw new TypeError('"this" is null or not defined');
    var i = Object(this), r2 = i.length >>> 0;
    if (r2 === 0) return false;
    var n2 = e2 | 0, s2 = Math.max(n2 >= 0 ? n2 : r2 - Math.abs(n2), 0);
    function a(o, l2) {
      return o === l2 || typeof o == "number" && typeof l2 == "number" && isNaN(o) && isNaN(l2);
    }
    for (; s2 < r2; ) {
      if (a(i[s2], t2)) return true;
      s2++;
    }
    return false;
  } });
  var hr = { name: "@geoman-io/leaflet-geoman-free", version: "2.17.0", description: "A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0", keywords: ["leaflet", "geoman", "polygon management", "geometry editing", "map data", "map overlay", "polygon", "geojson", "leaflet-draw", "data-field-geojson", "ui-leaflet-draw"], files: ["dist"], main: "dist/leaflet-geoman.js", types: "dist/leaflet-geoman.d.ts", dependencies: { "@turf/boolean-contains": "^6.5.0", "@turf/kinks": "^6.5.0", "@turf/line-intersect": "^6.5.0", "@turf/line-split": "^6.5.0", lodash: "4.17.21", "polyclip-ts": "^0.16.5" }, devDependencies: { "@types/leaflet": "^1.7.9", "cross-env": "^7.0.3", cypress: "6.9.1", "cypress-wait-until": "1.7.1", esbuild: "^0.20.0", eslint: "8.56.0", "eslint-config-airbnb-base": "15.0.0", "eslint-config-prettier": "9.1.0", "eslint-plugin-cypress": "2.15.1", "eslint-plugin-import": "2.29.1", husky: "^9.0.7", leaflet: "1.9.3", "lint-staged": "^15.2.1", prettier: "3.2.4", "prosthetic-hand": "1.3.1", "ts-node": "^10.9.2" }, peerDependencies: { leaflet: "^1.2.0" }, scripts: { start: "pnpm run dev", dev: "cross-env DEV=true ts-node bundle.mjs", build: "ts-node bundle.mjs", test: "cypress run", cypress: "cypress open", prepare: "pnpm run build && husky", "eslint-check": "eslint --print-config . | eslint-config-prettier-check", eslint: 'eslint "{src,cypress,demo}/**/*.js" --fix ', prettier: 'prettier --write "{src,cypress,demo}/**/*.{js,css}" --log-level=warn', lint: "pnpm run eslint && pnpm run prettier" }, repository: { type: "git", url: "git://github.com/geoman-io/leaflet-geoman.git" }, author: { name: "Geoman.io", email: "sales@geoman.io", url: "http://geoman.io" }, license: "MIT", bugs: { url: "https://github.com/geoman-io/leaflet-geoman/issues" }, homepage: "https://geoman.io", prettier: { trailingComma: "es5", tabWidth: 2, semi: true, singleQuote: true }, "lint-staged": { "*.js": 'eslint "{src,cypress,demo}/**/*.js" --fix', "*.{js,css,md}": 'prettier --write "{src,cypress,demo}/**/*.{js,css}"' } };
  var Pi2 = xt(Ne2());
  var Ga2 = { tooltips: { placeMarker: "Click to place marker", firstVertex: "Click to place first vertex", continueLine: "Click to continue drawing", finishLine: "Click any existing marker to finish", finishPoly: "Click first marker to finish", finishRect: "Click to finish", startCircle: "Click to place circle center", finishCircle: "Click to finish circle", placeCircleMarker: "Click to place circle marker", placeText: "Click to place text", selectFirstLayerFor: "Select first layer for {action}", selectSecondLayerFor: "Select second layer for {action}" }, actions: { finish: "Finish", cancel: "Cancel", removeLastVertex: "Remove Last Vertex" }, buttonTitles: { drawMarkerButton: "Draw Marker", drawPolyButton: "Draw Polygons", drawLineButton: "Draw Polyline", drawCircleButton: "Draw Circle", drawRectButton: "Draw Rectangle", editButton: "Edit Layers", dragButton: "Drag Layers", cutButton: "Cut Layers", deleteButton: "Remove Layers", drawCircleMarkerButton: "Draw Circle Marker", snappingButton: "Snap dragged marker to other layers and vertices", pinningButton: "Pin shared vertices together", rotateButton: "Rotate Layers", drawTextButton: "Draw Text", scaleButton: "Scale Layers", autoTracingButton: "Auto trace Line", snapGuidesButton: "Show SnapGuides", unionButton: "Union layers", differenceButton: "Subtract layers" }, measurements: { totalLength: "Length", segmentLength: "Segment length", area: "Area", radius: "Radius", perimeter: "Perimeter", height: "Height", width: "Width", coordinates: "Position", coordinatesMarker: "Position Marker" } };
  var qa2 = { tooltips: { placeMarker: "Platziere den Marker mit Klick", firstVertex: "Platziere den ersten Marker mit Klick", continueLine: "Klicke, um weiter zu zeichnen", finishLine: "Beende mit Klick auf existierenden Marker", finishPoly: "Beende mit Klick auf ersten Marker", finishRect: "Beende mit Klick", startCircle: "Platziere das Kreiszentrum mit Klick", finishCircle: "Beende den Kreis mit Klick", placeCircleMarker: "Platziere den Kreismarker mit Klick", placeText: "Platziere den Text mit Klick" }, actions: { finish: "Beenden", cancel: "Abbrechen", removeLastVertex: "Letzten Vertex löschen" }, buttonTitles: { drawMarkerButton: "Marker zeichnen", drawPolyButton: "Polygon zeichnen", drawLineButton: "Polyline zeichnen", drawCircleButton: "Kreis zeichnen", drawRectButton: "Rechteck zeichnen", editButton: "Layer editieren", dragButton: "Layer bewegen", cutButton: "Layer schneiden", deleteButton: "Layer löschen", drawCircleMarkerButton: "Kreismarker zeichnen", snappingButton: "Bewegter Layer an andere Layer oder Vertexe einhacken", pinningButton: "Vertexe an der gleichen Position verknüpfen", rotateButton: "Layer drehen", drawTextButton: "Text zeichnen", scaleButton: "Layer skalieren", autoTracingButton: "Linie automatisch nachzeichen" }, measurements: { totalLength: "Länge", segmentLength: "Segment Länge", area: "Fläche", radius: "Radius", perimeter: "Umfang", height: "Höhe", width: "Breite", coordinates: "Position", coordinatesMarker: "Position Marker" } };
  var Na2 = { tooltips: { placeMarker: "Clicca per posizionare un Marker", firstVertex: "Clicca per posizionare il primo vertice", continueLine: "Clicca per continuare a disegnare", finishLine: "Clicca qualsiasi marker esistente per terminare", finishPoly: "Clicca il primo marker per terminare", finishRect: "Clicca per terminare", startCircle: "Clicca per posizionare il punto centrale del cerchio", finishCircle: "Clicca per terminare il cerchio", placeCircleMarker: "Clicca per posizionare un Marker del cherchio" }, actions: { finish: "Termina", cancel: "Annulla", removeLastVertex: "Rimuovi l'ultimo vertice" }, buttonTitles: { drawMarkerButton: "Disegna Marker", drawPolyButton: "Disegna Poligoni", drawLineButton: "Disegna Polilinea", drawCircleButton: "Disegna Cerchio", drawRectButton: "Disegna Rettangolo", editButton: "Modifica Livelli", dragButton: "Sposta Livelli", cutButton: "Ritaglia Livelli", deleteButton: "Elimina Livelli", drawCircleMarkerButton: "Disegna Marker del Cerchio", snappingButton: "Snap ha trascinato il pennarello su altri strati e vertici", pinningButton: "Pin condiviso vertici insieme", rotateButton: "Ruota livello" } };
  var za2 = { tooltips: { placeMarker: "Klik untuk menempatkan marker", firstVertex: "Klik untuk menempatkan vertex pertama", continueLine: "Klik untuk meneruskan digitasi", finishLine: "Klik pada sembarang marker yang ada untuk mengakhiri", finishPoly: "Klik marker pertama untuk mengakhiri", finishRect: "Klik untuk mengakhiri", startCircle: "Klik untuk menempatkan titik pusat lingkaran", finishCircle: "Klik untuk mengakhiri lingkaran", placeCircleMarker: "Klik untuk menempatkan penanda lingkarann" }, actions: { finish: "Selesai", cancel: "Batal", removeLastVertex: "Hilangkan Vertex Terakhir" }, buttonTitles: { drawMarkerButton: "Digitasi Marker", drawPolyButton: "Digitasi Polygon", drawLineButton: "Digitasi Polyline", drawCircleButton: "Digitasi Lingkaran", drawRectButton: "Digitasi Segi Empat", editButton: "Edit Layer", dragButton: "Geser Layer", cutButton: "Potong Layer", deleteButton: "Hilangkan Layer", drawCircleMarkerButton: "Digitasi Penanda Lingkaran", snappingButton: "Jepretkan penanda yang ditarik ke lapisan dan simpul lain", pinningButton: "Sematkan simpul bersama bersama", rotateButton: "Putar lapisan" } };
  var Fa2 = { tooltips: { placeMarker: "Adaugă un punct", firstVertex: "Apasă aici pentru a adăuga primul Vertex", continueLine: "Apasă aici pentru a continua desenul", finishLine: "Apasă pe orice obiect pentru a finisa desenul", finishPoly: "Apasă pe primul obiect pentru a finisa", finishRect: "Apasă pentru a finisa", startCircle: "Apasă pentru a desena un cerc", finishCircle: "Apasă pentru a finisa un cerc", placeCircleMarker: "Adaugă un punct" }, actions: { finish: "Termină", cancel: "Anulează", removeLastVertex: "Șterge ultimul Vertex" }, buttonTitles: { drawMarkerButton: "Adaugă o bulină", drawPolyButton: "Desenează un poligon", drawLineButton: "Desenează o linie", drawCircleButton: "Desenează un cerc", drawRectButton: "Desenează un dreptunghi", editButton: "Editează straturile", dragButton: "Mută straturile", cutButton: "Taie straturile", deleteButton: "Șterge straturile", drawCircleMarkerButton: "Desenează marcatorul cercului", snappingButton: "Fixați marcatorul glisat pe alte straturi și vârfuri", pinningButton: "Fixați vârfurile partajate împreună", rotateButton: "Rotiți stratul" } };
  var Va2 = { tooltips: { placeMarker: "Нажмите, чтобы нанести маркер", firstVertex: "Нажмите, чтобы нанести первый объект", continueLine: "Нажмите, чтобы продолжить рисование", finishLine: "Нажмите любой существующий маркер для завершения", finishPoly: "Выберите первую точку, чтобы закончить", finishRect: "Нажмите, чтобы закончить", startCircle: "Нажмите, чтобы добавить центр круга", finishCircle: "Нажмите, чтобы задать радиус", placeCircleMarker: "Нажмите, чтобы нанести круговой маркер" }, actions: { finish: "Завершить", cancel: "Отменить", removeLastVertex: "Отменить последнее действие" }, buttonTitles: { drawMarkerButton: "Добавить маркер", drawPolyButton: "Рисовать полигон", drawLineButton: "Рисовать кривую", drawCircleButton: "Рисовать круг", drawRectButton: "Рисовать прямоугольник", editButton: "Редактировать слой", dragButton: "Перенести слой", cutButton: "Вырезать слой", deleteButton: "Удалить слой", drawCircleMarkerButton: "Добавить круговой маркер", snappingButton: "Привязать перетаскиваемый маркер к другим слоям и вершинам", pinningButton: "Связать общие точки вместе", rotateButton: "Поворот слоя" } };
  var Ua2 = { tooltips: { placeMarker: "Presiona para colocar un marcador", firstVertex: "Presiona para colocar el primer vértice", continueLine: "Presiona para continuar dibujando", finishLine: "Presiona cualquier marcador existente para finalizar", finishPoly: "Presiona el primer marcador para finalizar", finishRect: "Presiona para finalizar", startCircle: "Presiona para colocar el centro del círculo", finishCircle: "Presiona para finalizar el círculo", placeCircleMarker: "Presiona para colocar un marcador de círculo" }, actions: { finish: "Finalizar", cancel: "Cancelar", removeLastVertex: "Eliminar último vértice" }, buttonTitles: { drawMarkerButton: "Dibujar Marcador", drawPolyButton: "Dibujar Polígono", drawLineButton: "Dibujar Línea", drawCircleButton: "Dibujar Círculo", drawRectButton: "Dibujar Rectángulo", editButton: "Editar Capas", dragButton: "Arrastrar Capas", cutButton: "Cortar Capas", deleteButton: "Eliminar Capas", drawCircleMarkerButton: "Dibujar Marcador de Círculo", snappingButton: "El marcador de Snap arrastrado a otras capas y vértices", pinningButton: "Fijar juntos los vértices compartidos", rotateButton: "Rotar capa" } };
  var ja2 = { tooltips: { placeMarker: "Klik om een marker te plaatsen", firstVertex: "Klik om het eerste punt te plaatsen", continueLine: "Klik om te blijven tekenen", finishLine: "Klik op een bestaand punt om te beëindigen", finishPoly: "Klik op het eerst punt om te beëindigen", finishRect: "Klik om te beëindigen", startCircle: "Klik om het middelpunt te plaatsen", finishCircle: "Klik om de cirkel te beëindigen", placeCircleMarker: "Klik om een marker te plaatsen" }, actions: { finish: "Bewaar", cancel: "Annuleer", removeLastVertex: "Verwijder laatste punt" }, buttonTitles: { drawMarkerButton: "Plaats Marker", drawPolyButton: "Teken een vlak", drawLineButton: "Teken een lijn", drawCircleButton: "Teken een cirkel", drawRectButton: "Teken een vierkant", editButton: "Bewerk", dragButton: "Verplaats", cutButton: "Knip", deleteButton: "Verwijder", drawCircleMarkerButton: "Plaats Marker", snappingButton: "Snap gesleepte marker naar andere lagen en hoekpunten", pinningButton: "Speld gedeelde hoekpunten samen", rotateButton: "Laag roteren" } };
  var Ka2 = { tooltips: { placeMarker: "Cliquez pour placer un marqueur", firstVertex: "Cliquez pour placer le premier sommet", continueLine: "Cliquez pour continuer à dessiner", finishLine: "Cliquez sur n'importe quel marqueur pour terminer", finishPoly: "Cliquez sur le premier marqueur pour terminer", finishRect: "Cliquez pour terminer", startCircle: "Cliquez pour placer le centre du cercle", finishCircle: "Cliquez pour finir le cercle", placeCircleMarker: "Cliquez pour placer le marqueur circulaire" }, actions: { finish: "Terminer", cancel: "Annuler", removeLastVertex: "Retirer le dernier sommet" }, buttonTitles: { drawMarkerButton: "Placer des marqueurs", drawPolyButton: "Dessiner des polygones", drawLineButton: "Dessiner des polylignes", drawCircleButton: "Dessiner un cercle", drawRectButton: "Dessiner un rectangle", editButton: "Éditer des calques", dragButton: "Déplacer des calques", cutButton: "Couper des calques", deleteButton: "Supprimer des calques", drawCircleMarkerButton: "Dessiner un marqueur circulaire", snappingButton: "Glisser le marqueur vers d'autres couches et sommets", pinningButton: "Épingler ensemble les sommets partagés", rotateButton: "Tourner des calques" } };
  var Ha2 = { tooltips: { placeMarker: "单击放置标记", firstVertex: "单击放置首个顶点", continueLine: "单击继续绘制", finishLine: "单击任何存在的标记以完成", finishPoly: "单击第一个标记以完成", finishRect: "单击完成", startCircle: "单击放置圆心", finishCircle: "单击完成圆形", placeCircleMarker: "点击放置圆形标记" }, actions: { finish: "完成", cancel: "取消", removeLastVertex: "移除最后的顶点" }, buttonTitles: { drawMarkerButton: "绘制标记", drawPolyButton: "绘制多边形", drawLineButton: "绘制线段", drawCircleButton: "绘制圆形", drawRectButton: "绘制长方形", editButton: "编辑图层", dragButton: "拖拽图层", cutButton: "剪切图层", deleteButton: "删除图层", drawCircleMarkerButton: "画圆圈标记", snappingButton: "将拖动的标记捕捉到其他图层和顶点", pinningButton: "将共享顶点固定在一起", rotateButton: "旋转图层" } };
  var Xa2 = { tooltips: { placeMarker: "單擊放置標記", firstVertex: "單擊放置第一個頂點", continueLine: "單擊繼續繪製", finishLine: "單擊任何存在的標記以完成", finishPoly: "單擊第一個標記以完成", finishRect: "單擊完成", startCircle: "單擊放置圓心", finishCircle: "單擊完成圓形", placeCircleMarker: "點擊放置圓形標記" }, actions: { finish: "完成", cancel: "取消", removeLastVertex: "移除最後一個頂點" }, buttonTitles: { drawMarkerButton: "放置標記", drawPolyButton: "繪製多邊形", drawLineButton: "繪製線段", drawCircleButton: "繪製圓形", drawRectButton: "繪製方形", editButton: "編輯圖形", dragButton: "移動圖形", cutButton: "裁切圖形", deleteButton: "刪除圖形", drawCircleMarkerButton: "畫圓圈標記", snappingButton: "將拖動的標記對齊到其他圖層和頂點", pinningButton: "將共享頂點固定在一起", rotateButton: "旋轉圖形" } };
  var Ya2 = { tooltips: { placeMarker: "Clique para posicionar o marcador", firstVertex: "Clique para posicionar o primeiro vértice", continueLine: "Clique para continuar desenhando", finishLine: "Clique em qualquer marcador existente para finalizar", finishPoly: "Clique no primeiro marcador para finalizar", finishRect: "Clique para finalizar", startCircle: "Clique para posicionar o centro do círculo", finishCircle: "Clique para finalizar o círculo", placeCircleMarker: "Clique para posicionar o marcador circular", placeText: "Clique para inserir texto" }, actions: { finish: "Finalizar", cancel: "Cancelar", removeLastVertex: "Remover último vértice" }, buttonTitles: { drawMarkerButton: "Desenhar Marcador", drawPolyButton: "Desenhar Polígonos", drawLineButton: "Desenhar Linha Poligonal", drawCircleButton: "Desenhar Círculo", drawRectButton: "Desenhar Retângulo", editButton: "Editar Camadas", dragButton: "Arrastar Camadas", cutButton: "Recortar Camadas", deleteButton: "Remover Camadas", drawCircleMarkerButton: "Desenhar Marcador de Círculo", snappingButton: "Ajustar marcador arrastado a outras camadas e vértices", pinningButton: "Unir vértices compartilhados", rotateButton: "Rotacionar Camadas", drawTextButton: "Desenhar Texto", scaleButton: "Redimensionar Camadas", autoTracingButton: "Traçado Automático de Linha" }, measurements: { totalLength: "Comprimento", segmentLength: "Comprimento do Segmento", area: "Área", radius: "Raio", perimeter: "Perímetro", height: "Altura", width: "Largura", coordinates: "Posição", coordinatesMarker: "Marcador de Posição" } };
  var Ja2 = { tooltips: { placeMarker: "Clique para colocar marcador", firstVertex: "Clique para colocar primeiro vértice", continueLine: "Clique para continuar a desenhar", finishLine: "Clique num marcador existente para terminar", finishPoly: "Clique no primeiro marcador para terminar", finishRect: "Clique para terminar", startCircle: "Clique para colocar o centro do círculo", finishCircle: "Clique para terminar o círculo", placeCircleMarker: "Clique para colocar marcador de círculo", placeText: "Clique para colocar texto" }, actions: { finish: "Terminar", cancel: "Cancelar", removeLastVertex: "Remover Último Vértice" }, buttonTitles: { drawMarkerButton: "Desenhar Marcador", drawPolyButton: "Desenhar Polígonos", drawLineButton: "Desenhar Polilinha", drawCircleButton: "Desenhar Círculo", drawRectButton: "Desenhar Retângulo", editButton: "Editar Camadas", dragButton: "Arrastar Camadas", cutButton: "Cortar Camadas", deleteButton: "Remover Camadas", drawCircleMarkerButton: "Desenhar Marcador de Círculo", snappingButton: "Ajustar marcador arrastado a outras camadas e vértices", pinningButton: "Unir vértices partilhados", rotateButton: "Rodar Camadas", drawTextButton: "Desenhar Texto", scaleButton: "Escalar Camadas", autoTracingButton: "Traçado Automático de Linha" }, measurements: { totalLength: "Comprimento", segmentLength: "Comprimento do Segmento", area: "Área", radius: "Raio", perimeter: "Perímetro", height: "Altura", width: "Largura", coordinates: "Posição", coordinatesMarker: "Marcador de Posição" } };
  var $a2 = { tooltips: { placeMarker: "Kliknij, aby umieścić znacznik", firstVertex: "Kliknij, aby umieścić pierwszy wierzchołek", continueLine: "Kliknij, aby kontynuować rysowanie", finishLine: "Kliknij dowolny istniejący znacznik, aby zakończyć", finishPoly: "Kliknij pierwszy znacznik, aby zakończyć", finishRect: "Kliknij, aby zakończyć", startCircle: "Kliknij, aby umieścić środek okręgu", finishCircle: "Kliknij, aby zakończyć okrąg", placeCircleMarker: "Kliknij, aby umieścić znacznik okręgu", placeText: "Kliknij, aby umieścić tekst" }, actions: { finish: "Zakończ", cancel: "Anuluj", removeLastVertex: "Usuń ostatni wierzchołek" }, buttonTitles: { drawMarkerButton: "Rysuj znacznik", drawPolyButton: "Rysuj wielokąt", drawLineButton: "Rysuj linię", drawCircleButton: "Rysuj okrąg", drawRectButton: "Rysuj prostokąt", editButton: "Edytuj warstwy", dragButton: "Przeciągnij warstwy", cutButton: "Wytnij warstwy", deleteButton: "Usuń warstwy", drawCircleMarkerButton: "Rysuj znacznik okrągły", snappingButton: "Przyciągnij przenoszony znacznik do innych warstw i wierzchołków", pinningButton: "Przypnij wspólne wierzchołki razem", rotateButton: "Obróć warstwy", drawTextButton: "Rysuj tekst", scaleButton: "Skaluj warstwy", autoTracingButton: "Automatyczne śledzenie linii" }, measurements: { totalLength: "Długość", segmentLength: "Długość odcinka", area: "Obszar", radius: "Promień", perimeter: "Obwód", height: "Wysokość", width: "Szerokość", coordinates: "Pozycja", coordinatesMarker: "Znacznik pozycji" } };
  var Za2 = { tooltips: { placeMarker: "Klicka för att placera markör", firstVertex: "Klicka för att placera första hörnet", continueLine: "Klicka för att fortsätta rita", finishLine: "Klicka på en existerande punkt för att slutföra", finishPoly: "Klicka på den första punkten för att slutföra", finishRect: "Klicka för att slutföra", startCircle: "Klicka för att placera cirkelns centrum", finishCircle: "Klicka för att slutföra cirkeln", placeCircleMarker: "Klicka för att placera cirkelmarkör" }, actions: { finish: "Slutför", cancel: "Avbryt", removeLastVertex: "Ta bort sista hörnet" }, buttonTitles: { drawMarkerButton: "Rita Markör", drawPolyButton: "Rita Polygoner", drawLineButton: "Rita Linje", drawCircleButton: "Rita Cirkel", drawRectButton: "Rita Rektangel", editButton: "Redigera Lager", dragButton: "Dra Lager", cutButton: "Klipp i Lager", deleteButton: "Ta bort Lager", drawCircleMarkerButton: "Rita Cirkelmarkör", snappingButton: "Snäpp dra markören till andra lager och hörn", pinningButton: "Fäst delade hörn tillsammans", rotateButton: "Rotera lagret" } };
  var Wa2 = { tooltips: { placeMarker: "Κάντε κλικ για να τοποθετήσετε Δείκτη", firstVertex: "Κάντε κλικ για να τοποθετήσετε το πρώτο σημείο", continueLine: "Κάντε κλικ για να συνεχίσετε να σχεδιάζετε", finishLine: "Κάντε κλικ σε οποιονδήποτε υπάρχον σημείο για να ολοκληρωθεί", finishPoly: "Κάντε κλικ στο πρώτο σημείο για να τελειώσετε", finishRect: "Κάντε κλικ για να τελειώσετε", startCircle: "Κάντε κλικ για να τοποθετήσετε κέντρο Κύκλου", finishCircle: "Κάντε κλικ για να ολοκληρώσετε τον Κύκλο", placeCircleMarker: "Κάντε κλικ για να τοποθετήσετε Κυκλικό Δείκτη" }, actions: { finish: "Τέλος", cancel: "Ακύρωση", removeLastVertex: "Κατάργηση τελευταίου σημείου" }, buttonTitles: { drawMarkerButton: "Σχεδίαση Δείκτη", drawPolyButton: "Σχεδίαση Πολυγώνου", drawLineButton: "Σχεδίαση Γραμμής", drawCircleButton: "Σχεδίαση Κύκλου", drawRectButton: "Σχεδίαση Ορθογωνίου", editButton: "Επεξεργασία Επιπέδων", dragButton: "Μεταφορά Επιπέδων", cutButton: "Αποκοπή Επιπέδων", deleteButton: "Κατάργηση Επιπέδων", drawCircleMarkerButton: "Σχεδίαση Κυκλικού Δείκτη", snappingButton: "Προσκόλληση του Δείκτη μεταφοράς σε άλλα Επίπεδα και Κορυφές", pinningButton: "Περικοπή κοινών κορυφών μαζί", rotateButton: "Περιστρέψτε το στρώμα" } };
  var Qa2 = { tooltips: { placeMarker: "Kattintson a jelölő elhelyezéséhez", firstVertex: "Kattintson az első pont elhelyezéséhez", continueLine: "Kattintson a következő pont elhelyezéséhez", finishLine: "A befejezéshez kattintson egy meglévő pontra", finishPoly: "A befejezéshez kattintson az első pontra", finishRect: "Kattintson a befejezéshez", startCircle: "Kattintson a kör középpontjának elhelyezéséhez", finishCircle: "Kattintson a kör befejezéséhez", placeCircleMarker: "Kattintson a körjelölő elhelyezéséhez" }, actions: { finish: "Befejezés", cancel: "Mégse", removeLastVertex: "Utolsó pont eltávolítása" }, buttonTitles: { drawMarkerButton: "Jelölő rajzolása", drawPolyButton: "Poligon rajzolása", drawLineButton: "Vonal rajzolása", drawCircleButton: "Kör rajzolása", drawRectButton: "Négyzet rajzolása", editButton: "Elemek szerkesztése", dragButton: "Elemek mozgatása", cutButton: "Elemek vágása", deleteButton: "Elemek törlése", drawCircleMarkerButton: "Kör jelölő rajzolása", snappingButton: "Kapcsolja a jelöltőt másik elemhez vagy ponthoz", pinningButton: "Közös pontok összekötése", rotateButton: "Fólia elforgatása" } };
  var to = { tooltips: { placeMarker: "Tryk for at placere en markør", firstVertex: "Tryk for at placere det første punkt", continueLine: "Tryk for at fortsætte linjen", finishLine: "Tryk på et eksisterende punkt for at afslutte", finishPoly: "Tryk på det første punkt for at afslutte", finishRect: "Tryk for at afslutte", startCircle: "Tryk for at placere cirklens center", finishCircle: "Tryk for at afslutte cirklen", placeCircleMarker: "Tryk for at placere en cirkelmarkør" }, actions: { finish: "Afslut", cancel: "Afbryd", removeLastVertex: "Fjern sidste punkt" }, buttonTitles: { drawMarkerButton: "Placer markør", drawPolyButton: "Tegn polygon", drawLineButton: "Tegn linje", drawCircleButton: "Tegn cirkel", drawRectButton: "Tegn firkant", editButton: "Rediger", dragButton: "Træk", cutButton: "Klip", deleteButton: "Fjern", drawCircleMarkerButton: "Tegn cirkelmarkør", snappingButton: "Fastgør trukket markør til andre elementer", pinningButton: "Sammenlæg delte elementer", rotateButton: "Roter laget" } };
  var eo = { tooltips: { placeMarker: "Klikk for å plassere punkt", firstVertex: "Klikk for å plassere første punkt", continueLine: "Klikk for å tegne videre", finishLine: "Klikk på et eksisterende punkt for å fullføre", finishPoly: "Klikk første punkt for å fullføre", finishRect: "Klikk for å fullføre", startCircle: "Klikk for å sette sirkel midtpunkt", finishCircle: "Klikk for å fullføre sirkel", placeCircleMarker: "Klikk for å plassere sirkel", placeText: "Klikk for å plassere tekst" }, actions: { finish: "Fullfør", cancel: "Kanseller", removeLastVertex: "Fjern forrige punkt" }, buttonTitles: { drawMarkerButton: "Tegn punkt", drawPolyButton: "Tegn flate", drawLineButton: "Tegn linje", drawCircleButton: "Tegn sirkel", drawRectButton: "Tegn rektangel", editButton: "Rediger objekter", dragButton: "Dra objekter", cutButton: "Kutt objekter", deleteButton: "Fjern objekter", drawCircleMarkerButton: "Tegn sirkel-punkt", snappingButton: "Fest dratt punkt til andre objekter og punkt", pinningButton: "Pin delte punkter sammen", rotateButton: "Rotér objekter", drawTextButton: "Tegn tekst", scaleButton: "Skalér objekter", autoTracingButton: "Automatisk sporing av linje" }, measurements: { totalLength: "Lengde", segmentLength: "Segmentlengde", area: "Område", radius: "Radius", perimeter: "Omriss", height: "Høyde", width: "Bredde", coordinates: "Posisjon", coordinatesMarker: "Posisjonsmarkør" } };
  var io = { tooltips: { placeMarker: "کلیک برای جانمایی نشان", firstVertex: "کلیک برای رسم اولین رأس", continueLine: "کلیک برای ادامه رسم", finishLine: "کلیک روی هر نشان موجود برای پایان", finishPoly: "کلیک روی اولین نشان برای پایان", finishRect: "کلیک برای پایان", startCircle: "کلیک برای رسم مرکز دایره", finishCircle: "کلیک برای پایان رسم دایره", placeCircleMarker: "کلیک برای رسم نشان دایره", placeText: "کلیک برای نوشتن متن" }, actions: { finish: "پایان", cancel: "لفو", removeLastVertex: "حذف آخرین رأس" }, buttonTitles: { drawMarkerButton: "درج نشان", drawPolyButton: "رسم چندضلعی", drawLineButton: "رسم خط", drawCircleButton: "رسم دایره", drawRectButton: "رسم چهارضلعی", editButton: "ویرایش لایه‌ها", dragButton: "جابجایی لایه‌ها", cutButton: "برش لایه‌ها", deleteButton: "حذف لایه‌ها", drawCircleMarkerButton: "رسم نشان دایره", snappingButton: "نشانگر را به لایه‌ها و رئوس دیگر بکشید", pinningButton: "رئوس مشترک را با هم پین کنید", rotateButton: "چرخش لایه", drawTextButton: "رسم متن", scaleButton: "مقیاس‌گذاری", autoTracingButton: "ردیاب خودکار" }, measurements: { totalLength: "طول", segmentLength: "طول بخش", area: "ناحیه", radius: "شعاع", perimeter: "محیط", height: "ارتفاع", width: "عرض", coordinates: "موقعیت", coordinatesMarker: "موقعیت نشان" } };
  var ro = { tooltips: { placeMarker: "Натисніть, щоб нанести маркер", firstVertex: "Натисніть, щоб нанести першу вершину", continueLine: "Натисніть, щоб продовжити малювати", finishLine: "Натисніть будь-який існуючий маркер для завершення", finishPoly: "Виберіть перший маркер, щоб завершити", finishRect: "Натисніть, щоб завершити", startCircle: "Натисніть, щоб додати центр кола", finishCircle: "Натисніть, щоб завершити коло", placeCircleMarker: "Натисніть, щоб нанести круговий маркер" }, actions: { finish: "Завершити", cancel: "Відмінити", removeLastVertex: "Видалити попередню вершину" }, buttonTitles: { drawMarkerButton: "Малювати маркер", drawPolyButton: "Малювати полігон", drawLineButton: "Малювати криву", drawCircleButton: "Малювати коло", drawRectButton: "Малювати прямокутник", editButton: "Редагувати шари", dragButton: "Перенести шари", cutButton: "Вирізати шари", deleteButton: "Видалити шари", drawCircleMarkerButton: "Малювати круговий маркер", snappingButton: "Прив’язати перетягнутий маркер до інших шарів та вершин", pinningButton: "Зв'язати спільні вершини разом", rotateButton: "Повернути шар" } };
  var no = { tooltips: { placeMarker: "İşaretçi yerleştirmek için tıklayın", firstVertex: "İlk tepe noktasını yerleştirmek için tıklayın", continueLine: "Çizime devam etmek için tıklayın", finishLine: "Bitirmek için mevcut herhangi bir işaretçiyi tıklayın", finishPoly: "Bitirmek için ilk işaretçiyi tıklayın", finishRect: "Bitirmek için tıklayın", startCircle: "Daire merkezine yerleştirmek için tıklayın", finishCircle: "Daireyi bitirmek için tıklayın", placeCircleMarker: "Daire işaretçisi yerleştirmek için tıklayın" }, actions: { finish: "Bitir", cancel: "İptal", removeLastVertex: "Son köşeyi kaldır" }, buttonTitles: { drawMarkerButton: "Çizim İşaretçisi", drawPolyButton: "Çokgenler çiz", drawLineButton: "Çoklu çizgi çiz", drawCircleButton: "Çember çiz", drawRectButton: "Dikdörtgen çiz", editButton: "Katmanları düzenle", dragButton: "Katmanları sürükle", cutButton: "Katmanları kes", deleteButton: "Katmanları kaldır", drawCircleMarkerButton: "Daire işaretçisi çiz", snappingButton: "Sürüklenen işaretçiyi diğer katmanlara ve köşelere yapıştır", pinningButton: "Paylaşılan köşeleri birbirine sabitle", rotateButton: "Katmanı döndür" } };
  var so = { tooltips: { placeMarker: "Kliknutím vytvoříte značku", firstVertex: "Kliknutím vytvoříte první objekt", continueLine: "Kliknutím pokračujte v kreslení", finishLine: "Kliknutí na libovolnou existující značku pro dokončení", finishPoly: "Vyberte první bod pro dokončení", finishRect: "Klikněte pro dokončení", startCircle: "Kliknutím přidejte střed kruhu", finishCircle: "Нажмите, чтобы задать радиус", placeCircleMarker: "Kliknutím nastavte poloměr" }, actions: { finish: "Dokončit", cancel: "Zrušit", removeLastVertex: "Zrušit poslední akci" }, buttonTitles: { drawMarkerButton: "Přidat značku", drawPolyButton: "Nakreslit polygon", drawLineButton: "Nakreslit křivku", drawCircleButton: "Nakreslit kruh", drawRectButton: "Nakreslit obdélník", editButton: "Upravit vrstvu", dragButton: "Přeneste vrstvu", cutButton: "Vyjmout vrstvu", deleteButton: "Smazat vrstvu", drawCircleMarkerButton: "Přidat kruhovou značku", snappingButton: "Navázat tažnou značku k dalším vrstvám a vrcholům", pinningButton: "Spojit společné body dohromady", rotateButton: "Otočte vrstvu" } };
  var ao = { tooltips: { placeMarker: "クリックしてマーカーを配置", firstVertex: "クリックして最初の頂点を配置", continueLine: "クリックして描画を続ける", finishLine: "任意のマーカーをクリックして終了", finishPoly: "最初のマーカーをクリックして終了", finishRect: "クリックして終了", startCircle: "クリックして円の中心を配置", finishCircle: "クリックして円の描画を終了", placeCircleMarker: "クリックして円マーカーを配置", placeText: "クリックしてテキストを配置" }, actions: { finish: "終了", cancel: "キャンセル", removeLastVertex: "最後の頂点を削除" }, buttonTitles: { drawMarkerButton: "マーカーを描画", drawPolyButton: "ポリゴンを描画", drawLineButton: "折れ線を描画", drawCircleButton: "円を描画", drawRectButton: "矩形を描画", editButton: "レイヤーを編集", dragButton: "レイヤーをドラッグ", cutButton: "レイヤーを切り取り", deleteButton: "レイヤーを削除", drawCircleMarkerButton: "円マーカーを描画", snappingButton: "ドラッグしたマーカーを他のレイヤーや頂点にスナップする", pinningButton: "共有する頂点を同時に動かす", rotateButton: "レイヤーを回転", drawTextButton: "テキストを描画" } };
  var oo = { tooltips: { placeMarker: "Klikkaa asettaaksesi merkin", firstVertex: "Klikkaa asettaakseni ensimmäisen osuuden", continueLine: "Klikkaa jatkaaksesi piirtämistä", finishLine: "Klikkaa olemassa olevaa merkkiä lopettaaksesi", finishPoly: "Klikkaa ensimmäistä merkkiä lopettaaksesi", finishRect: "Klikkaa lopettaaksesi", startCircle: "Klikkaa asettaaksesi ympyrän keskipisteen", finishCircle: "Klikkaa lopettaaksesi ympyrän", placeCircleMarker: "Klikkaa asettaaksesi ympyrämerkin", placeText: "Klikkaa asettaaksesi tekstin" }, actions: { finish: "Valmis", cancel: "Peruuta", removeLastVertex: "Poista viimeinen osuus" }, buttonTitles: { drawMarkerButton: "Piirrä merkkejä", drawPolyButton: "Piirrä monikulmioita", drawLineButton: "Piirrä viivoja", drawCircleButton: "Piirrä ympyrä", drawRectButton: "Piirrä neliskulmioita", editButton: "Muokkaa", dragButton: "Siirrä", cutButton: "Leikkaa", deleteButton: "Poista", drawCircleMarkerButton: "Piirrä ympyrämerkki", snappingButton: "Kiinnitä siirrettävä merkki toisiin muotoihin", pinningButton: "Kiinnitä jaetut muodot yhteen", rotateButton: "Käännä", drawTextButton: "Piirrä tekstiä" } };
  var lo = { tooltips: { placeMarker: "마커 위치를 클릭하세요", firstVertex: "첫번째 꼭지점 위치을 클릭하세요", continueLine: "계속 그리려면 클릭하세요", finishLine: "끝내려면 기존 마커를 클릭하세요", finishPoly: "끝내려면 처음 마커를 클릭하세요", finishRect: "끝내려면 클릭하세요", startCircle: "원의 중심이 될 위치를 클릭하세요", finishCircle: "원을 끝내려면 클릭하세요", placeCircleMarker: "원 마커 위치를 클릭하세요", placeText: "텍스트 위치를 클릭하세요" }, actions: { finish: "끝내기", cancel: "취소", removeLastVertex: "마지막 꼭지점 제거" }, buttonTitles: { drawMarkerButton: "마커 그리기", drawPolyButton: "다각형 그리기", drawLineButton: "다각선 그리기", drawCircleButton: "원 그리기", drawRectButton: "직사각형 그리기", editButton: "레이어 편집하기", dragButton: "레이어 끌기", cutButton: "레이어 자르기", deleteButton: "레이어 제거하기", drawCircleMarkerButton: "원 마커 그리기", snappingButton: "잡아끈 마커를 다른 레이어 및 꼭지점에 들러붙게 하기", pinningButton: "공유 꼭지점을 함께 찍기", rotateButton: "레이어 회전하기", drawTextButton: "텍스트 그리기" } };
  var ho = { tooltips: { placeMarker: "Маркерди жайгаштыруу үчүн басыңыз", firstVertex: "Биринчи чокуну жайгаштырууну үчүн басыңыз", continueLine: "Сүрөт тартууну улантуу үчүн басыңыз", finishLine: "Аяктоо үчүн учурдагы маркерди басыңыз", finishPoly: "Бүтүрүү үчүн биринчи маркерди басыңыз", finishRect: "Бүтүрүү үчүн басыңыз", startCircle: "Айлананын борборун жайгаштырууну үчүн басыңыз", finishCircle: "Айлананы бүтүрүү үчүн басыңыз", placeCircleMarker: "Тегерек маркерди жайгаштыруу үчүн басыңыз", placeText: "Текстти жайгаштыруу үчүн басыңыз" }, actions: { finish: "Аягы", cancel: "Жок кылуу", removeLastVertex: "Акыркы чокуну өчүрүү" }, buttonTitles: { drawMarkerButton: "Маркерди чизуу", drawPolyButton: "Полигон чизуу", drawLineButton: "Полилиния чизуу", drawCircleButton: "Дайынды чизуу", drawRectButton: "Прямоугольник чизуу", editButton: "Слоопту түзөтүү", dragButton: "Слоопту карап сүйлөү", cutButton: "Слооптун башын кесүү", deleteButton: "Слооптун өчүрүү", drawCircleMarkerButton: "Дайынды маркерди чизуу", snappingButton: "Башка слооптордун жана вертекстердин арасына чекилдөө", pinningButton: "Бөлүшкөн вертекстерди бирге тутуштуруу", rotateButton: "Слооптун өзгөртүү", drawTextButton: "Текст чизуу", scaleButton: "Слооптун өлчөмүн өзгөртүү", autoTracingButton: "Автоматтык тизмеги чизуу" }, measurements: { totalLength: "Узундук", segmentLength: "Сегмент узундугу", area: "Аймак", radius: "Радиус", perimeter: "Периметр", height: "Диаметр", width: "Кенчилик", coordinates: "Координаттар", coordinatesMarker: "Маркердин координаттары" } };
  var Nt = { en: Ga2, de: qa2, it: Na2, id: za2, ro: Fa2, ru: Va2, es: Ua2, nl: ja2, fr: Ka2, pt_br: Ya2, pt_pt: Ja2, zh: Ha2, zh_tw: Xa2, pl: $a2, sv: Za2, el: Wa2, hu: Qa2, da: to, no: eo, fa: io, ua: ro, tr: no, cz: so, ja: ao, fi: oo, ko: lo, ky: ho };
  var mg2 = { _globalEditModeEnabled: false, enableGlobalEditMode(t2) {
    let e2 = { ...t2 };
    this._globalEditModeEnabled = true, this.Toolbar.toggleButton("editMode", this.globalEditModeEnabled()), L.PM.Utils.findLayers(this.map).forEach((r2) => {
      this._isRelevantForEdit(r2) && r2.pm.enable(e2);
    }), this.throttledReInitEdit || (this.throttledReInitEdit = L.Util.throttle(this.handleLayerAdditionInGlobalEditMode, 100, this)), this._addedLayersEdit = {}, this.map.on("layeradd", this._layerAddedEdit, this), this.map.on("layeradd", this.throttledReInitEdit, this), this._fireGlobalEditModeToggled(true);
  }, disableGlobalEditMode() {
    this._globalEditModeEnabled = false, L.PM.Utils.findLayers(this.map).forEach((e2) => {
      e2.pm.disable();
    }), this.map.off("layeradd", this._layerAddedEdit, this), this.map.off("layeradd", this.throttledReInitEdit, this), this.Toolbar.toggleButton("editMode", this.globalEditModeEnabled()), this._fireGlobalEditModeToggled(false);
  }, globalEditEnabled() {
    return this.globalEditModeEnabled();
  }, globalEditModeEnabled() {
    return this._globalEditModeEnabled;
  }, toggleGlobalEditMode(t2 = this.globalOptions) {
    this.globalEditModeEnabled() ? this.disableGlobalEditMode() : this.enableGlobalEditMode(t2);
  }, handleLayerAdditionInGlobalEditMode() {
    let t2 = this._addedLayersEdit;
    if (this._addedLayersEdit = {}, this.globalEditModeEnabled()) for (let e2 in t2) {
      let i = t2[e2];
      this._isRelevantForEdit(i) && i.pm.enable({ ...this.globalOptions });
    }
  }, _layerAddedEdit({ layer: t2 }) {
    this._addedLayersEdit[L.stamp(t2)] = t2;
  }, _isRelevantForEdit(t2) {
    return t2.pm && !(t2 instanceof L.LayerGroup) && (!L.PM.optIn && !t2.options.pmIgnore || L.PM.optIn && t2.options.pmIgnore === false) && !t2._pmTempLayer && t2.pm.options.allowEditing;
  } }, uo = mg2;
  var _g = { _globalDragModeEnabled: false, enableGlobalDragMode() {
    let t2 = L.PM.Utils.findLayers(this.map);
    this._globalDragModeEnabled = true, this._addedLayersDrag = {}, t2.forEach((e2) => {
      this._isRelevantForDrag(e2) && e2.pm.enableLayerDrag();
    }), this.throttledReInitDrag || (this.throttledReInitDrag = L.Util.throttle(this.reinitGlobalDragMode, 100, this)), this.map.on("layeradd", this._layerAddedDrag, this), this.map.on("layeradd", this.throttledReInitDrag, this), this.Toolbar.toggleButton("dragMode", this.globalDragModeEnabled()), this._fireGlobalDragModeToggled(true);
  }, disableGlobalDragMode() {
    let t2 = L.PM.Utils.findLayers(this.map);
    this._globalDragModeEnabled = false, t2.forEach((e2) => {
      e2.pm.disableLayerDrag();
    }), this.map.off("layeradd", this._layerAddedDrag, this), this.map.off("layeradd", this.throttledReInitDrag, this), this.Toolbar.toggleButton("dragMode", this.globalDragModeEnabled()), this._fireGlobalDragModeToggled(false);
  }, globalDragModeEnabled() {
    return !!this._globalDragModeEnabled;
  }, toggleGlobalDragMode() {
    this.globalDragModeEnabled() ? this.disableGlobalDragMode() : this.enableGlobalDragMode();
  }, reinitGlobalDragMode() {
    let t2 = this._addedLayersDrag;
    if (this._addedLayersDrag = {}, this.globalDragModeEnabled()) for (let e2 in t2) {
      let i = t2[e2];
      this._isRelevantForDrag(i) && i.pm.enableLayerDrag();
    }
  }, _layerAddedDrag({ layer: t2 }) {
    this._addedLayersDrag[L.stamp(t2)] = t2;
  }, _isRelevantForDrag(t2) {
    return t2.pm && !(t2 instanceof L.LayerGroup) && (!L.PM.optIn && !t2.options.pmIgnore || L.PM.optIn && t2.options.pmIgnore === false) && !t2._pmTempLayer && t2.pm.options.draggable;
  } }, co = _g;
  var yg2 = { _globalRemovalModeEnabled: false, enableGlobalRemovalMode() {
    this._globalRemovalModeEnabled = true, this.map.eachLayer((t2) => {
      this._isRelevantForRemoval(t2) && (t2.pm.enabled() && t2.pm.disable(), t2.on("click", this.removeLayer, this));
    }), this.throttledReInitRemoval || (this.throttledReInitRemoval = L.Util.throttle(this.handleLayerAdditionInGlobalRemovalMode, 100, this)), this._addedLayersRemoval = {}, this.map.on("layeradd", this._layerAddedRemoval, this), this.map.on("layeradd", this.throttledReInitRemoval, this), this.Toolbar.toggleButton("removalMode", this.globalRemovalModeEnabled()), this._fireGlobalRemovalModeToggled(true);
  }, disableGlobalRemovalMode() {
    this._globalRemovalModeEnabled = false, this.map.eachLayer((t2) => {
      t2.off("click", this.removeLayer, this);
    }), this.map.off("layeradd", this._layerAddedRemoval, this), this.map.off("layeradd", this.throttledReInitRemoval, this), this.Toolbar.toggleButton("removalMode", this.globalRemovalModeEnabled()), this._fireGlobalRemovalModeToggled(false);
  }, globalRemovalEnabled() {
    return this.globalRemovalModeEnabled();
  }, globalRemovalModeEnabled() {
    return !!this._globalRemovalModeEnabled;
  }, toggleGlobalRemovalMode() {
    this.globalRemovalModeEnabled() ? this.disableGlobalRemovalMode() : this.enableGlobalRemovalMode();
  }, removeLayer(t2) {
    let e2 = t2.target;
    this._isRelevantForRemoval(e2) && !e2.pm.dragging() && (e2.removeFrom(this.map.pm._getContainingLayer()), e2.remove(), e2 instanceof L.LayerGroup ? (this._fireRemoveLayerGroup(e2), this._fireRemoveLayerGroup(this.map, e2)) : (e2.pm._fireRemove(e2), e2.pm._fireRemove(this.map, e2)));
  }, _isRelevantForRemoval(t2) {
    return t2.pm && !(t2 instanceof L.LayerGroup) && (!L.PM.optIn && !t2.options.pmIgnore || L.PM.optIn && t2.options.pmIgnore === false) && !t2._pmTempLayer && t2.pm.options.allowRemoval;
  }, handleLayerAdditionInGlobalRemovalMode() {
    let t2 = this._addedLayersRemoval;
    if (this._addedLayersRemoval = {}, this.globalRemovalModeEnabled()) for (let e2 in t2) {
      let i = t2[e2];
      this._isRelevantForRemoval(i) && (i.pm.enabled() && i.pm.disable(), i.on("click", this.removeLayer, this));
    }
  }, _layerAddedRemoval({ layer: t2 }) {
    this._addedLayersRemoval[L.stamp(t2)] = t2;
  } }, po = yg2;
  var Lg2 = { _globalRotateModeEnabled: false, enableGlobalRotateMode() {
    this._globalRotateModeEnabled = true, L.PM.Utils.findLayers(this.map).filter((e2) => e2 instanceof L.Polyline).forEach((e2) => {
      this._isRelevantForRotate(e2) && e2.pm.enableRotate();
    }), this.throttledReInitRotate || (this.throttledReInitRotate = L.Util.throttle(this.handleLayerAdditionInGlobalRotateMode, 100, this)), this._addedLayersRotate = {}, this.map.on("layeradd", this._layerAddedRotate, this), this.map.on("layeradd", this.throttledReInitRotate, this), this.Toolbar.toggleButton("rotateMode", this.globalRotateModeEnabled()), this._fireGlobalRotateModeToggled();
  }, disableGlobalRotateMode() {
    this._globalRotateModeEnabled = false, L.PM.Utils.findLayers(this.map).filter((e2) => e2 instanceof L.Polyline).forEach((e2) => {
      e2.pm.disableRotate();
    }), this.map.off("layeradd", this._layerAddedRotate, this), this.map.off("layeradd", this.throttledReInitRotate, this), this.Toolbar.toggleButton("rotateMode", this.globalRotateModeEnabled()), this._fireGlobalRotateModeToggled();
  }, globalRotateModeEnabled() {
    return !!this._globalRotateModeEnabled;
  }, toggleGlobalRotateMode() {
    this.globalRotateModeEnabled() ? this.disableGlobalRotateMode() : this.enableGlobalRotateMode();
  }, _isRelevantForRotate(t2) {
    return t2.pm && t2 instanceof L.Polyline && !(t2 instanceof L.LayerGroup) && (!L.PM.optIn && !t2.options.pmIgnore || L.PM.optIn && t2.options.pmIgnore === false) && !t2._pmTempLayer && t2.pm.options.allowRotation;
  }, handleLayerAdditionInGlobalRotateMode() {
    let t2 = this._addedLayersRotate;
    if (this._addedLayersRotate = {}, this.globalRotateModeEnabled()) for (let e2 in t2) {
      let i = t2[e2];
      this._isRelevantForRemoval(i) && i.pm.enableRotate();
    }
  }, _layerAddedRotate({ layer: t2 }) {
    this._addedLayersRotate[L.stamp(t2)] = t2;
  } }, fo = Lg2;
  var go = xt(Ne2()), bg2 = { _fireDrawStart(t2 = "Draw", e2 = {}) {
    this.__fire(this._map, "pm:drawstart", { shape: this._shape, workingLayer: this._layer }, t2, e2);
  }, _fireDrawEnd(t2 = "Draw", e2 = {}) {
    this.__fire(this._map, "pm:drawend", { shape: this._shape }, t2, e2);
  }, _fireCreate(t2, e2 = "Draw", i = {}) {
    this.__fire(this._map, "pm:create", { shape: this._shape, marker: t2, layer: t2 }, e2, i);
  }, _fireCenterPlaced(t2 = "Draw", e2 = {}) {
    let i = t2 === "Draw" ? this._layer : void 0, r2 = t2 !== "Draw" ? this._layer : void 0;
    this.__fire(this._layer, "pm:centerplaced", { shape: this._shape, workingLayer: i, layer: r2, latlng: this._layer.getLatLng() }, t2, e2);
  }, _fireCut(t2, e2, i, r2 = "Draw", n2 = {}) {
    this.__fire(t2, "pm:cut", { shape: this._shape, layer: e2, originalLayer: i }, r2, n2);
  }, _fireEdit(t2 = this._layer, e2 = "Edit", i = {}) {
    this.__fire(t2, "pm:edit", { layer: this._layer, shape: this.getShape() }, e2, i);
  }, _fireEnable(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:enable", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireDisable(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:disable", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireUpdate(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:update", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireMarkerDragStart(t2, e2 = void 0, i = "Edit", r2 = {}) {
    this.__fire(this._layer, "pm:markerdragstart", { layer: this._layer, markerEvent: t2, shape: this.getShape(), indexPath: e2 }, i, r2);
  }, _fireMarkerDrag(t2, e2 = void 0, i = "Edit", r2 = {}) {
    this.__fire(this._layer, "pm:markerdrag", { layer: this._layer, markerEvent: t2, shape: this.getShape(), indexPath: e2 }, i, r2);
  }, _fireMarkerDragEnd(t2, e2 = void 0, i = void 0, r2 = "Edit", n2 = {}) {
    this.__fire(this._layer, "pm:markerdragend", { layer: this._layer, markerEvent: t2, shape: this.getShape(), indexPath: e2, intersectionReset: i }, r2, n2);
  }, _fireDragStart(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:dragstart", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireDrag(t2, e2 = "Edit", i = {}) {
    this.__fire(this._layer, "pm:drag", { ...t2, shape: this.getShape() }, e2, i);
  }, _fireDragEnd(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:dragend", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireDragEnable(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:dragenable", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireDragDisable(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:dragdisable", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireRemove(t2, e2 = t2, i = "Edit", r2 = {}) {
    this.__fire(t2, "pm:remove", { layer: e2, shape: this.getShape() }, i, r2);
  }, _fireVertexAdded(t2, e2, i, r2 = "Edit", n2 = {}) {
    this.__fire(this._layer, "pm:vertexadded", { layer: this._layer, workingLayer: this._layer, marker: t2, indexPath: e2, latlng: i, shape: this.getShape() }, r2, n2);
  }, _fireVertexRemoved(t2, e2, i = "Edit", r2 = {}) {
    this.__fire(this._layer, "pm:vertexremoved", { layer: this._layer, marker: t2, indexPath: e2, shape: this.getShape() }, i, r2);
  }, _fireVertexClick(t2, e2, i = "Edit", r2 = {}) {
    this.__fire(this._layer, "pm:vertexclick", { layer: this._layer, markerEvent: t2, indexPath: e2, shape: this.getShape() }, i, r2);
  }, _fireIntersect(t2, e2 = this._layer, i = "Edit", r2 = {}) {
    this.__fire(e2, "pm:intersect", { layer: this._layer, intersection: t2, shape: this.getShape() }, i, r2);
  }, _fireLayerReset(t2, e2, i = "Edit", r2 = {}) {
    this.__fire(this._layer, "pm:layerreset", { layer: this._layer, markerEvent: t2, indexPath: e2, shape: this.getShape() }, i, r2);
  }, _fireChange(t2, e2 = "Edit", i = {}) {
    this.__fire(this._layer, "pm:change", { layer: this._layer, latlngs: t2, shape: this.getShape() }, e2, i);
  }, _fireTextChange(t2, e2 = "Edit", i = {}) {
    this.__fire(this._layer, "pm:textchange", { layer: this._layer, text: t2, shape: this.getShape() }, e2, i);
  }, _fireTextFocus(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:textfocus", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireTextBlur(t2 = "Edit", e2 = {}) {
    this.__fire(this._layer, "pm:textblur", { layer: this._layer, shape: this.getShape() }, t2, e2);
  }, _fireSnapDrag(t2, e2, i = "Snapping", r2 = {}) {
    this.__fire(t2, "pm:snapdrag", e2, i, r2);
  }, _fireSnap(t2, e2, i = "Snapping", r2 = {}) {
    this.__fire(t2, "pm:snap", e2, i, r2);
  }, _fireUnsnap(t2, e2, i = "Snapping", r2 = {}) {
    this.__fire(t2, "pm:unsnap", e2, i, r2);
  }, _fireRotationEnable(t2, e2, i = "Rotation", r2 = {}) {
    this.__fire(t2, "pm:rotateenable", { layer: this._layer, helpLayer: this._rotatePoly, shape: this.getShape() }, i, r2);
  }, _fireRotationDisable(t2, e2 = "Rotation", i = {}) {
    this.__fire(t2, "pm:rotatedisable", { layer: this._layer, shape: this.getShape() }, e2, i);
  }, _fireRotationStart(t2, e2, i = "Rotation", r2 = {}) {
    this.__fire(t2, "pm:rotatestart", { layer: this._rotationLayer, helpLayer: this._layer, startAngle: this._startAngle, originLatLngs: e2 }, i, r2);
  }, _fireRotation(t2, e2, i, r2 = this._rotationLayer, n2 = "Rotation", s2 = {}) {
    this.__fire(t2, "pm:rotate", { layer: r2, helpLayer: this._layer, startAngle: this._startAngle, angle: r2.pm.getAngle(), angleDiff: e2, oldLatLngs: i, newLatLngs: r2.getLatLngs() }, n2, s2);
  }, _fireRotationEnd(t2, e2, i, r2 = "Rotation", n2 = {}) {
    this.__fire(t2, "pm:rotateend", { layer: this._rotationLayer, helpLayer: this._layer, startAngle: e2, angle: this._rotationLayer.pm.getAngle(), originLatLngs: i, newLatLngs: this._rotationLayer.getLatLngs() }, r2, n2);
  }, _fireActionClick(t2, e2, i, r2 = "Toolbar", n2 = {}) {
    this.__fire(this._map, "pm:actionclick", { text: t2.text, action: t2, btnName: e2, button: i }, r2, n2);
  }, _fireButtonClick(t2, e2, i = "Toolbar", r2 = {}) {
    this.__fire(this._map, "pm:buttonclick", { btnName: t2, button: e2 }, i, r2);
  }, _fireLangChange(t2, e2, i, r2, n2 = "Global", s2 = {}) {
    this.__fire(this.map, "pm:langchange", { oldLang: t2, activeLang: e2, fallback: i, translations: r2 }, n2, s2);
  }, _fireGlobalDragModeToggled(t2, e2 = "Global", i = {}) {
    this.__fire(this.map, "pm:globaldragmodetoggled", { enabled: t2, map: this.map }, e2, i);
  }, _fireGlobalEditModeToggled(t2, e2 = "Global", i = {}) {
    this.__fire(this.map, "pm:globaleditmodetoggled", { enabled: t2, map: this.map }, e2, i);
  }, _fireGlobalRemovalModeToggled(t2, e2 = "Global", i = {}) {
    this.__fire(this.map, "pm:globalremovalmodetoggled", { enabled: t2, map: this.map }, e2, i);
  }, _fireGlobalCutModeToggled(t2 = "Global", e2 = {}) {
    this.__fire(this._map, "pm:globalcutmodetoggled", { enabled: !!this._enabled, map: this._map }, t2, e2);
  }, _fireGlobalDrawModeToggled(t2 = "Global", e2 = {}) {
    this.__fire(this._map, "pm:globaldrawmodetoggled", { enabled: this._enabled, shape: this._shape, map: this._map }, t2, e2);
  }, _fireGlobalRotateModeToggled(t2 = "Global", e2 = {}) {
    this.__fire(this.map, "pm:globalrotatemodetoggled", { enabled: this.globalRotateModeEnabled(), map: this.map }, t2, e2);
  }, _fireRemoveLayerGroup(t2, e2 = t2, i = "Edit", r2 = {}) {
    this.__fire(t2, "pm:remove", { layer: e2, shape: void 0 }, i, r2);
  }, _fireKeyeventEvent(t2, e2, i, r2 = "Global", n2 = {}) {
    this.__fire(this.map, "pm:keyevent", { event: t2, eventType: e2, focusOn: i }, r2, n2);
  }, __fire(t2, e2, i, r2, n2 = {}) {
    i = (0, go.default)(i, n2, { source: r2 }), L.PM.Utils._fireEvent(t2, e2, i);
  } }, Tt = bg2;
  var vg2 = () => ({ _lastEvents: { keydown: void 0, keyup: void 0, current: void 0 }, _initKeyListener(t2) {
    this.map = t2, L.DomEvent.on(document, "keydown keyup", this._onKeyListener, this), L.DomEvent.on(window, "blur", this._onBlur, this), t2.once("unload", this._unbindKeyListenerEvents, this);
  }, _unbindKeyListenerEvents() {
    L.DomEvent.off(document, "keydown keyup", this._onKeyListener, this), L.DomEvent.off(window, "blur", this._onBlur, this);
  }, _onKeyListener(t2) {
    let e2 = "document";
    this.map.getContainer().contains(t2.target) && (e2 = "map");
    let i = { event: t2, eventType: t2.type, focusOn: e2 };
    this._lastEvents[t2.type] = i, this._lastEvents.current = i, this.map.pm._fireKeyeventEvent(t2, t2.type, e2);
  }, _onBlur(t2) {
    t2.altKey = false;
    let e2 = { event: t2, eventType: t2.type, focusOn: "document" };
    this._lastEvents[t2.type] = e2, this._lastEvents.current = e2;
  }, getLastKeyEvent(t2 = "current") {
    return this._lastEvents[t2];
  }, isShiftKeyPressed() {
    var _a3;
    return (_a3 = this._lastEvents.current) == null ? void 0 : _a3.event.shiftKey;
  }, isAltKeyPressed() {
    var _a3;
    return (_a3 = this._lastEvents.current) == null ? void 0 : _a3.event.altKey;
  }, isCtrlKeyPressed() {
    var _a3;
    return (_a3 = this._lastEvents.current) == null ? void 0 : _a3.event.ctrlKey;
  }, isMetaKeyPressed() {
    var _a3;
    return (_a3 = this._lastEvents.current) == null ? void 0 : _a3.event.metaKey;
  }, getPressedKey() {
    var _a3;
    return (_a3 = this._lastEvents.current) == null ? void 0 : _a3.event.key;
  } }), mo = vg2;
  var wi2 = xt(Le2());
  function V2(t2) {
    let e2 = L.PM.activeLang;
    return (0, wi2.default)(Nt[e2], t2) || (0, wi2.default)(Nt.en, t2) || t2;
  }
  function be2(t2) {
    for (let e2 = 0; e2 < t2.length; e2 += 1) {
      let i = t2[e2];
      if (Array.isArray(i)) {
        if (be2(i)) return true;
      } else if (i != null && i !== "") return true;
    }
    return false;
  }
  function ve2(t2) {
    return t2.reduce((e2, i) => {
      if (i.length !== 0) {
        let r2 = Array.isArray(i) ? ve2(i) : i;
        Array.isArray(r2) ? r2.length !== 0 && e2.push(r2) : e2.push(r2);
      }
      return e2;
    }, []);
  }
  function sm(t2, e2, i) {
    let r2 = { a: L.CRS.Earth.R, b: 63567523142e-4, f: 0.0033528106647474805 }, { a: n2, b: s2, f: a } = r2, o = t2.lng, l2 = t2.lat, u2 = i, f2 = Math.PI, d = e2 * f2 / 180, P2 = Math.sin(d), E2 = Math.cos(d), T2 = (1 - a) * Math.tan(l2 * f2 / 180), G2 = 1 / Math.sqrt(1 + T2 * T2), _ = T2 * G2, x2 = Math.atan2(T2, E2), b = G2 * P2, R2 = 1 - b * b, D2 = R2 * (n2 * n2 - s2 * s2) / (s2 * s2), O2 = 1 + D2 / 16384 * (4096 + D2 * (-768 + D2 * (320 - 175 * D2))), A2 = D2 / 1024 * (256 + D2 * (-128 + D2 * (74 - 47 * D2))), q2 = u2 / (s2 * O2), h2 = 2 * Math.PI, c, p2, y2;
    for (; Math.abs(q2 - h2) > 1e-12; ) {
      c = Math.cos(2 * x2 + q2), p2 = Math.sin(q2), y2 = Math.cos(q2);
      let B2 = A2 * p2 * (c + A2 / 4 * (y2 * (-1 + 2 * c * c) - A2 / 6 * c * (-3 + 4 * p2 * p2) * (-3 + 4 * c * c)));
      h2 = q2, q2 = u2 / (s2 * O2) + B2;
    }
    let g2 = _ * p2 - G2 * y2 * E2, k2 = Math.atan2(_ * y2 + G2 * p2 * E2, (1 - a) * Math.sqrt(b * b + g2 * g2)), C2 = Math.atan2(p2 * P2, G2 * y2 - _ * p2 * E2), m2 = a / 16 * R2 * (4 + a * (4 - 3 * R2)), v2 = C2 - (1 - m2) * a * b * (q2 + m2 * p2 * (c + m2 * y2 * (-1 + 2 * c * c))), w2 = o + v2 * 180 / f2, M2 = k2 * 180 / f2;
    return L.latLng(w2, M2);
  }
  function Ci2(t2, e2, i, r2, n2 = true) {
    let s2, a, o, l2 = [];
    for (let u2 = 0; u2 < i; u2 += 1) {
      if (n2) s2 = u2 * 360 / i + r2, a = sm(t2, s2, e2), o = L.latLng(a.lng, a.lat);
      else {
        let f2 = t2.lat + Math.cos(2 * u2 * Math.PI / i) * e2, d = t2.lng + Math.sin(2 * u2 * Math.PI / i) * e2;
        o = L.latLng(f2, d);
      }
      l2.push(o);
    }
    return l2;
  }
  function am(t2, e2, i) {
    e2 = (e2 + 360) % 360;
    let r2 = Math.PI / 180, n2 = 180 / Math.PI, { R: s2 } = L.CRS.Earth, a = t2.lng * r2, o = t2.lat * r2, l2 = e2 * r2, u2 = Math.sin(o), f2 = Math.cos(o), d = Math.cos(i / s2), P2 = Math.sin(i / s2), E2 = Math.asin(u2 * d + f2 * P2 * Math.cos(l2)), T2 = a + Math.atan2(Math.sin(l2) * P2 * f2, d - u2 * Math.sin(E2));
    T2 *= n2;
    let G2 = T2 - 360, _ = T2 < -180 ? T2 + 360 : T2;
    return T2 = T2 > 180 ? G2 : _, L.latLng([E2 * n2, T2]);
  }
  function ke2(t2, e2, i) {
    let r2 = t2.latLngToContainerPoint(e2), n2 = t2.latLngToContainerPoint(i), s2 = Math.atan2(n2.y - r2.y, n2.x - r2.x) * 180 / Math.PI + 90;
    return s2 += s2 < 0 ? 360 : 0, s2;
  }
  function te2(t2, e2, i, r2) {
    let n2 = ke2(t2, e2, i);
    return am(e2, n2, r2);
  }
  function jo(t2, e2, i = "asc") {
    if (!e2 || Object.keys(e2).length === 0) return (l2, u2) => l2 - u2;
    let r2 = Object.keys(e2), n2, s2 = r2.length - 1, a = {};
    for (; s2 >= 0; ) n2 = r2[s2], a[n2.toLowerCase()] = e2[n2], s2 -= 1;
    function o(l2) {
      if (l2 instanceof L.Marker) return "Marker";
      if (l2 instanceof L.Circle) return "Circle";
      if (l2 instanceof L.CircleMarker) return "CircleMarker";
      if (l2 instanceof L.Rectangle) return "Rectangle";
      if (l2 instanceof L.Polygon) return "Polygon";
      if (l2 instanceof L.Polyline) return "Line";
    }
    return (l2, u2) => {
      let f2, d;
      {
        if (f2 = o(l2.layer).toLowerCase(), d = o(u2.layer).toLowerCase(), !f2 || !d) return 0;
      }
      let P2 = f2 in a ? a[f2] : Number.MAX_SAFE_INTEGER, E2 = d in a ? a[d] : Number.MAX_SAFE_INTEGER, T2 = 0;
      return P2 < E2 ? T2 = -1 : P2 > E2 && (T2 = 1), i === "desc" ? T2 * -1 : T2;
    };
  }
  function vt(t2, e2 = t2.getLatLngs()) {
    return t2 instanceof L.Polygon ? L.polygon(e2).getLatLngs() : L.polyline(e2).getLatLngs();
  }
  function Ei2(t2, e2) {
    var _a3, _b2, _c, _d;
    if ((_b2 = (_a3 = e2.options.crs) == null ? void 0 : _a3.projection) == null ? void 0 : _b2.MAX_LATITUDE) {
      let i = (_d = (_c = e2.options.crs) == null ? void 0 : _c.projection) == null ? void 0 : _d.MAX_LATITUDE;
      t2.lat = Math.max(Math.min(i, t2.lat), -i);
    }
    return t2;
  }
  function Rt(t2) {
    return t2.options.renderer || t2._map && (t2._map._getPaneRenderer(t2.options.pane) || t2._map.options.renderer || t2._map._renderer) || t2._renderer;
  }
  var om = L.Class.extend({ includes: [uo, co, po, fo, Tt], initialize(t2) {
    this.map = t2, this.Draw = new L.PM.Draw(t2), this.Toolbar = new L.PM.Toolbar(t2), this.Keyboard = mo(), this.globalOptions = { snappable: true, layerGroup: void 0, snappingOrder: ["Marker", "CircleMarker", "Circle", "Line", "Polygon", "Rectangle"], panes: { vertexPane: "markerPane", layerPane: "overlayPane", markerPane: "markerPane" }, draggable: true }, this.Keyboard._initKeyListener(t2);
  }, setLang(t2 = "en", e2, i = "en") {
    let r2 = L.PM.activeLang;
    e2 && (Nt[t2] = (0, Pi2.default)(Nt[i], e2)), L.PM.activeLang = t2, this.map.pm.Toolbar.reinit(), this._fireLangChange(r2, t2, i, Nt[t2]);
  }, addControls(t2) {
    this.Toolbar.addControls(t2);
  }, removeControls() {
    this.Toolbar.removeControls();
  }, toggleControls() {
    this.Toolbar.toggleControls();
  }, controlsVisible() {
    return this.Toolbar.isVisible;
  }, enableDraw(t2 = "Polygon", e2) {
    t2 === "Poly" && (t2 = "Polygon"), this.Draw.enable(t2, e2);
  }, disableDraw(t2 = "Polygon") {
    t2 === "Poly" && (t2 = "Polygon"), this.Draw.disable(t2);
  }, setPathOptions(t2, e2 = {}) {
    let i = e2.ignoreShapes || [], r2 = e2.merge || false;
    this.map.pm.Draw.shapes.forEach((n2) => {
      i.indexOf(n2) === -1 && this.map.pm.Draw[n2].setPathOptions(t2, r2);
    });
  }, getGlobalOptions() {
    return this.globalOptions;
  }, setGlobalOptions(t2) {
    let e2 = (0, Pi2.default)(this.globalOptions, t2);
    e2.editable && (e2.resizeableCircleMarker = e2.editable, delete e2.editable);
    let i = false;
    this.map.pm.Draw.CircleMarker.enabled() && !!this.map.pm.Draw.CircleMarker.options.resizeableCircleMarker != !!e2.resizeableCircleMarker && (this.map.pm.Draw.CircleMarker.disable(), i = true);
    let r2 = false;
    this.map.pm.Draw.Circle.enabled() && !!this.map.pm.Draw.Circle.options.resizableCircle != !!e2.resizableCircle && (this.map.pm.Draw.Circle.disable(), r2 = true), this.map.pm.Draw.shapes.forEach((s2) => {
      this.map.pm.Draw[s2].setOptions(e2);
    }), i && this.map.pm.Draw.CircleMarker.enable(), r2 && this.map.pm.Draw.Circle.enable(), L.PM.Utils.findLayers(this.map).forEach((s2) => {
      s2.pm.setOptions(e2);
    }), this.map.fire("pm:globaloptionschanged"), this.globalOptions = e2, this.applyGlobalOptions();
  }, applyGlobalOptions() {
    L.PM.Utils.findLayers(this.map).forEach((e2) => {
      e2.pm.enabled() && e2.pm.applyOptions();
    });
  }, globalDrawModeEnabled() {
    return !!this.Draw.getActiveShape();
  }, globalCutModeEnabled() {
    return !!this.Draw.Cut.enabled();
  }, enableGlobalCutMode(t2) {
    return this.Draw.Cut.enable(t2);
  }, toggleGlobalCutMode(t2) {
    return this.Draw.Cut.toggle(t2);
  }, disableGlobalCutMode() {
    return this.Draw.Cut.disable();
  }, getGeomanLayers(t2 = false) {
    let e2 = L.PM.Utils.findLayers(this.map);
    if (!t2) return e2;
    let i = L.featureGroup();
    return i._pmTempLayer = true, e2.forEach((r2) => {
      i.addLayer(r2);
    }), i;
  }, getGeomanDrawLayers(t2 = false) {
    let e2 = L.PM.Utils.findLayers(this.map).filter((r2) => r2._drawnByGeoman === true);
    if (!t2) return e2;
    let i = L.featureGroup();
    return i._pmTempLayer = true, e2.forEach((r2) => {
      i.addLayer(r2);
    }), i;
  }, _getContainingLayer() {
    return this.globalOptions.layerGroup && this.globalOptions.layerGroup instanceof L.LayerGroup ? this.globalOptions.layerGroup : this.map;
  }, _isCRSSimple() {
    return this.map.options.crs === L.CRS.Simple;
  }, _touchEventCounter: 0, _addTouchEvents(t2) {
    this._touchEventCounter === 0 && (L.DomEvent.on(t2, "touchmove", this._canvasTouchMove, this), L.DomEvent.on(t2, "touchstart touchend touchcancel", this._canvasTouchClick, this)), this._touchEventCounter += 1;
  }, _removeTouchEvents(t2) {
    this._touchEventCounter === 1 && (L.DomEvent.off(t2, "touchmove", this._canvasTouchMove, this), L.DomEvent.off(t2, "touchstart touchend touchcancel", this._canvasTouchClick, this)), this._touchEventCounter = this._touchEventCounter <= 1 ? 0 : this._touchEventCounter - 1;
  }, _canvasTouchMove(t2) {
    Rt(this.map)._onMouseMove(this._createMouseEvent("mousemove", t2));
  }, _canvasTouchClick(t2) {
    let e2 = "";
    t2.type === "touchstart" || t2.type === "pointerdown" ? e2 = "mousedown" : (t2.type === "touchend" || t2.type === "pointerup" || t2.type === "touchcancel" || t2.type === "pointercancel") && (e2 = "mouseup"), e2 && Rt(this.map)._onClick(this._createMouseEvent(e2, t2));
  }, _createMouseEvent(t2, e2) {
    let i, r2 = e2.touches[0] || e2.changedTouches[0];
    try {
      i = new MouseEvent(t2, { bubbles: e2.bubbles, cancelable: e2.cancelable, view: e2.view, detail: r2.detail, screenX: r2.screenX, screenY: r2.screenY, clientX: r2.clientX, clientY: r2.clientY, ctrlKey: e2.ctrlKey, altKey: e2.altKey, shiftKey: e2.shiftKey, metaKey: e2.metaKey, button: e2.button, relatedTarget: e2.relatedTarget });
    } catch {
      i = document.createEvent("MouseEvents"), i.initMouseEvent(t2, e2.bubbles, e2.cancelable, e2.view, r2.detail, r2.screenX, r2.screenY, r2.clientX, r2.clientY, e2.ctrlKey, e2.altKey, e2.shiftKey, e2.metaKey, e2.button, e2.relatedTarget);
    }
    return i;
  } }), Ko = om;
  var lm = L.Control.extend({ includes: [Tt], options: { position: "topleft", disableByOtherButtons: true }, initialize(t2) {
    this._button = L.Util.extend({}, this.options, t2);
  }, onAdd(t2) {
    return this._map = t2, this._map.pm.Toolbar.options.oneBlock ? this._container = this._map.pm.Toolbar._createContainer(this.options.position) : this._button.tool === "edit" ? this._container = this._map.pm.Toolbar.editContainer : this._button.tool === "options" ? this._container = this._map.pm.Toolbar.optionsContainer : this._button.tool === "custom" ? this._container = this._map.pm.Toolbar.customContainer : this._container = this._map.pm.Toolbar.drawContainer, this._renderButton(), this._container;
  }, _renderButton() {
    let t2 = this.buttonsDomNode;
    this.buttonsDomNode = this._makeButton(this._button), t2 ? t2.replaceWith(this.buttonsDomNode) : this._container.appendChild(this.buttonsDomNode);
  }, onRemove() {
    return this.buttonsDomNode.remove(), this._container;
  }, getText() {
    return this._button.text;
  }, getIconUrl() {
    return this._button.iconUrl;
  }, destroy() {
    this._button = {}, this._update();
  }, toggle(t2) {
    return typeof t2 == "boolean" ? this._button.toggleStatus = t2 : this._button.toggleStatus = !this._button.toggleStatus, this._applyStyleClasses(), this._button.toggleStatus;
  }, toggled() {
    return this._button.toggleStatus;
  }, onCreate() {
    this.toggle(false);
  }, disable() {
    this.toggle(false), this._button.disabled = true, this._updateDisabled();
  }, enable() {
    this._button.disabled = false, this._updateDisabled();
  }, _triggerClick(t2) {
    t2 && t2.preventDefault(), !this._button.disabled && (this._button.onClick(t2, { button: this, event: t2 }), this._clicked(t2), this._button.afterClick(t2, { button: this, event: t2 }));
  }, _makeButton(t2) {
    let e2 = this.options.position.indexOf("right") > -1 ? "pos-right" : "", i = L.DomUtil.create("div", `button-container  ${e2}`, this._container);
    t2.title && i.setAttribute("title", t2.title);
    let r2 = L.DomUtil.create("a", "leaflet-buttons-control-button", i);
    r2.setAttribute("role", "button"), r2.setAttribute("tabindex", "0"), r2.href = "#";
    let n2 = L.DomUtil.create("div", `leaflet-pm-actions-container ${e2}`, i), s2 = t2.actions, a = { cancel: { text: V2("actions.cancel"), title: V2("actions.cancel"), onClick() {
      this._triggerClick();
    } }, finishMode: { text: V2("actions.finish"), title: V2("actions.finish"), onClick() {
      this._triggerClick();
    } }, removeLastVertex: { text: V2("actions.removeLastVertex"), title: V2("actions.removeLastVertex"), onClick() {
      this._map.pm.Draw[t2.jsClass]._removeLastVertex();
    } }, finish: { text: V2("actions.finish"), title: V2("actions.finish"), onClick(l2) {
      this._map.pm.Draw[t2.jsClass]._finishShape(l2);
    } } };
    s2.forEach((l2) => {
      let u2 = typeof l2 == "string" ? l2 : l2.name, f2;
      if (a[u2]) f2 = a[u2];
      else if (l2.text) f2 = l2;
      else return;
      let d = L.DomUtil.create("a", `leaflet-pm-action ${e2} action-${u2}`, n2);
      if (d.setAttribute("role", "button"), d.setAttribute("tabindex", "0"), d.href = "#", f2.title && (d.title = f2.title), d.innerHTML = f2.text, L.DomEvent.disableClickPropagation(d), L.DomEvent.on(d, "click", L.DomEvent.stop), !t2.disabled && f2.onClick) {
        let P2 = (E2) => {
          E2.preventDefault();
          let T2 = "", { buttons: G2 } = this._map.pm.Toolbar;
          for (let _ in G2) if (G2[_]._button === t2) {
            T2 = _;
            break;
          }
          this._fireActionClick(f2, T2, t2);
        };
        L.DomEvent.addListener(d, "click", P2, this), L.DomEvent.addListener(d, "click", f2.onClick, this);
      }
    }), t2.toggleStatus && L.DomUtil.addClass(i, "active");
    let o = L.DomUtil.create("div", "control-icon", r2);
    return t2.iconUrl && o.setAttribute("src", t2.iconUrl), t2.className && L.DomUtil.addClass(o, t2.className), L.DomEvent.disableClickPropagation(r2), L.DomEvent.on(r2, "click", L.DomEvent.stop), t2.disabled || (L.DomEvent.addListener(r2, "click", this._onBtnClick, this), L.DomEvent.addListener(r2, "click", this._triggerClick, this)), t2.disabled && (L.DomUtil.addClass(r2, "pm-disabled"), r2.setAttribute("aria-disabled", "true")), i;
  }, _applyStyleClasses() {
    this._container && (!this._button.toggleStatus || this._button.cssToggle === false ? (L.DomUtil.removeClass(this.buttonsDomNode, "active"), L.DomUtil.removeClass(this._container, "activeChild")) : (L.DomUtil.addClass(this.buttonsDomNode, "active"), L.DomUtil.addClass(this._container, "activeChild")));
  }, _onBtnClick() {
    if (this._button.disabled) return;
    this._button.disableOtherButtons && this._map.pm.Toolbar.triggerClickOnToggledButtons(this);
    let t2 = "", { buttons: e2 } = this._map.pm.Toolbar;
    for (let i in e2) if (e2[i]._button === this._button) {
      t2 = i;
      break;
    }
    this._fireButtonClick(t2, this._button);
  }, _clicked() {
    this._button.doToggle && this.toggle();
  }, _updateDisabled() {
    if (!this._container) return;
    let t2 = "pm-disabled", e2 = this.buttonsDomNode.children[0];
    this._button.disabled ? (L.DomUtil.addClass(e2, t2), e2.setAttribute("aria-disabled", "true")) : (L.DomUtil.removeClass(e2, t2), e2.setAttribute("aria-disabled", "false"));
  } }), Ho = lm;
  L.Control.PMButton = Ho;
  var hm = L.Class.extend({ options: { drawMarker: true, drawRectangle: true, drawPolyline: true, drawPolygon: true, drawCircle: true, drawCircleMarker: true, drawText: true, editMode: true, dragMode: true, cutPolygon: true, removalMode: true, rotateMode: true, snappingOption: true, drawControls: true, editControls: true, optionsControls: true, customControls: true, oneBlock: false, position: "topleft", positions: { draw: "", edit: "", options: "", custom: "" } }, customButtons: [], initialize(t2) {
    this.customButtons = [], this.options.positions = { draw: "", edit: "", options: "", custom: "" }, this.init(t2);
  }, reinit() {
    let t2 = this.isVisible;
    this.removeControls(), this._defineButtons(), t2 && this.addControls();
  }, init(t2) {
    this.map = t2, this.buttons = {}, this.isVisible = false, this.drawContainer = L.DomUtil.create("div", "leaflet-pm-toolbar leaflet-pm-draw leaflet-bar leaflet-control"), this.editContainer = L.DomUtil.create("div", "leaflet-pm-toolbar leaflet-pm-edit leaflet-bar leaflet-control"), this.optionsContainer = L.DomUtil.create("div", "leaflet-pm-toolbar leaflet-pm-options leaflet-bar leaflet-control"), this.customContainer = L.DomUtil.create("div", "leaflet-pm-toolbar leaflet-pm-custom leaflet-bar leaflet-control"), this._defineButtons();
  }, _createContainer(t2) {
    let e2 = `${t2}Container`;
    return this[e2] || (this[e2] = L.DomUtil.create("div", `leaflet-pm-toolbar leaflet-pm-${t2} leaflet-bar leaflet-control`)), this[e2];
  }, getButtons() {
    return this.buttons;
  }, addControls(t2 = this.options) {
    typeof t2.editPolygon < "u" && (t2.editMode = t2.editPolygon), typeof t2.deleteLayer < "u" && (t2.removalMode = t2.deleteLayer), L.Util.setOptions(this, t2), this.applyIconStyle(), this.isVisible = true, this._showHideButtons();
  }, applyIconStyle() {
    let t2 = this.getButtons(), e2 = { geomanIcons: { drawMarker: "control-icon leaflet-pm-icon-marker", drawPolyline: "control-icon leaflet-pm-icon-polyline", drawRectangle: "control-icon leaflet-pm-icon-rectangle", drawPolygon: "control-icon leaflet-pm-icon-polygon", drawCircle: "control-icon leaflet-pm-icon-circle", drawCircleMarker: "control-icon leaflet-pm-icon-circle-marker", editMode: "control-icon leaflet-pm-icon-edit", dragMode: "control-icon leaflet-pm-icon-drag", cutPolygon: "control-icon leaflet-pm-icon-cut", removalMode: "control-icon leaflet-pm-icon-delete", drawText: "control-icon leaflet-pm-icon-text" } };
    for (let i in t2) {
      let r2 = t2[i];
      L.Util.setOptions(r2, { className: e2.geomanIcons[i] });
    }
  }, removeControls() {
    let t2 = this.getButtons();
    for (let e2 in t2) t2[e2].remove();
    this.isVisible = false;
  }, toggleControls(t2 = this.options) {
    this.isVisible ? this.removeControls() : this.addControls(t2);
  }, _addButton(t2, e2) {
    return this.buttons[t2] = e2, this.options[t2] = !!this.options[t2] || false, this.buttons[t2];
  }, triggerClickOnToggledButtons(t2) {
    for (let e2 in this.buttons) {
      let i = this.buttons[e2];
      i._button.disableByOtherButtons && i !== t2 && i.toggled() && i._triggerClick();
    }
  }, toggleButton(t2, e2, i = true) {
    return t2 === "editPolygon" && (t2 = "editMode"), t2 === "deleteLayer" && (t2 = "removalMode"), i && this.triggerClickOnToggledButtons(this.buttons[t2]), this.buttons[t2] ? this.buttons[t2].toggle(e2) : false;
  }, _defineButtons() {
    let t2 = { className: "control-icon leaflet-pm-icon-marker", title: V2("buttonTitles.drawMarkerButton"), jsClass: "Marker", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["cancel"] }, e2 = { title: V2("buttonTitles.drawPolyButton"), className: "control-icon leaflet-pm-icon-polygon", jsClass: "Polygon", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["finish", "removeLastVertex", "cancel"] }, i = { className: "control-icon leaflet-pm-icon-polyline", title: V2("buttonTitles.drawLineButton"), jsClass: "Line", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["finish", "removeLastVertex", "cancel"] }, r2 = { title: V2("buttonTitles.drawCircleButton"), className: "control-icon leaflet-pm-icon-circle", jsClass: "Circle", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["cancel"] }, n2 = { title: V2("buttonTitles.drawCircleMarkerButton"), className: "control-icon leaflet-pm-icon-circle-marker", jsClass: "CircleMarker", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["cancel"] }, s2 = { title: V2("buttonTitles.drawRectButton"), className: "control-icon leaflet-pm-icon-rectangle", jsClass: "Rectangle", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["cancel"] }, a = { title: V2("buttonTitles.editButton"), className: "control-icon leaflet-pm-icon-edit", onClick: () => {
    }, afterClick: () => {
      this.map.pm.toggleGlobalEditMode();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, tool: "edit", actions: ["finishMode"] }, o = { title: V2("buttonTitles.dragButton"), className: "control-icon leaflet-pm-icon-drag", onClick: () => {
    }, afterClick: () => {
      this.map.pm.toggleGlobalDragMode();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, tool: "edit", actions: ["finishMode"] }, l2 = { title: V2("buttonTitles.cutButton"), className: "control-icon leaflet-pm-icon-cut", jsClass: "Cut", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle({ snappable: true, cursorMarker: true, allowSelfIntersection: false });
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, tool: "edit", actions: ["finish", "removeLastVertex", "cancel"] }, u2 = { title: V2("buttonTitles.deleteButton"), className: "control-icon leaflet-pm-icon-delete", onClick: () => {
    }, afterClick: () => {
      this.map.pm.toggleGlobalRemovalMode();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, tool: "edit", actions: ["finishMode"] }, f2 = { title: V2("buttonTitles.rotateButton"), className: "control-icon leaflet-pm-icon-rotate", onClick: () => {
    }, afterClick: () => {
      this.map.pm.toggleGlobalRotateMode();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, tool: "edit", actions: ["finishMode"] }, d = { className: "control-icon leaflet-pm-icon-text", title: V2("buttonTitles.drawTextButton"), jsClass: "Text", onClick: () => {
    }, afterClick: (P2, E2) => {
      this.map.pm.Draw[E2.button._button.jsClass].toggle();
    }, doToggle: true, toggleStatus: false, disableOtherButtons: true, position: this.options.position, actions: ["cancel"] };
    this._addButton("drawMarker", new L.Control.PMButton(t2)), this._addButton("drawPolyline", new L.Control.PMButton(i)), this._addButton("drawRectangle", new L.Control.PMButton(s2)), this._addButton("drawPolygon", new L.Control.PMButton(e2)), this._addButton("drawCircle", new L.Control.PMButton(r2)), this._addButton("drawCircleMarker", new L.Control.PMButton(n2)), this._addButton("drawText", new L.Control.PMButton(d)), this._addButton("editMode", new L.Control.PMButton(a)), this._addButton("dragMode", new L.Control.PMButton(o)), this._addButton("cutPolygon", new L.Control.PMButton(l2)), this._addButton("removalMode", new L.Control.PMButton(u2)), this._addButton("rotateMode", new L.Control.PMButton(f2));
  }, _showHideButtons() {
    if (!this.isVisible) return;
    this.removeControls(), this.isVisible = true;
    let t2 = this.getButtons(), e2 = [];
    this.options.drawControls === false && (e2 = e2.concat(Object.keys(t2).filter((i) => !t2[i]._button.tool))), this.options.editControls === false && (e2 = e2.concat(Object.keys(t2).filter((i) => t2[i]._button.tool === "edit"))), this.options.optionsControls === false && (e2 = e2.concat(Object.keys(t2).filter((i) => t2[i]._button.tool === "options"))), this.options.customControls === false && (e2 = e2.concat(Object.keys(t2).filter((i) => t2[i]._button.tool === "custom")));
    for (let i in t2) if (this.options[i] && e2.indexOf(i) === -1) {
      let r2 = t2[i]._button.tool;
      r2 || (r2 = "draw"), t2[i].setPosition(this._getBtnPosition(r2)), t2[i].addTo(this.map);
    }
  }, _getBtnPosition(t2) {
    return this.options.positions && this.options.positions[t2] ? this.options.positions[t2] : this.options.position;
  }, setBlockPosition(t2, e2) {
    this.options.positions[t2] = e2, this._showHideButtons(), this.changeControlOrder();
  }, getBlockPositions() {
    return this.options.positions;
  }, copyDrawControl(t2, e2) {
    if (e2) typeof e2 != "object" && (e2 = { name: e2 });
    else throw new TypeError("Button has no name");
    let i = this._btnNameMapping(t2);
    if (!e2.name) throw new TypeError("Button has no name");
    if (this.buttons[e2.name]) throw new TypeError("Button with this name already exists");
    let r2 = this.map.pm.Draw.createNewDrawInstance(e2.name, i);
    e2 = { ...this.buttons[i]._button, ...e2 };
    let s2 = this.createCustomControl(e2);
    return { drawInstance: r2, control: s2 };
  }, createCustomControl(t2) {
    if (!t2.name) throw new TypeError("Button has no name");
    if (this.buttons[t2.name]) throw new TypeError("Button with this name already exists");
    t2.onClick || (t2.onClick = () => {
    }), t2.afterClick || (t2.afterClick = () => {
    }), t2.toggle !== false && (t2.toggle = true), t2.block && (t2.block = t2.block.toLowerCase()), (!t2.block || t2.block === "draw") && (t2.block = ""), t2.className ? t2.className.indexOf("control-icon") === -1 && (t2.className = `control-icon ${t2.className}`) : t2.className = "control-icon";
    let e2 = { tool: t2.block, className: t2.className, title: t2.title || "", jsClass: t2.name, onClick: t2.onClick, afterClick: t2.afterClick, doToggle: t2.toggle, toggleStatus: false, disableOtherButtons: t2.disableOtherButtons ?? true, disableByOtherButtons: t2.disableByOtherButtons ?? true, cssToggle: t2.toggle, position: this.options.position, actions: t2.actions || [], disabled: !!t2.disabled };
    this.options[t2.name] !== false && (this.options[t2.name] = true);
    let i = this._addButton(t2.name, new L.Control.PMButton(e2));
    return this.changeControlOrder(), i;
  }, controlExists(t2) {
    return !!this.getButton(t2);
  }, getButton(t2) {
    return this.getButtons()[t2];
  }, getButtonsInBlock(t2) {
    let e2 = {};
    if (t2) for (let i in this.getButtons()) {
      let r2 = this.getButtons()[i];
      (r2._button.tool === t2 || t2 === "draw" && !r2._button.tool) && (e2[i] = r2);
    }
    return e2;
  }, changeControlOrder(t2 = []) {
    let e2 = this._shapeMapping(), i = [];
    t2.forEach((u2) => {
      e2[u2] ? i.push(e2[u2]) : i.push(u2);
    });
    let r2 = this.getButtons(), n2 = {};
    i.forEach((u2) => {
      r2[u2] && (n2[u2] = r2[u2]);
    }), Object.keys(r2).filter((u2) => !r2[u2]._button.tool).forEach((u2) => {
      i.indexOf(u2) === -1 && (n2[u2] = r2[u2]);
    }), Object.keys(r2).filter((u2) => r2[u2]._button.tool === "edit").forEach((u2) => {
      i.indexOf(u2) === -1 && (n2[u2] = r2[u2]);
    }), Object.keys(r2).filter((u2) => r2[u2]._button.tool === "options").forEach((u2) => {
      i.indexOf(u2) === -1 && (n2[u2] = r2[u2]);
    }), Object.keys(r2).filter((u2) => r2[u2]._button.tool === "custom").forEach((u2) => {
      i.indexOf(u2) === -1 && (n2[u2] = r2[u2]);
    }), Object.keys(r2).forEach((u2) => {
      i.indexOf(u2) === -1 && (n2[u2] = r2[u2]);
    }), this.map.pm.Toolbar.buttons = n2, this._showHideButtons();
  }, getControlOrder() {
    let t2 = this.getButtons(), e2 = [];
    for (let i in t2) e2.push(i);
    return e2;
  }, changeActionsOfControl(t2, e2) {
    let i = this._btnNameMapping(t2);
    if (!i) throw new TypeError("No name passed");
    if (!e2) throw new TypeError("No actions passed");
    if (!this.buttons[i]) throw new TypeError("Button with this name not exists");
    this.buttons[i]._button.actions = e2, this.changeControlOrder();
  }, setButtonDisabled(t2, e2) {
    let i = this._btnNameMapping(t2);
    e2 ? this.buttons[i].disable() : this.buttons[i].enable();
  }, _shapeMapping() {
    return { Marker: "drawMarker", Circle: "drawCircle", Polygon: "drawPolygon", Rectangle: "drawRectangle", Polyline: "drawPolyline", Line: "drawPolyline", CircleMarker: "drawCircleMarker", Edit: "editMode", Drag: "dragMode", Cut: "cutPolygon", Removal: "removalMode", Rotate: "rotateMode", Text: "drawText" };
  }, _btnNameMapping(t2) {
    let e2 = this._shapeMapping();
    return e2[t2] ? e2[t2] : t2;
  } }), Xo = hm;
  var Yo = xt(Ne2());
  var um = { _initSnappableMarkers() {
    this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === void 0 ? true : this.options.snapSegment, this._assignEvents(this._markers), this._layer.off("pm:dragstart", this._unsnap, this), this._layer.on("pm:dragstart", this._unsnap, this);
  }, _disableSnapping() {
    this._layer.off("pm:dragstart", this._unsnap, this);
  }, _assignEvents(t2) {
    t2.forEach((e2) => {
      if (Array.isArray(e2)) {
        this._assignEvents(e2);
        return;
      }
      e2.off("drag", this._handleSnapping, this), e2.on("drag", this._handleSnapping, this), e2.off("dragend", this._cleanupSnapping, this), e2.on("dragend", this._cleanupSnapping, this);
    });
  }, _cleanupSnapping(t2) {
    if (t2) {
      let e2 = t2.target;
      e2._snapped = false;
    }
    delete this._snapList, this.throttledList && (this._map.off("layeradd", this.throttledList, this), this.throttledList = void 0), this._map.off("layerremove", this._handleSnapLayerRemoval, this), this.debugIndicatorLines && this.debugIndicatorLines.forEach((e2) => {
      e2.remove();
    });
  }, _handleThrottleSnapping() {
    this.throttledList && this._createSnapList();
  }, _handleSnapping(t2) {
    var _a3, _b2, _c;
    let e2 = t2.target;
    if (e2._snapped = false, this.throttledList || (this.throttledList = L.Util.throttle(this._handleThrottleSnapping, 100, this)), ((_a3 = t2 == null ? void 0 : t2.originalEvent) == null ? void 0 : _a3.altKey) || ((_c = (_b2 = this._map) == null ? void 0 : _b2.pm) == null ? void 0 : _c.Keyboard.isAltKeyPressed()) || (this._snapList === void 0 && (this._createSnapList(), this._map.off("layeradd", this.throttledList, this), this._map.on("layeradd", this.throttledList, this)), this._snapList.length <= 0)) return false;
    let i = this._calcClosestLayer(e2.getLatLng(), this._snapList);
    if (Object.keys(i).length === 0) return false;
    let r2 = i.layer instanceof L.Marker || i.layer instanceof L.CircleMarker || !this.options.snapSegment, n2;
    r2 ? n2 = i.latlng : n2 = this._checkPrioritiySnapping(i);
    let s2 = this.options.snapDistance, a = { marker: e2, shape: this._shape, snapLatLng: n2, segment: i.segment, layer: this._layer, workingLayer: this._layer, layerInteractedWith: i.layer, distance: i.distance };
    if (this._fireSnapDrag(a.marker, a), this._fireSnapDrag(this._layer, a), i.distance < s2) {
      e2._orgLatLng = e2.getLatLng(), e2.setLatLng(n2), e2._snapped = true, e2._snapInfo = a;
      let o = () => {
        this._snapLatLng = n2, this._fireSnap(e2, a), this._fireSnap(this._layer, a);
      }, l2 = this._snapLatLng || {}, u2 = n2 || {};
      (l2.lat !== u2.lat || l2.lng !== u2.lng) && o();
    } else this._snapLatLng && (this._unsnap(a), e2._snapped = false, e2._snapInfo = void 0, this._fireUnsnap(a.marker, a), this._fireUnsnap(this._layer, a));
    return true;
  }, _createSnapList() {
    let t2 = [], e2 = [], i = this._map;
    i.off("layerremove", this._handleSnapLayerRemoval, this), i.on("layerremove", this._handleSnapLayerRemoval, this), i.eachLayer((r2) => {
      if ((r2 instanceof L.Polyline || r2 instanceof L.Marker || r2 instanceof L.CircleMarker || r2 instanceof L.ImageOverlay) && r2.options.snapIgnore !== true) {
        if (r2.options.snapIgnore === void 0 && (!L.PM.optIn && r2.options.pmIgnore === true || L.PM.optIn && r2.options.pmIgnore !== false)) return;
        (r2 instanceof L.Circle || r2 instanceof L.CircleMarker) && r2.pm && r2.pm._hiddenPolyCircle ? t2.push(r2.pm._hiddenPolyCircle) : r2 instanceof L.ImageOverlay && (r2 = L.rectangle(r2.getBounds())), t2.push(r2);
        let n2 = L.polyline([], { color: "red", pmIgnore: true });
        n2._pmTempLayer = true, e2.push(n2), (r2 instanceof L.Circle || r2 instanceof L.CircleMarker) && e2.push(n2);
      }
    }), t2 = t2.filter((r2) => this._layer !== r2), t2 = t2.filter((r2) => r2._latlng || r2._latlngs && be2(r2._latlngs)), t2 = t2.filter((r2) => !r2._pmTempLayer), this._otherSnapLayers ? (this._otherSnapLayers.forEach(() => {
      let r2 = L.polyline([], { color: "red", pmIgnore: true });
      r2._pmTempLayer = true, e2.push(r2);
    }), this._snapList = t2.concat(this._otherSnapLayers)) : this._snapList = t2, this.debugIndicatorLines = e2;
  }, _handleSnapLayerRemoval({ layer: t2 }) {
    if (!t2._leaflet_id) return;
    let e2 = this._snapList.findIndex((i) => i._leaflet_id === t2._leaflet_id);
    e2 > -1 && this._snapList.splice(e2, 1);
  }, _calcClosestLayer(t2, e2) {
    return this._calcClosestLayers(t2, e2, 1)[0];
  }, _calcClosestLayers(t2, e2, i = 1) {
    let r2 = [], n2 = {};
    e2.forEach((a, o) => {
      if (a._parentCopy && a._parentCopy === this._layer) return;
      let l2 = this._calcLayerDistances(t2, a);
      if (l2.distance = Math.floor(l2.distance), this.debugIndicatorLines) {
        if (!this.debugIndicatorLines[o]) {
          let u2 = L.polyline([], { color: "red", pmIgnore: true });
          u2._pmTempLayer = true, this.debugIndicatorLines[o] = u2;
        }
        this.debugIndicatorLines[o].setLatLngs([t2, l2.latlng]);
      }
      i === 1 && (n2.distance === void 0 || l2.distance - 5 <= n2.distance) ? (l2.distance + 5 < n2.distance && (r2 = []), n2 = l2, n2.layer = a, r2.push(n2)) : i !== 1 && (n2 = {}, n2 = l2, n2.layer = a, r2.push(n2));
    }), i !== 1 && (r2 = r2.sort((a, o) => a.distance - o.distance)), i === -1 && (i = r2.length);
    let s2 = this._getClosestLayerByPriority(r2, i);
    return L.Util.isArray(s2) ? s2 : [s2];
  }, _calcLayerDistances(t2, e2) {
    let i = this._map, r2 = e2 instanceof L.Marker || e2 instanceof L.CircleMarker, n2 = e2 instanceof L.Polygon, s2 = t2;
    if (r2) {
      let a = e2.getLatLng();
      return { latlng: { ...a }, distance: this._getDistance(i, a, s2) };
    }
    return this._calcLatLngDistances(s2, e2.getLatLngs(), i, n2);
  }, _calcLatLngDistances(t2, e2, i, r2 = false) {
    let n2, s2, a, o = (l2) => {
      l2.forEach((u2, f2) => {
        if (Array.isArray(u2)) {
          o(u2);
          return;
        }
        if (this.options.snapSegment) {
          let d = u2, P2;
          r2 ? P2 = f2 + 1 === l2.length ? 0 : f2 + 1 : P2 = f2 + 1 === l2.length ? void 0 : f2 + 1;
          let E2 = l2[P2];
          if (E2) {
            let T2 = this._getDistanceToSegment(i, t2, d, E2);
            (s2 === void 0 || T2 < s2) && (s2 = T2, a = [d, E2]);
          }
        } else {
          let d = this._getDistance(i, t2, u2);
          (s2 === void 0 || d < s2) && (s2 = d, n2 = u2);
        }
      });
    };
    return o(e2), this.options.snapSegment ? { latlng: { ...this._getClosestPointOnSegment(i, t2, a[0], a[1]) }, segment: a, distance: s2 } : { latlng: n2, distance: s2 };
  }, _getClosestLayerByPriority(t2, e2 = 1) {
    t2 = t2.sort((a, o) => a._leaflet_id - o._leaflet_id);
    let i = ["Marker", "CircleMarker", "Circle", "Line", "Polygon", "Rectangle"], r2 = this._map.pm.globalOptions.snappingOrder || [], n2 = 0, s2 = {};
    return r2.concat(i).forEach((a) => {
      s2[a] || (n2 += 1, s2[a] = n2);
    }), t2.sort(jo("instanceofShape", s2)), e2 === 1 ? t2[0] || {} : t2.slice(0, e2);
  }, _checkPrioritiySnapping(t2) {
    let e2 = this._map, i = t2.segment[0], r2 = t2.segment[1], n2 = t2.latlng, s2 = this._getDistance(e2, i, n2), a = this._getDistance(e2, r2, n2), o = s2 < a ? i : r2, l2 = s2 < a ? s2 : a;
    if (this.options.snapMiddle) {
      let d = L.PM.Utils.calcMiddleLatLng(e2, i, r2), P2 = this._getDistance(e2, d, n2);
      P2 < s2 && P2 < a && (o = d, l2 = P2);
    }
    let u2 = this.options.snapDistance, f2;
    return l2 < u2 ? f2 = o : f2 = n2, { ...f2 };
  }, _unsnap() {
    delete this._snapLatLng;
  }, _getClosestPointOnSegment(t2, e2, i, r2) {
    let n2 = t2.getMaxZoom();
    n2 === 1 / 0 && (n2 = t2.getZoom());
    let s2 = t2.project(e2, n2), a = t2.project(i, n2), o = t2.project(r2, n2), l2 = L.LineUtil.closestPointOnSegment(s2, a, o);
    return t2.unproject(l2, n2);
  }, _getDistanceToSegment(t2, e2, i, r2) {
    let n2 = t2.latLngToLayerPoint(e2), s2 = t2.latLngToLayerPoint(i), a = t2.latLngToLayerPoint(r2);
    return L.LineUtil.pointToSegmentDistance(n2, s2, a);
  }, _getDistance(t2, e2, i) {
    return t2.latLngToLayerPoint(e2).distanceTo(t2.latLngToLayerPoint(i));
  } }, Fe2 = um;
  var cm = L.Class.extend({ includes: [Fe2, Tt], options: { snappable: true, snapDistance: 20, snapMiddle: false, allowSelfIntersection: true, tooltips: true, templineStyle: {}, hintlineStyle: { color: "#3388ff", dashArray: "5,5" }, pathOptions: null, cursorMarker: true, finishOn: null, markerStyle: { draggable: true, icon: L.icon() }, hideMiddleMarkers: false, minRadiusCircle: null, maxRadiusCircle: null, minRadiusCircleMarker: null, maxRadiusCircleMarker: null, resizeableCircleMarker: false, resizableCircle: true, markerEditable: true, continueDrawing: false, snapSegment: true, requireSnapToFinish: false, rectangleAngle: 0 }, setOptions(t2) {
    L.Util.setOptions(this, t2), this.setStyle(this.options);
  }, setStyle() {
  }, getOptions() {
    return this.options;
  }, initialize(t2) {
    let e2 = new L.Icon.Default();
    e2.options.tooltipAnchor = [0, 0], this.options.markerStyle.icon = e2, this._map = t2, this.shapes = ["Marker", "CircleMarker", "Line", "Polygon", "Rectangle", "Circle", "Cut", "Text"], this.shapes.forEach((i) => {
      this[i] = new L.PM.Draw[i](this._map);
    }), this.Marker.setOptions({ continueDrawing: true }), this.CircleMarker.setOptions({ continueDrawing: true });
  }, setPathOptions(t2, e2 = false) {
    e2 ? this.options.pathOptions = (0, Yo.default)(this.options.pathOptions, t2) : this.options.pathOptions = t2;
  }, getShapes() {
    return this.shapes;
  }, getShape() {
    return this._shape;
  }, enable(t2, e2) {
    if (!t2) throw new Error(`Error: Please pass a shape as a parameter. Possible shapes are: ${this.getShapes().join(",")}`);
    this.disable(), this[t2].enable(e2);
  }, disable() {
    this.shapes.forEach((t2) => {
      this[t2].disable();
    });
  }, addControls() {
    this.shapes.forEach((t2) => {
      this[t2].addButton();
    });
  }, getActiveShape() {
    let t2;
    return this.shapes.forEach((e2) => {
      this[e2]._enabled && (t2 = e2);
    }), t2;
  }, _setGlobalDrawMode() {
    this._shape === "Cut" ? this._fireGlobalCutModeToggled() : this._fireGlobalDrawModeToggled();
    let t2 = [];
    this._map.eachLayer((e2) => {
      (e2 instanceof L.Polyline || e2 instanceof L.Marker || e2 instanceof L.Circle || e2 instanceof L.CircleMarker || e2 instanceof L.ImageOverlay) && (e2._pmTempLayer || t2.push(e2));
    }), this._enabled ? t2.forEach((e2) => {
      L.PM.Utils.disablePopup(e2);
    }) : t2.forEach((e2) => {
      L.PM.Utils.enablePopup(e2);
    });
  }, createNewDrawInstance(t2, e2) {
    let i = this._getShapeFromBtnName(e2);
    if (this[t2]) throw new TypeError("Draw Type already exists");
    if (!L.PM.Draw[i]) throw new TypeError(`There is no class L.PM.Draw.${i}`);
    return this[t2] = new L.PM.Draw[i](this._map), this[t2].toolbarButtonName = t2, this[t2]._shape = t2, this.shapes.push(t2), this[e2] && this[t2].setOptions(this[e2].options), this[t2].setOptions(this[t2].options), this[t2];
  }, _getShapeFromBtnName(t2) {
    let e2 = { drawMarker: "Marker", drawCircle: "Circle", drawPolygon: "Polygon", drawPolyline: "Line", drawRectangle: "Rectangle", drawCircleMarker: "CircleMarker", editMode: "Edit", dragMode: "Drag", cutPolygon: "Cut", removalMode: "Removal", rotateMode: "Rotate", drawText: "Text" };
    return e2[t2] ? e2[t2] : this[t2] ? this[t2]._shape : t2;
  }, _finishLayer(t2) {
    t2.pm && (t2.pm.setOptions(this.options), t2.pm._shape = this._shape, t2.pm._map = this._map), this._addDrawnLayerProp(t2);
  }, _addDrawnLayerProp(t2) {
    t2._drawnByGeoman = true;
  }, _setPane(t2, e2) {
    e2 === "layerPane" ? t2.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.layerPane || "overlayPane" : e2 === "vertexPane" ? t2.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.vertexPane || "markerPane" : e2 === "markerPane" && (t2.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.markerPane || "markerPane");
  }, _isFirstLayer() {
    return (this._map || this._layer._map).pm.getGeomanLayers().length === 0;
  } }), X2 = cm;
  X2.Marker = X2.extend({ initialize(t2) {
    this._map = t2, this._shape = "Marker", this.toolbarButtonName = "drawMarker";
  }, enable(t2) {
    L.Util.setOptions(this, t2), this._enabled = true, this._map.getContainer().classList.add("geoman-draw-cursor"), this._map.on("click", this._createMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true), this._hintMarker = L.marker(this._map.getCenter(), this.options.markerStyle), this._setPane(this._hintMarker, "markerPane"), this._hintMarker._pmTempLayer = true, this._hintMarker.addTo(this._map), this.options.tooltips && this._hintMarker.bindTooltip(V2("tooltips.placeMarker"), { permanent: true, offset: L.point(0, 10), direction: "bottom", opacity: 0.8 }).openTooltip(), this._layer = this._hintMarker, this._map.on("mousemove", this._syncHintMarker, this), this.options.markerEditable && this._map.eachLayer((e2) => {
      this.isRelevantMarker(e2) && e2.pm.enable();
    }), this._fireDrawStart(), this._setGlobalDrawMode();
  }, disable() {
    this._enabled && (this._enabled = false, this._map.getContainer().classList.remove("geoman-draw-cursor"), this._map.off("click", this._createMarker, this), this._hintMarker.remove(), this._map.off("mousemove", this._syncHintMarker, this), this._map.eachLayer((t2) => {
      this.isRelevantMarker(t2) && t2.pm.disable();
    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());
  }, enabled() {
    return this._enabled;
  }, toggle(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, isRelevantMarker(t2) {
    return t2 instanceof L.Marker && t2.pm && !t2._pmTempLayer && !t2.pm._initTextMarker;
  }, _syncHintMarker(t2) {
    if (this._hintMarker.setLatLng(t2.latlng), this.options.snappable) {
      let e2 = t2;
      e2.target = this._hintMarker, this._handleSnapping(e2);
    }
    this._fireChange(this._hintMarker.getLatLng(), "Draw");
  }, _createMarker(t2) {
    if (!t2.latlng || this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer()) return;
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng(), i = new L.Marker(e2, this.options.markerStyle);
    this._setPane(i, "markerPane"), this._finishLayer(i), i.pm || (i.options.draggable = false), i.addTo(this._map.pm._getContainingLayer()), i.pm && this.options.markerEditable ? i.pm.enable() : i.dragging && i.dragging.disable(), this._fireCreate(i), this._cleanupSnapping(), this.options.continueDrawing || this.disable();
  }, setStyle() {
    var _a3, _b2;
    ((_a3 = this.options.markerStyle) == null ? void 0 : _a3.icon) && ((_b2 = this._hintMarker) == null ? void 0 : _b2.setIcon(this.options.markerStyle.icon));
  } });
  var at = 63710088e-1, Jo = { centimeters: at * 100, centimetres: at * 100, degrees: at / 111325, feet: at * 3.28084, inches: at * 39.37, kilometers: at / 1e3, kilometres: at / 1e3, meters: at, metres: at, miles: at / 1609.344, millimeters: at * 1e3, millimetres: at * 1e3, nauticalmiles: at / 1852, radians: 1, yards: at * 1.0936 };
  function Dt(t2, e2, i) {
    i === void 0 && (i = {});
    var r2 = { type: "Feature" };
    return (i.id === 0 || i.id) && (r2.id = i.id), i.bbox && (r2.bbox = i.bbox), r2.properties = e2 || {}, r2.geometry = t2, r2;
  }
  function _t(t2, e2, i) {
    if (i === void 0 && (i = {}), !t2) throw new Error("coordinates is required");
    if (!Array.isArray(t2)) throw new Error("coordinates must be an Array");
    if (t2.length < 2) throw new Error("coordinates must be at least 2 numbers long");
    if (!Si2(t2[0]) || !Si2(t2[1])) throw new Error("coordinates must contain numbers");
    var r2 = { type: "Point", coordinates: t2 };
    return Dt(r2, e2, i);
  }
  function wt(t2, e2, i) {
    if (i === void 0 && (i = {}), t2.length < 2) throw new Error("coordinates must be an array of two or more positions");
    var r2 = { type: "LineString", coordinates: t2 };
    return Dt(r2, e2, i);
  }
  function yt(t2, e2) {
    e2 === void 0 && (e2 = {});
    var i = { type: "FeatureCollection" };
    return e2.id && (i.id = e2.id), e2.bbox && (i.bbox = e2.bbox), i.features = t2, i;
  }
  function $o(t2, e2) {
    e2 === void 0 && (e2 = "kilometers");
    var i = Jo[e2];
    if (!i) throw new Error(e2 + " units is invalid");
    return t2 * i;
  }
  function Zo(t2, e2) {
    e2 === void 0 && (e2 = "kilometers");
    var i = Jo[e2];
    if (!i) throw new Error(e2 + " units is invalid");
    return t2 / i;
  }
  function Me2(t2) {
    var e2 = t2 % (2 * Math.PI);
    return e2 * 180 / Math.PI;
  }
  function lt(t2) {
    var e2 = t2 % 360;
    return e2 * Math.PI / 180;
  }
  function Si2(t2) {
    return !isNaN(t2) && t2 !== null && !Array.isArray(t2);
  }
  function zt(t2) {
    var e2, i, r2 = { type: "FeatureCollection", features: [] };
    if (t2.type === "Feature" ? i = t2.geometry : i = t2, i.type === "LineString") e2 = [i.coordinates];
    else if (i.type === "MultiLineString") e2 = i.coordinates;
    else if (i.type === "MultiPolygon") e2 = [].concat.apply([], i.coordinates);
    else if (i.type === "Polygon") e2 = i.coordinates;
    else throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
    return e2.forEach(function(n2) {
      e2.forEach(function(s2) {
        for (var a = 0; a < n2.length - 1; a++) for (var o = a; o < s2.length - 1; o++) if (!(n2 === s2 && (Math.abs(a - o) === 1 || a === 0 && o === n2.length - 2 && n2[a][0] === n2[n2.length - 1][0] && n2[a][1] === n2[n2.length - 1][1]))) {
          var l2 = pm(n2[a][0], n2[a][1], n2[a + 1][0], n2[a + 1][1], s2[o][0], s2[o][1], s2[o + 1][0], s2[o + 1][1]);
          l2 && r2.features.push(_t([l2[0], l2[1]]));
        }
      });
    }), r2;
  }
  function pm(t2, e2, i, r2, n2, s2, a, o) {
    var l2, u2, f2, d, P2, E2 = { x: null, y: null, onLine1: false, onLine2: false };
    return l2 = (o - s2) * (i - t2) - (a - n2) * (r2 - e2), l2 === 0 ? E2.x !== null && E2.y !== null ? E2 : false : (u2 = e2 - s2, f2 = t2 - n2, d = (a - n2) * u2 - (o - s2) * f2, P2 = (i - t2) * u2 - (r2 - e2) * f2, u2 = d / l2, f2 = P2 / l2, E2.x = t2 + u2 * (i - t2), E2.y = e2 + u2 * (r2 - e2), u2 >= 0 && u2 <= 1 && (E2.onLine1 = true), f2 >= 0 && f2 <= 1 && (E2.onLine2 = true), E2.onLine1 && E2.onLine2 ? [E2.x, E2.y] : false);
  }
  X2.Line = X2.extend({ initialize(t2) {
    this._map = t2, this._shape = "Line", this.toolbarButtonName = "drawPolyline", this._doesSelfIntersect = false;
  }, enable(t2) {
    L.Util.setOptions(this, t2), this._enabled = true, this._markers = [], this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = true, this._layerGroup.addTo(this._map), this._layer = L.polyline([], { ...this.options.templineStyle, pmIgnore: false }), this._setPane(this._layer, "layerPane"), this._layer._pmTempLayer = true, this._layerGroup.addLayer(this._layer), this._hintline = L.polyline([], this.options.hintlineStyle), this._setPane(this._hintline, "layerPane"), this._hintline._pmTempLayer = true, this._layerGroup.addLayer(this._hintline), this._hintMarker = L.marker(this._map.getCenter(), { interactive: false, zIndexOffset: 100, icon: L.divIcon({ className: "marker-icon cursor-marker" }) }), this._setPane(this._hintMarker, "vertexPane"), this._hintMarker._pmTempLayer = true, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, "visible"), this.options.tooltips && this._hintMarker.bindTooltip(V2("tooltips.firstVertex"), { permanent: true, offset: L.point(0, 10), direction: "bottom", opacity: 0.8 }).openTooltip(), this._map.getContainer().classList.add("geoman-draw-cursor"), this._map.on("click", this._createVertex, this), this.options.finishOn && this.options.finishOn !== "snap" && this._map.on(this.options.finishOn, this._finishShape, this), this.options.finishOn === "dblclick" && (this.tempMapDoubleClickZoomState = this._map.doubleClickZoom._enabled, this.tempMapDoubleClickZoomState && this._map.doubleClickZoom.disable()), this._map.on("mousemove", this._syncHintMarker, this), this._hintMarker.on("move", this._syncHintLine, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true), this._otherSnapLayers = [], this.isRed = false, this._fireDrawStart(), this._setGlobalDrawMode();
  }, disable() {
    this._enabled && (this._enabled = false, this._map.getContainer().classList.remove("geoman-draw-cursor"), this._map.off("click", this._createVertex, this), this._map.off("mousemove", this._syncHintMarker, this), this.options.finishOn && this.options.finishOn !== "snap" && this._map.off(this.options.finishOn, this._finishShape, this), this.tempMapDoubleClickZoomState && this._map.doubleClickZoom.enable(), this._map.removeLayer(this._layerGroup), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());
  }, enabled() {
    return this._enabled;
  }, toggle(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, _syncHintLine() {
    let t2 = this._layer.getLatLngs();
    if (t2.length > 0) {
      let e2 = t2[t2.length - 1];
      this._hintline.setLatLngs([e2, this._hintMarker.getLatLng()]);
    }
  }, _syncHintMarker(t2) {
    if (this._hintMarker.setLatLng(t2.latlng), this.options.snappable) {
      let i = t2;
      i.target = this._hintMarker, this._handleSnapping(i);
    }
    this.options.allowSelfIntersection || this._handleSelfIntersection(true, this._hintMarker.getLatLng());
    let e2 = this._layer._defaultShape().slice();
    e2.push(this._hintMarker.getLatLng()), this._change(e2);
  }, hasSelfIntersection() {
    return zt(this._layer.toGeoJSON(15)).features.length > 0;
  }, _handleSelfIntersection(t2, e2) {
    let i = L.polyline(this._layer.getLatLngs());
    t2 && (e2 || (e2 = this._hintMarker.getLatLng()), i.addLatLng(e2));
    let r2 = zt(i.toGeoJSON(15));
    this._doesSelfIntersect = r2.features.length > 0, this._doesSelfIntersect ? this.isRed || (this.isRed = true, this._hintline.setStyle({ color: "#f00000ff" }), this._fireIntersect(r2, this._map, "Draw")) : this._hintline.isEmpty() || (this.isRed = false, this._hintline.setStyle(this.options.hintlineStyle));
  }, _createVertex(t2) {
    if (!this.options.allowSelfIntersection && (this._handleSelfIntersection(true, t2.latlng), this._doesSelfIntersect)) return;
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng(), i = this._layer.getLatLngs(), r2 = i[i.length - 1];
    if (e2.equals(i[0]) || i.length > 0 && e2.equals(r2)) {
      this._finishShape();
      return;
    }
    this._layer._latlngInfo = this._layer._latlngInfo || [], this._layer._latlngInfo.push({ latlng: e2, snapInfo: this._hintMarker._snapInfo }), this._layer.addLatLng(e2);
    let n2 = this._createMarker(e2);
    this._setTooltipText(), this._setHintLineAfterNewVertex(e2), this._fireVertexAdded(n2, void 0, e2, "Draw"), this._change(this._layer.getLatLngs()), this.options.finishOn === "snap" && this._hintMarker._snapped && this._finishShape(t2);
  }, _setHintLineAfterNewVertex(t2) {
    this._hintline.setLatLngs([t2, t2]);
  }, _removeLastVertex() {
    let t2 = this._markers;
    if (t2.length <= 1) {
      this.disable();
      return;
    }
    let e2 = this._layer.getLatLngs(), i = t2[t2.length - 1], { indexPath: r2 } = L.PM.Utils.findDeepMarkerIndex(t2, i);
    t2.pop(), this._layerGroup.removeLayer(i);
    let n2 = t2[t2.length - 1], s2 = e2.indexOf(n2.getLatLng());
    e2 = e2.slice(0, s2 + 1), this._layer.setLatLngs(e2), this._layer._latlngInfo.pop(), this._syncHintLine(), this._setTooltipText(), this._fireVertexRemoved(i, r2, "Draw"), this._change(this._layer.getLatLngs());
  }, _finishShape() {
    if (!this.options.allowSelfIntersection && (this._handleSelfIntersection(false), this._doesSelfIntersect) || this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer()) return;
    let t2 = this._layer.getLatLngs();
    if (t2.length <= 1) return;
    let e2 = L.polyline(t2, this.options.pathOptions);
    this._setPane(e2, "layerPane"), this._finishLayer(e2), e2.addTo(this._map.pm._getContainingLayer()), this._fireCreate(e2), this.options.snappable && this._cleanupSnapping(), this.disable(), this.options.continueDrawing && this.enable();
  }, _createMarker(t2) {
    let e2 = new L.Marker(t2, { draggable: false, icon: L.divIcon({ className: "marker-icon" }) });
    return this._setPane(e2, "vertexPane"), e2._pmTempLayer = true, this._layerGroup.addLayer(e2), this._markers.push(e2), e2.on("click", this._finishShape, this), e2;
  }, _setTooltipText() {
    let { length: t2 } = this._layer.getLatLngs().flat(), e2 = "";
    t2 <= 1 ? e2 = V2("tooltips.continueLine") : e2 = V2("tooltips.finishLine"), this._hintMarker.setTooltipContent(e2);
  }, _change(t2) {
    this._fireChange(t2, "Draw");
  }, setStyle() {
    var _a3, _b2;
    (_a3 = this._layer) == null ? void 0 : _a3.setStyle(this.options.templineStyle), (_b2 = this._hintline) == null ? void 0 : _b2.setStyle(this.options.hintlineStyle);
  } });
  X2.Polygon = X2.Line.extend({ initialize(t2) {
    this._map = t2, this._shape = "Polygon", this.toolbarButtonName = "drawPolygon";
  }, enable(t2) {
    L.PM.Draw.Line.prototype.enable.call(this, t2), this._layer.pm._shape = "Polygon";
  }, _createMarker(t2) {
    let e2 = new L.Marker(t2, { draggable: false, icon: L.divIcon({ className: "marker-icon" }) });
    return this._setPane(e2, "vertexPane"), e2._pmTempLayer = true, this._layerGroup.addLayer(e2), this._markers.push(e2), this._layer.getLatLngs().flat().length === 1 ? (e2.on("click", this._finishShape, this), this._tempSnapLayerIndex = this._otherSnapLayers.push(e2) - 1, this.options.snappable && this._cleanupSnapping()) : e2.on("click", () => 1), e2;
  }, _setTooltipText() {
    let { length: t2 } = this._layer.getLatLngs().flat(), e2 = "";
    t2 <= 2 ? e2 = V2("tooltips.continueLine") : e2 = V2("tooltips.finishPoly"), this._hintMarker.setTooltipContent(e2);
  }, _finishShape() {
    if (!this.options.allowSelfIntersection && (this._handleSelfIntersection(true, this._layer.getLatLngs()[0]), this._doesSelfIntersect) || this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer()) return;
    let t2 = this._layer.getLatLngs();
    if (t2.length <= 2) return;
    let e2 = L.polygon(t2, this.options.pathOptions);
    this._setPane(e2, "layerPane"), this._finishLayer(e2), e2.addTo(this._map.pm._getContainingLayer()), this._fireCreate(e2), this._cleanupSnapping(), this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1), delete this._tempSnapLayerIndex, this.disable(), this.options.continueDrawing && this.enable();
  } });
  X2.Rectangle = X2.extend({ initialize(t2) {
    this._map = t2, this._shape = "Rectangle", this.toolbarButtonName = "drawRectangle";
  }, enable(t2) {
    if (L.Util.setOptions(this, t2), this._enabled = true, this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = true, this._layerGroup.addTo(this._map), this._layer = L.rectangle([[0, 0], [0, 0]], this.options.pathOptions), this._setPane(this._layer, "layerPane"), this._layer._pmTempLayer = true, this._startMarker = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "marker-icon rect-start-marker" }), draggable: false, zIndexOffset: -100, opacity: this.options.cursorMarker ? 1 : 0 }), this._setPane(this._startMarker, "vertexPane"), this._startMarker._pmTempLayer = true, this._layerGroup.addLayer(this._startMarker), this._hintMarker = L.marker(this._map.getCenter(), { zIndexOffset: 150, icon: L.divIcon({ className: "marker-icon cursor-marker" }) }), this._setPane(this._hintMarker, "vertexPane"), this._hintMarker._pmTempLayer = true, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, "visible"), this.options.tooltips && this._hintMarker.bindTooltip(V2("tooltips.firstVertex"), { permanent: true, offset: L.point(0, 10), direction: "bottom", opacity: 0.8 }).openTooltip(), this.options.cursorMarker) {
      this._styleMarkers = [];
      for (let e2 = 0; e2 < 2; e2 += 1) {
        let i = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "marker-icon rect-style-marker" }), draggable: false, zIndexOffset: 100 });
        this._setPane(i, "vertexPane"), i._pmTempLayer = true, this._layerGroup.addLayer(i), this._styleMarkers.push(i);
      }
    }
    this._map.getContainer().classList.add("geoman-draw-cursor"), this._map.on("click", this._placeStartingMarkers, this), this._map.on("mousemove", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true), this._otherSnapLayers = [], this._fireDrawStart(), this._setGlobalDrawMode();
  }, disable() {
    this._enabled && (this._enabled = false, this._map.getContainer().classList.remove("geoman-draw-cursor"), this._map.off("click", this._finishShape, this), this._map.off("click", this._placeStartingMarkers, this), this._map.off("mousemove", this._syncHintMarker, this), this._map.removeLayer(this._layerGroup), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());
  }, enabled() {
    return this._enabled;
  }, toggle(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, _placeStartingMarkers(t2) {
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng();
    L.DomUtil.addClass(this._startMarker._icon, "visible"), this._startMarker.setLatLng(e2), this.options.cursorMarker && this._styleMarkers && this._styleMarkers.forEach((i) => {
      L.DomUtil.addClass(i._icon, "visible"), i.setLatLng(e2);
    }), this._map.off("click", this._placeStartingMarkers, this), this._map.on("click", this._finishShape, this), this._hintMarker.setTooltipContent(V2("tooltips.finishRect")), this._setRectangleOrigin();
  }, _setRectangleOrigin() {
    let t2 = this._startMarker.getLatLng();
    t2 && (this._layerGroup.addLayer(this._layer), this._layer.setLatLngs([t2, t2]), this._hintMarker.on("move", this._syncRectangleSize, this));
  }, _syncHintMarker(t2) {
    if (this._hintMarker.setLatLng(t2.latlng), this.options.snappable) {
      let i = t2;
      i.target = this._hintMarker, this._handleSnapping(i);
    }
    let e2 = this._layerGroup && this._layerGroup.hasLayer(this._layer) ? this._layer.getLatLngs() : [this._hintMarker.getLatLng()];
    this._fireChange(e2, "Draw");
  }, _syncRectangleSize() {
    let t2 = Ei2(this._startMarker.getLatLng(), this._map), e2 = Ei2(this._hintMarker.getLatLng(), this._map), i = L.PM.Utils._getRotatedRectangle(t2, e2, this.options.rectangleAngle || 0, this._map);
    if (this._layer.setLatLngs(i), this.options.cursorMarker && this._styleMarkers) {
      let r2 = [];
      i.forEach((n2) => {
        !n2.equals(t2, 1e-8) && !n2.equals(e2, 1e-8) && r2.push(n2);
      }), r2.forEach((n2, s2) => {
        try {
          this._styleMarkers[s2].setLatLng(n2);
        } catch {
        }
      });
    }
  }, _findCorners() {
    let t2 = this._layer.getLatLngs()[0];
    return L.PM.Utils._getRotatedRectangle(t2[0], t2[2], this.options.rectangleAngle || 0, this._map);
  }, _finishShape(t2) {
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng(), i = this._startMarker.getLatLng();
    if (this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer() || i.equals(e2)) return;
    let r2 = L.rectangle([i, e2], this.options.pathOptions);
    if (this.options.rectangleAngle) {
      let n2 = L.PM.Utils._getRotatedRectangle(i, e2, this.options.rectangleAngle || 0, this._map);
      r2.setLatLngs(n2), r2.pm && r2.pm._setAngle(this.options.rectangleAngle || 0);
    }
    this._setPane(r2, "layerPane"), this._finishLayer(r2), r2.addTo(this._map.pm._getContainingLayer()), this._fireCreate(r2), this.disable(), this.options.continueDrawing && this.enable();
  }, setStyle() {
    var _a3;
    (_a3 = this._layer) == null ? void 0 : _a3.setStyle(this.options.pathOptions);
  } });
  X2.CircleMarker = X2.extend({ initialize(t2) {
    this._map = t2, this._shape = "CircleMarker", this.toolbarButtonName = "drawCircleMarker", this._layerIsDragging = false, this._BaseCircleClass = L.CircleMarker, this._minRadiusOption = "minRadiusCircleMarker", this._maxRadiusOption = "maxRadiusCircleMarker", this._editableOption = "resizeableCircleMarker", this._defaultRadius = 10;
  }, enable(t2) {
    if (L.Util.setOptions(this, t2), this.options.editable && (this.options.resizeableCircleMarker = this.options.editable, delete this.options.editable), this._enabled = true, this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true), this._map.getContainer().classList.add("geoman-draw-cursor"), this.options[this._editableOption]) {
      let e2 = {};
      L.extend(e2, this.options.templineStyle), e2.radius = 0, this._layerGroup = new L.FeatureGroup(), this._layerGroup._pmTempLayer = true, this._layerGroup.addTo(this._map), this._layer = new this._BaseCircleClass(this._map.getCenter(), e2), this._setPane(this._layer, "layerPane"), this._layer._pmTempLayer = true, this._centerMarker = L.marker(this._map.getCenter(), { icon: L.divIcon({ className: "marker-icon" }), draggable: false, zIndexOffset: 100 }), this._setPane(this._centerMarker, "vertexPane"), this._centerMarker._pmTempLayer = true, this._hintMarker = L.marker(this._map.getCenter(), { zIndexOffset: 110, icon: L.divIcon({ className: "marker-icon cursor-marker" }) }), this._setPane(this._hintMarker, "vertexPane"), this._hintMarker._pmTempLayer = true, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, "visible"), this.options.tooltips && this._hintMarker.bindTooltip(V2("tooltips.startCircle"), { permanent: true, offset: L.point(0, 10), direction: "bottom", opacity: 0.8 }).openTooltip(), this._hintline = L.polyline([], this.options.hintlineStyle), this._setPane(this._hintline, "layerPane"), this._hintline._pmTempLayer = true, this._layerGroup.addLayer(this._hintline), this._map.on("click", this._placeCenterMarker, this);
    } else this._map.on("click", this._createMarker, this), this._hintMarker = new this._BaseCircleClass(this._map.getCenter(), { radius: this._defaultRadius, ...this.options.templineStyle }), this._setPane(this._hintMarker, "layerPane"), this._hintMarker._pmTempLayer = true, this._hintMarker.addTo(this._map), this._layer = this._hintMarker, this.options.tooltips && this._hintMarker.bindTooltip(V2("tooltips.placeCircleMarker"), { permanent: true, offset: L.point(0, 10), direction: "bottom", opacity: 0.8 }).openTooltip();
    this._map.on("mousemove", this._syncHintMarker, this), this._extendingEnable(), this._otherSnapLayers = [], this._fireDrawStart(), this._setGlobalDrawMode();
  }, _extendingEnable() {
    !this.options[this._editableOption] && this.options.markerEditable && this._map.eachLayer((t2) => {
      this.isRelevantMarker(t2) && t2.pm.enable();
    }), this._layer.bringToBack();
  }, disable() {
    this._enabled && (this._enabled = false, this._map.getContainer().classList.remove("geoman-draw-cursor"), this.options[this._editableOption] ? (this._map.off("click", this._finishShape, this), this._map.off("click", this._placeCenterMarker, this), this._map.removeLayer(this._layerGroup)) : (this._map.off("click", this._createMarker, this), this._extendingDisable(), this._hintMarker.remove()), this._map.off("mousemove", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());
  }, _extendingDisable() {
    this._map.eachLayer((t2) => {
      this.isRelevantMarker(t2) && t2.pm.disable();
    });
  }, enabled() {
    return this._enabled;
  }, toggle(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, _placeCenterMarker(t2) {
    this._layerGroup.addLayer(this._layer), this._layerGroup.addLayer(this._centerMarker), this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng();
    this._layerGroup.addLayer(this._layer), this._centerMarker.setLatLng(e2), this._map.off("click", this._placeCenterMarker, this), this._map.on("click", this._finishShape, this), this._placeCircleCenter();
  }, _placeCircleCenter() {
    let t2 = this._centerMarker.getLatLng();
    t2 && (this._layer.setLatLng(t2), this._hintMarker.on("move", this._syncHintLine, this), this._hintMarker.on("move", this._syncCircleRadius, this), this._hintMarker.setTooltipContent(V2("tooltips.finishCircle")), this._fireCenterPlaced(), this._fireChange(this._layer.getLatLng(), "Draw"));
  }, _syncHintLine() {
    let t2 = this._centerMarker.getLatLng(), e2 = this._getNewDestinationOfHintMarker();
    this._hintline.setLatLngs([t2, e2]);
  }, _syncCircleRadius() {
    let t2 = this._centerMarker.getLatLng(), e2 = this._hintMarker.getLatLng(), i = this._distanceCalculation(t2, e2);
    this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? this._layer.setRadius(this.options[this._minRadiusOption]) : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] ? this._layer.setRadius(this.options[this._maxRadiusOption]) : this._layer.setRadius(i);
  }, _syncHintMarker(t2) {
    if (this._hintMarker.setLatLng(t2.latlng), this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker()), this.options.snappable) {
      let i = t2;
      i.target = this._hintMarker, this._handleSnapping(i);
    }
    this._handleHintMarkerSnapping();
    let e2 = this._layerGroup && this._layerGroup.hasLayer(this._centerMarker) ? this._centerMarker.getLatLng() : this._hintMarker.getLatLng();
    this._fireChange(e2, "Draw");
  }, isRelevantMarker(t2) {
    return t2 instanceof L.CircleMarker && !(t2 instanceof L.Circle) && t2.pm && !t2._pmTempLayer;
  }, _createMarker(t2) {
    if (this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer() || !t2.latlng || this._layerIsDragging) return;
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng(), i = new this._BaseCircleClass(e2, { radius: this._defaultRadius, ...this.options.pathOptions });
    this._setPane(i, "layerPane"), this._finishLayer(i), i.addTo(this._map.pm._getContainingLayer()), this._extendingCreateMarker(i), this._fireCreate(i), this._cleanupSnapping(), this.options.continueDrawing || this.disable();
  }, _extendingCreateMarker(t2) {
    t2.pm && this.options.markerEditable && t2.pm.enable();
  }, _finishShape(t2) {
    if (this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer()) return;
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._centerMarker.getLatLng(), i = this._defaultRadius;
    if (this.options[this._editableOption]) {
      let s2 = this._hintMarker.getLatLng();
      i = this._distanceCalculation(e2, s2), this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? i = this.options[this._minRadiusOption] : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] && (i = this.options[this._maxRadiusOption]);
    }
    let r2 = { ...this.options.pathOptions, radius: i }, n2 = new this._BaseCircleClass(e2, r2);
    this._setPane(n2, "layerPane"), this._finishLayer(n2), n2.addTo(this._map.pm._getContainingLayer()), n2.pm && n2.pm._updateHiddenPolyCircle(), this._fireCreate(n2), this.disable(), this.options.continueDrawing && this.enable();
  }, _getNewDestinationOfHintMarker() {
    let t2 = this._hintMarker.getLatLng();
    if (this.options[this._editableOption]) {
      if (!this._layerGroup.hasLayer(this._centerMarker)) return t2;
      let e2 = this._centerMarker.getLatLng(), i = this._distanceCalculation(e2, t2);
      this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? t2 = te2(this._map, e2, t2, this._getMinDistanceInMeter()) : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] && (t2 = te2(this._map, e2, t2, this._getMaxDistanceInMeter()));
    }
    return t2;
  }, _getMinDistanceInMeter() {
    return L.PM.Utils.pxRadiusToMeterRadius(this.options[this._minRadiusOption], this._map, this._centerMarker.getLatLng());
  }, _getMaxDistanceInMeter() {
    return L.PM.Utils.pxRadiusToMeterRadius(this.options[this._maxRadiusOption], this._map, this._centerMarker.getLatLng());
  }, _handleHintMarkerSnapping() {
    if (this.options[this._editableOption]) {
      if (this._hintMarker._snapped) {
        let t2 = this._centerMarker.getLatLng(), e2 = this._hintMarker.getLatLng(), i = this._distanceCalculation(t2, e2);
        this._layerGroup.hasLayer(this._centerMarker) && (this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? this._hintMarker.setLatLng(this._hintMarker._orgLatLng) : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] && this._hintMarker.setLatLng(this._hintMarker._orgLatLng));
      }
      this._hintMarker.setLatLng(this._getNewDestinationOfHintMarker());
    }
  }, setStyle() {
    var _a3, _b2;
    let t2 = {};
    L.extend(t2, this.options.templineStyle), this.options[this._editableOption] && (t2.radius = 0), (_a3 = this._layer) == null ? void 0 : _a3.setStyle(t2), (_b2 = this._hintline) == null ? void 0 : _b2.setStyle(this.options.hintlineStyle);
  }, _distanceCalculation(t2, e2) {
    return this._map.project(t2).distanceTo(this._map.project(e2));
  } });
  X2.Circle = X2.CircleMarker.extend({ initialize(t2) {
    this._map = t2, this._shape = "Circle", this.toolbarButtonName = "drawCircle", this._BaseCircleClass = L.Circle, this._minRadiusOption = "minRadiusCircle", this._maxRadiusOption = "maxRadiusCircle", this._editableOption = "resizableCircle", this._defaultRadius = 100;
  }, _extendingEnable() {
  }, _extendingDisable() {
  }, _extendingCreateMarker() {
  }, isRelevantMarker() {
  }, _getMinDistanceInMeter() {
    return this.options[this._minRadiusOption];
  }, _getMaxDistanceInMeter() {
    return this.options[this._maxRadiusOption];
  }, _distanceCalculation(t2, e2) {
    return this._map.distance(t2, e2);
  } });
  function rt(t2) {
    if (!t2) throw new Error("coord is required");
    if (!Array.isArray(t2)) {
      if (t2.type === "Feature" && t2.geometry !== null && t2.geometry.type === "Point") return t2.geometry.coordinates;
      if (t2.type === "Point") return t2.coordinates;
    }
    if (Array.isArray(t2) && t2.length >= 2 && !Array.isArray(t2[0]) && !Array.isArray(t2[1])) return t2;
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function ot(t2) {
    if (Array.isArray(t2)) return t2;
    if (t2.type === "Feature") {
      if (t2.geometry !== null) return t2.geometry.coordinates;
    } else if (t2.coordinates) return t2.coordinates;
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
  }
  function ee2(t2) {
    return t2.type === "Feature" ? t2.geometry : t2;
  }
  function Bi2(t2, e2) {
    return t2.type === "FeatureCollection" ? "FeatureCollection" : t2.type === "GeometryCollection" ? "GeometryCollection" : t2.type === "Feature" && t2.geometry !== null ? t2.geometry.type : t2.type;
  }
  function xe(t2, e2, i) {
    if (t2 !== null) for (var r2, n2, s2, a, o, l2, u2, f2 = 0, d = 0, P2, E2 = t2.type, T2 = E2 === "FeatureCollection", G2 = E2 === "Feature", _ = T2 ? t2.features.length : 1, x2 = 0; x2 < _; x2++) {
      u2 = T2 ? t2.features[x2].geometry : G2 ? t2.geometry : t2, P2 = u2 ? u2.type === "GeometryCollection" : false, o = P2 ? u2.geometries.length : 1;
      for (var b = 0; b < o; b++) {
        var R2 = 0, D2 = 0;
        if (a = P2 ? u2.geometries[b] : u2, a !== null) {
          l2 = a.coordinates;
          var O2 = a.type;
          switch (f2 = 0, O2) {
            case null:
              break;
            case "Point":
              if (e2(l2, d, x2, R2, D2) === false) return false;
              d++, R2++;
              break;
            case "LineString":
            case "MultiPoint":
              for (r2 = 0; r2 < l2.length; r2++) {
                if (e2(l2[r2], d, x2, R2, D2) === false) return false;
                d++, O2 === "MultiPoint" && R2++;
              }
              O2 === "LineString" && R2++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (r2 = 0; r2 < l2.length; r2++) {
                for (n2 = 0; n2 < l2[r2].length - f2; n2++) {
                  if (e2(l2[r2][n2], d, x2, R2, D2) === false) return false;
                  d++;
                }
                O2 === "MultiLineString" && R2++, O2 === "Polygon" && D2++;
              }
              O2 === "Polygon" && R2++;
              break;
            case "MultiPolygon":
              for (r2 = 0; r2 < l2.length; r2++) {
                for (D2 = 0, n2 = 0; n2 < l2[r2].length; n2++) {
                  for (s2 = 0; s2 < l2[r2][n2].length - f2; s2++) {
                    if (e2(l2[r2][n2][s2], d, x2, R2, D2) === false) return false;
                    d++;
                  }
                  D2++;
                }
                R2++;
              }
              break;
            case "GeometryCollection":
              for (r2 = 0; r2 < a.geometries.length; r2++) if (xe(a.geometries[r2], e2) === false) return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
  }
  function Ft(t2, e2) {
    if (t2.type === "Feature") e2(t2, 0);
    else if (t2.type === "FeatureCollection") for (var i = 0; i < t2.features.length && e2(t2.features[i], i) !== false; i++) ;
  }
  function Wo(t2, e2, i) {
    var r2 = i;
    return Ft(t2, function(n2, s2) {
      s2 === 0 && i === void 0 ? r2 = n2 : r2 = e2(r2, n2, s2);
    }), r2;
  }
  function fm(t2, e2) {
    var i, r2, n2, s2, a, o, l2, u2, f2, d, P2 = 0, E2 = t2.type === "FeatureCollection", T2 = t2.type === "Feature", G2 = E2 ? t2.features.length : 1;
    for (i = 0; i < G2; i++) {
      for (o = E2 ? t2.features[i].geometry : T2 ? t2.geometry : t2, u2 = E2 ? t2.features[i].properties : T2 ? t2.properties : {}, f2 = E2 ? t2.features[i].bbox : T2 ? t2.bbox : void 0, d = E2 ? t2.features[i].id : T2 ? t2.id : void 0, l2 = o ? o.type === "GeometryCollection" : false, a = l2 ? o.geometries.length : 1, n2 = 0; n2 < a; n2++) {
        if (s2 = l2 ? o.geometries[n2] : o, s2 === null) {
          if (e2(null, P2, u2, f2, d) === false) return false;
          continue;
        }
        switch (s2.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (e2(s2, P2, u2, f2, d) === false) return false;
            break;
          }
          case "GeometryCollection": {
            for (r2 = 0; r2 < s2.geometries.length; r2++) if (e2(s2.geometries[r2], P2, u2, f2, d) === false) return false;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      P2++;
    }
  }
  function ie2(t2, e2) {
    fm(t2, function(i, r2, n2, s2, a) {
      var o = i === null ? null : i.type;
      switch (o) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return e2(Dt(i, n2, { bbox: s2, id: a }), r2, 0) === false ? false : void 0;
      }
      var l2;
      switch (o) {
        case "MultiPoint":
          l2 = "Point";
          break;
        case "MultiLineString":
          l2 = "LineString";
          break;
        case "MultiPolygon":
          l2 = "Polygon";
          break;
      }
      for (var u2 = 0; u2 < i.coordinates.length; u2++) {
        var f2 = i.coordinates[u2], d = { type: l2, coordinates: f2 };
        if (e2(Dt(d, n2), r2, u2) === false) return false;
      }
    });
  }
  function dm(t2) {
    if (!t2) throw new Error("geojson is required");
    var e2 = [];
    return ie2(t2, function(i) {
      gm(i, e2);
    }), yt(e2);
  }
  function gm(t2, e2) {
    var i = [], r2 = t2.geometry;
    if (r2 !== null) {
      switch (r2.type) {
        case "Polygon":
          i = ot(r2);
          break;
        case "LineString":
          i = [ot(r2)];
      }
      i.forEach(function(n2) {
        var s2 = mm(n2, t2.properties);
        s2.forEach(function(a) {
          a.id = e2.length, e2.push(a);
        });
      });
    }
  }
  function mm(t2, e2) {
    var i = [];
    return t2.reduce(function(r2, n2) {
      var s2 = wt([r2, n2], e2);
      return s2.bbox = _m(r2, n2), i.push(s2), n2;
    }), i;
  }
  function _m(t2, e2) {
    var i = t2[0], r2 = t2[1], n2 = e2[0], s2 = e2[1], a = i < n2 ? i : n2, o = r2 < s2 ? r2 : s2, l2 = i > n2 ? i : n2, u2 = r2 > s2 ? r2 : s2;
    return [a, o, l2, u2];
  }
  var we2 = dm;
  var gl2 = xt(Ui2(), 1);
  function jm(t2, e2) {
    var i = {}, r2 = [];
    if (t2.type === "LineString" && (t2 = Dt(t2)), e2.type === "LineString" && (e2 = Dt(e2)), t2.type === "Feature" && e2.type === "Feature" && t2.geometry !== null && e2.geometry !== null && t2.geometry.type === "LineString" && e2.geometry.type === "LineString" && t2.geometry.coordinates.length === 2 && e2.geometry.coordinates.length === 2) {
      var n2 = dl2(t2, e2);
      return n2 && r2.push(n2), yt(r2);
    }
    var s2 = (0, gl2.default)();
    return s2.load(we2(e2)), Ft(we2(t2), function(a) {
      Ft(s2.search(a), function(o) {
        var l2 = dl2(a, o);
        if (l2) {
          var u2 = ot(l2).join(",");
          i[u2] || (i[u2] = true, r2.push(l2));
        }
      });
    }), yt(r2);
  }
  function dl2(t2, e2) {
    var i = ot(t2), r2 = ot(e2);
    if (i.length !== 2) throw new Error("<intersects> line1 must only contain 2 coordinates");
    if (r2.length !== 2) throw new Error("<intersects> line2 must only contain 2 coordinates");
    var n2 = i[0][0], s2 = i[0][1], a = i[1][0], o = i[1][1], l2 = r2[0][0], u2 = r2[0][1], f2 = r2[1][0], d = r2[1][1], P2 = (d - u2) * (a - n2) - (f2 - l2) * (o - s2), E2 = (f2 - l2) * (s2 - u2) - (d - u2) * (n2 - l2), T2 = (a - n2) * (s2 - u2) - (o - s2) * (n2 - l2);
    if (P2 === 0) return null;
    var G2 = E2 / P2, _ = T2 / P2;
    if (G2 >= 0 && G2 <= 1 && _ >= 0 && _ <= 1) {
      var x2 = n2 + G2 * (a - n2), b = s2 + G2 * (o - s2);
      return _t([x2, b]);
    }
    return null;
  }
  var pt = jm;
  var Xi2 = xt(Ui2(), 1);
  function Km(t2, e2, i) {
    i === void 0 && (i = {});
    var r2 = rt(t2), n2 = rt(e2), s2 = lt(n2[1] - r2[1]), a = lt(n2[0] - r2[0]), o = lt(r2[1]), l2 = lt(n2[1]), u2 = Math.pow(Math.sin(s2 / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(o) * Math.cos(l2);
    return $o(2 * Math.atan2(Math.sqrt(u2), Math.sqrt(1 - u2)), i.units);
  }
  var Ct = Km;
  function Hm(t2) {
    var e2 = t2[0], i = t2[1], r2 = t2[2], n2 = t2[3], s2 = Ct(t2.slice(0, 2), [r2, i]), a = Ct(t2.slice(0, 2), [e2, n2]);
    if (s2 >= a) {
      var o = (i + n2) / 2;
      return [e2, o - (r2 - e2) / 2, r2, o + (r2 - e2) / 2];
    } else {
      var l2 = (e2 + r2) / 2;
      return [l2 - (n2 - i) / 2, i, l2 + (n2 - i) / 2, n2];
    }
  }
  var ml2 = Hm;
  function ji2(t2) {
    var e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return xe(t2, function(i) {
      e2[0] > i[0] && (e2[0] = i[0]), e2[1] > i[1] && (e2[1] = i[1]), e2[2] < i[0] && (e2[2] = i[0]), e2[3] < i[1] && (e2[3] = i[1]);
    }), e2;
  }
  ji2.default = ji2;
  var Vt = ji2;
  function Xm(t2, e2) {
    e2 === void 0 && (e2 = {});
    var i = e2.precision, r2 = e2.coordinates, n2 = e2.mutate;
    if (i = i == null || isNaN(i) ? 6 : i, r2 = r2 == null || isNaN(r2) ? 3 : r2, !t2) throw new Error("<geojson> is required");
    if (typeof i != "number") throw new Error("<precision> must be a number");
    if (typeof r2 != "number") throw new Error("<coordinates> must be a number");
    (n2 === false || n2 === void 0) && (t2 = JSON.parse(JSON.stringify(t2)));
    var s2 = Math.pow(10, i);
    return xe(t2, function(a) {
      Ym(a, s2, r2);
    }), t2;
  }
  function Ym(t2, e2, i) {
    t2.length > i && t2.splice(i, t2.length);
    for (var r2 = 0; r2 < t2.length; r2++) t2[r2] = Math.round(t2[r2] * e2) / e2;
    return t2;
  }
  var _l = Xm;
  function Ke2(t2, e2, i) {
    if (i === void 0 && (i = {}), i.final === true) return Jm(t2, e2);
    var r2 = rt(t2), n2 = rt(e2), s2 = lt(r2[0]), a = lt(n2[0]), o = lt(r2[1]), l2 = lt(n2[1]), u2 = Math.sin(a - s2) * Math.cos(l2), f2 = Math.cos(o) * Math.sin(l2) - Math.sin(o) * Math.cos(l2) * Math.cos(a - s2);
    return Me2(Math.atan2(u2, f2));
  }
  function Jm(t2, e2) {
    var i = Ke2(e2, t2);
    return i = (i + 180) % 360, i;
  }
  function He2(t2, e2, i, r2) {
    r2 === void 0 && (r2 = {});
    var n2 = rt(t2), s2 = lt(n2[0]), a = lt(n2[1]), o = lt(i), l2 = Zo(e2, r2.units), u2 = Math.asin(Math.sin(a) * Math.cos(l2) + Math.cos(a) * Math.sin(l2) * Math.cos(o)), f2 = s2 + Math.atan2(Math.sin(o) * Math.sin(l2) * Math.cos(a), Math.cos(l2) - Math.sin(a) * Math.sin(u2)), d = Me2(f2), P2 = Me2(u2);
    return _t([d, P2], r2.properties);
  }
  function $m(t2, e2, i) {
    i === void 0 && (i = {});
    var r2 = _t([1 / 0, 1 / 0], { dist: 1 / 0 }), n2 = 0;
    return ie2(t2, function(s2) {
      for (var a = ot(s2), o = 0; o < a.length - 1; o++) {
        var l2 = _t(a[o]);
        l2.properties.dist = Ct(e2, l2, i);
        var u2 = _t(a[o + 1]);
        u2.properties.dist = Ct(e2, u2, i);
        var f2 = Ct(l2, u2, i), d = Math.max(l2.properties.dist, u2.properties.dist), P2 = Ke2(l2, u2), E2 = He2(e2, d, P2 + 90, i), T2 = He2(e2, d, P2 - 90, i), G2 = pt(wt([E2.geometry.coordinates, T2.geometry.coordinates]), wt([l2.geometry.coordinates, u2.geometry.coordinates])), _ = null;
        G2.features.length > 0 && (_ = G2.features[0], _.properties.dist = Ct(e2, _, i), _.properties.location = n2 + Ct(l2, _, i)), l2.properties.dist < r2.properties.dist && (r2 = l2, r2.properties.index = o, r2.properties.location = n2), u2.properties.dist < r2.properties.dist && (r2 = u2, r2.properties.index = o + 1, r2.properties.location = n2 + f2), _ && _.properties.dist < r2.properties.dist && (r2 = _, r2.properties.index = o), n2 += f2;
      }
    }), r2;
  }
  var yl = $m;
  function Zm(t2, e2) {
    if (!t2) throw new Error("line is required");
    if (!e2) throw new Error("splitter is required");
    var i = Bi2(t2), r2 = Bi2(e2);
    if (i !== "LineString") throw new Error("line must be LineString");
    if (r2 === "FeatureCollection") throw new Error("splitter cannot be a FeatureCollection");
    if (r2 === "GeometryCollection") throw new Error("splitter cannot be a GeometryCollection");
    var n2 = _l(e2, { precision: 7 });
    switch (r2) {
      case "Point":
        return Hi2(t2, n2);
      case "MultiPoint":
        return Ll(t2, n2);
      case "LineString":
      case "MultiLineString":
      case "Polygon":
      case "MultiPolygon":
        return Ll(t2, pt(t2, n2));
    }
  }
  function Ll(t2, e2) {
    var i = [], r2 = (0, Xi2.default)();
    return ie2(e2, function(n2) {
      if (i.forEach(function(o, l2) {
        o.id = l2;
      }), !i.length) i = Hi2(t2, n2).features, i.forEach(function(o) {
        o.bbox || (o.bbox = ml2(Vt(o)));
      }), r2.load(yt(i));
      else {
        var s2 = r2.search(n2);
        if (s2.features.length) {
          var a = bl2(n2, s2);
          i = i.filter(function(o) {
            return o.id !== a.id;
          }), r2.remove(a), Ft(Hi2(a, n2), function(o) {
            i.push(o), r2.insert(o);
          });
        }
      }
    }), yt(i);
  }
  function Hi2(t2, e2) {
    var i = [], r2 = ot(t2)[0], n2 = ot(t2)[t2.geometry.coordinates.length - 1];
    if (Ki2(r2, rt(e2)) || Ki2(n2, rt(e2))) return yt([t2]);
    var s2 = (0, Xi2.default)(), a = we2(t2);
    s2.load(a);
    var o = s2.search(e2);
    if (!o.features.length) return yt([t2]);
    var l2 = bl2(e2, o), u2 = [r2], f2 = Wo(a, function(d, P2, E2) {
      var T2 = ot(P2)[1], G2 = rt(e2);
      return E2 === l2.id ? (d.push(G2), i.push(wt(d)), Ki2(G2, T2) ? [G2] : [G2, T2]) : (d.push(T2), d);
    }, u2);
    return f2.length > 1 && i.push(wt(f2)), yt(i);
  }
  function bl2(t2, e2) {
    if (!e2.features.length) throw new Error("lines must contain features");
    if (e2.features.length === 1) return e2.features[0];
    var i, r2 = 1 / 0;
    return Ft(e2, function(n2) {
      var s2 = yl(n2, t2), a = s2.properties.dist;
      a < r2 && (i = n2, r2 = a);
    }), i;
  }
  function Ki2(t2, e2) {
    return t2[0] === e2[0] && t2[1] === e2[1];
  }
  var vl = Zm;
  function ne2(t2, e2, i) {
    if (i === void 0 && (i = {}), !t2) throw new Error("point is required");
    if (!e2) throw new Error("polygon is required");
    var r2 = rt(t2), n2 = ee2(e2), s2 = n2.type, a = e2.bbox, o = n2.coordinates;
    if (a && Wm(r2, a) === false) return false;
    s2 === "Polygon" && (o = [o]);
    for (var l2 = false, u2 = 0; u2 < o.length && !l2; u2++) if (kl2(r2, o[u2][0], i.ignoreBoundary)) {
      for (var f2 = false, d = 1; d < o[u2].length && !f2; ) kl2(r2, o[u2][d], !i.ignoreBoundary) && (f2 = true), d++;
      f2 || (l2 = true);
    }
    return l2;
  }
  function kl2(t2, e2, i) {
    var r2 = false;
    e2[0][0] === e2[e2.length - 1][0] && e2[0][1] === e2[e2.length - 1][1] && (e2 = e2.slice(0, e2.length - 1));
    for (var n2 = 0, s2 = e2.length - 1; n2 < e2.length; s2 = n2++) {
      var a = e2[n2][0], o = e2[n2][1], l2 = e2[s2][0], u2 = e2[s2][1], f2 = t2[1] * (a - l2) + o * (l2 - t2[0]) + u2 * (t2[0] - a) === 0 && (a - t2[0]) * (l2 - t2[0]) <= 0 && (o - t2[1]) * (u2 - t2[1]) <= 0;
      if (f2) return !i;
      var d = o > t2[1] != u2 > t2[1] && t2[0] < (l2 - a) * (t2[1] - o) / (u2 - o) + a;
      d && (r2 = !r2);
    }
    return r2;
  }
  function Wm(t2, e2) {
    return e2[0] <= t2[0] && e2[1] <= t2[1] && e2[2] >= t2[0] && e2[3] >= t2[1];
  }
  function Qm(t2, e2, i) {
    i === void 0 && (i = {});
    for (var r2 = rt(t2), n2 = ot(e2), s2 = 0; s2 < n2.length - 1; s2++) {
      var a = false;
      if (i.ignoreEndVertices && (s2 === 0 && (a = "start"), s2 === n2.length - 2 && (a = "end"), s2 === 0 && s2 + 1 === n2.length - 1 && (a = "both")), t_(n2[s2], n2[s2 + 1], r2, a, typeof i.epsilon > "u" ? null : i.epsilon)) return true;
    }
    return false;
  }
  function t_(t2, e2, i, r2, n2) {
    var s2 = i[0], a = i[1], o = t2[0], l2 = t2[1], u2 = e2[0], f2 = e2[1], d = i[0] - o, P2 = i[1] - l2, E2 = u2 - o, T2 = f2 - l2, G2 = d * T2 - P2 * E2;
    if (n2 !== null) {
      if (Math.abs(G2) > n2) return false;
    } else if (G2 !== 0) return false;
    if (r2) {
      if (r2 === "start") return Math.abs(E2) >= Math.abs(T2) ? E2 > 0 ? o < s2 && s2 <= u2 : u2 <= s2 && s2 < o : T2 > 0 ? l2 < a && a <= f2 : f2 <= a && a < l2;
      if (r2 === "end") return Math.abs(E2) >= Math.abs(T2) ? E2 > 0 ? o <= s2 && s2 < u2 : u2 < s2 && s2 <= o : T2 > 0 ? l2 <= a && a < f2 : f2 < a && a <= l2;
      if (r2 === "both") return Math.abs(E2) >= Math.abs(T2) ? E2 > 0 ? o < s2 && s2 < u2 : u2 < s2 && s2 < o : T2 > 0 ? l2 < a && a < f2 : f2 < a && a < l2;
    } else return Math.abs(E2) >= Math.abs(T2) ? E2 > 0 ? o <= s2 && s2 <= u2 : u2 <= s2 && s2 <= o : T2 > 0 ? l2 <= a && a <= f2 : f2 <= a && a <= l2;
    return false;
  }
  var se2 = Qm;
  function Yi2(t2, e2) {
    var i = ee2(t2), r2 = ee2(e2), n2 = i.type, s2 = r2.type, a = i.coordinates, o = r2.coordinates;
    switch (n2) {
      case "Point":
        switch (s2) {
          case "Point":
            return Ji2(a, o);
          default:
            throw new Error("feature2 " + s2 + " geometry not supported");
        }
      case "MultiPoint":
        switch (s2) {
          case "Point":
            return e_(i, r2);
          case "MultiPoint":
            return i_(i, r2);
          default:
            throw new Error("feature2 " + s2 + " geometry not supported");
        }
      case "LineString":
        switch (s2) {
          case "Point":
            return se2(r2, i, { ignoreEndVertices: true });
          case "LineString":
            return s_(i, r2);
          case "MultiPoint":
            return r_(i, r2);
          default:
            throw new Error("feature2 " + s2 + " geometry not supported");
        }
      case "Polygon":
        switch (s2) {
          case "Point":
            return ne2(r2, i, { ignoreBoundary: true });
          case "LineString":
            return a_(i, r2);
          case "Polygon":
            return o_(i, r2);
          case "MultiPoint":
            return n_(i, r2);
          default:
            throw new Error("feature2 " + s2 + " geometry not supported");
        }
      default:
        throw new Error("feature1 " + n2 + " geometry not supported");
    }
  }
  function e_(t2, e2) {
    var i, r2 = false;
    for (i = 0; i < t2.coordinates.length; i++) if (Ji2(t2.coordinates[i], e2.coordinates)) {
      r2 = true;
      break;
    }
    return r2;
  }
  function i_(t2, e2) {
    for (var i = 0, r2 = e2.coordinates; i < r2.length; i++) {
      for (var n2 = r2[i], s2 = false, a = 0, o = t2.coordinates; a < o.length; a++) {
        var l2 = o[a];
        if (Ji2(n2, l2)) {
          s2 = true;
          break;
        }
      }
      if (!s2) return false;
    }
    return true;
  }
  function r_(t2, e2) {
    for (var i = false, r2 = 0, n2 = e2.coordinates; r2 < n2.length; r2++) {
      var s2 = n2[r2];
      if (se2(s2, t2, { ignoreEndVertices: true }) && (i = true), !se2(s2, t2)) return false;
    }
    return !!i;
  }
  function n_(t2, e2) {
    for (var i = 0, r2 = e2.coordinates; i < r2.length; i++) {
      var n2 = r2[i];
      if (!ne2(n2, t2, { ignoreBoundary: true })) return false;
    }
    return true;
  }
  function s_(t2, e2) {
    for (var i = false, r2 = 0, n2 = e2.coordinates; r2 < n2.length; r2++) {
      var s2 = n2[r2];
      if (se2({ type: "Point", coordinates: s2 }, t2, { ignoreEndVertices: true }) && (i = true), !se2({ type: "Point", coordinates: s2 }, t2, { ignoreEndVertices: false })) return false;
    }
    return i;
  }
  function a_(t2, e2) {
    var i = false, r2 = 0, n2 = Vt(t2), s2 = Vt(e2);
    if (!Ml(n2, s2)) return false;
    for (r2; r2 < e2.coordinates.length - 1; r2++) {
      var a = l_(e2.coordinates[r2], e2.coordinates[r2 + 1]);
      if (ne2({ type: "Point", coordinates: a }, t2, { ignoreBoundary: true })) {
        i = true;
        break;
      }
    }
    return i;
  }
  function o_(t2, e2) {
    if (t2.type === "Feature" && t2.geometry === null || e2.type === "Feature" && e2.geometry === null) return false;
    var i = Vt(t2), r2 = Vt(e2);
    if (!Ml(i, r2)) return false;
    for (var n2 = ee2(e2).coordinates, s2 = 0, a = n2; s2 < a.length; s2++) for (var o = a[s2], l2 = 0, u2 = o; l2 < u2.length; l2++) {
      var f2 = u2[l2];
      if (!ne2(f2, t2)) return false;
    }
    return true;
  }
  function Ml(t2, e2) {
    return !(t2[0] > e2[0] || t2[2] < e2[2] || t2[1] > e2[1] || t2[3] < e2[3]);
  }
  function Ji2(t2, e2) {
    return t2[0] === e2[0] && t2[1] === e2[1];
  }
  function l_(t2, e2) {
    return [(t2[0] + e2[0]) / 2, (t2[1] + e2[1]) / 2];
  }
  var Kl = xt(Le2());
  var Xe2 = (t2) => () => t2;
  var Ee2 = (t2) => {
    let e2 = t2 ? (i, r2) => r2.minus(i).abs().isLessThanOrEqualTo(t2) : Xe2(false);
    return (i, r2) => e2(i, r2) ? 0 : i.comparedTo(r2);
  };
  function xl(t2) {
    let e2 = t2 ? (i, r2, n2, s2, a) => i.exponentiatedBy(2).isLessThanOrEqualTo(s2.minus(r2).exponentiatedBy(2).plus(a.minus(n2).exponentiatedBy(2)).times(t2)) : Xe2(false);
    return (i, r2, n2) => {
      let s2 = i.x, a = i.y, o = n2.x, l2 = n2.y, u2 = a.minus(l2).times(r2.x.minus(o)).minus(s2.minus(o).times(r2.y.minus(l2)));
      return e2(u2, s2, a, o, l2) ? 0 : u2.comparedTo(0);
    };
  }
  var h_ = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, $i2 = Math.ceil, dt = Math.floor, ht = "[BigNumber Error] ", wl = ht + "Number primitive has more than 15 significant digits: ", Lt = 1e14, F2 = 14, Zi2 = 9007199254740991, Wi2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], At = 1e7, tt = 1e9;
  function Cl(t2) {
    var e2, i, r2, n2 = b.prototype = { constructor: b, toString: null, valueOf: null }, s2 = new b(1), a = 20, o = 4, l2 = -7, u2 = 21, f2 = -1e7, d = 1e7, P2 = false, E2 = 1, T2 = 0, G2 = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: " ", suffix: "" }, _ = "0123456789abcdefghijklmnopqrstuvwxyz", x2 = true;
    function b(h2, c) {
      var p2, y2, g2, k2, C2, m2, v2, w2, M2 = this;
      if (!(M2 instanceof b)) return new b(h2, c);
      if (c == null) {
        if (h2 && h2._isBigNumber === true) {
          M2.s = h2.s, !h2.c || h2.e > d ? M2.c = M2.e = null : h2.e < f2 ? M2.c = [M2.e = 0] : (M2.e = h2.e, M2.c = h2.c.slice());
          return;
        }
        if ((m2 = typeof h2 == "number") && h2 * 0 == 0) {
          if (M2.s = 1 / h2 < 0 ? (h2 = -h2, -1) : 1, h2 === ~~h2) {
            for (k2 = 0, C2 = h2; C2 >= 10; C2 /= 10, k2++) ;
            k2 > d ? M2.c = M2.e = null : (M2.e = k2, M2.c = [h2]);
            return;
          }
          w2 = String(h2);
        } else {
          if (!h_.test(w2 = String(h2))) return r2(M2, w2, m2);
          M2.s = w2.charCodeAt(0) == 45 ? (w2 = w2.slice(1), -1) : 1;
        }
        (k2 = w2.indexOf(".")) > -1 && (w2 = w2.replace(".", "")), (C2 = w2.search(/e/i)) > 0 ? (k2 < 0 && (k2 = C2), k2 += +w2.slice(C2 + 1), w2 = w2.substring(0, C2)) : k2 < 0 && (k2 = w2.length);
      } else {
        if (J2(c, 2, _.length, "Base"), c == 10 && x2) return M2 = new b(h2), A2(M2, a + M2.e + 1, o);
        if (w2 = String(h2), m2 = typeof h2 == "number") {
          if (h2 * 0 != 0) return r2(M2, w2, m2, c);
          if (M2.s = 1 / h2 < 0 ? (w2 = w2.slice(1), -1) : 1, b.DEBUG && w2.replace(/^0\.0*|\./, "").length > 15) throw Error(wl + h2);
        } else M2.s = w2.charCodeAt(0) === 45 ? (w2 = w2.slice(1), -1) : 1;
        for (p2 = _.slice(0, c), k2 = C2 = 0, v2 = w2.length; C2 < v2; C2++) if (p2.indexOf(y2 = w2.charAt(C2)) < 0) {
          if (y2 == ".") {
            if (C2 > k2) {
              k2 = v2;
              continue;
            }
          } else if (!g2 && (w2 == w2.toUpperCase() && (w2 = w2.toLowerCase()) || w2 == w2.toLowerCase() && (w2 = w2.toUpperCase()))) {
            g2 = true, C2 = -1, k2 = 0;
            continue;
          }
          return r2(M2, String(h2), m2, c);
        }
        m2 = false, w2 = i(w2, c, 10, M2.s), (k2 = w2.indexOf(".")) > -1 ? w2 = w2.replace(".", "") : k2 = w2.length;
      }
      for (C2 = 0; w2.charCodeAt(C2) === 48; C2++) ;
      for (v2 = w2.length; w2.charCodeAt(--v2) === 48; ) ;
      if (w2 = w2.slice(C2, ++v2)) {
        if (v2 -= C2, m2 && b.DEBUG && v2 > 15 && (h2 > Zi2 || h2 !== dt(h2))) throw Error(wl + M2.s * h2);
        if ((k2 = k2 - C2 - 1) > d) M2.c = M2.e = null;
        else if (k2 < f2) M2.c = [M2.e = 0];
        else {
          if (M2.e = k2, M2.c = [], C2 = (k2 + 1) % F2, k2 < 0 && (C2 += F2), C2 < v2) {
            for (C2 && M2.c.push(+w2.slice(0, C2)), v2 -= F2; C2 < v2; ) M2.c.push(+w2.slice(C2, C2 += F2));
            C2 = F2 - (w2 = w2.slice(C2)).length;
          } else C2 -= v2;
          for (; C2--; w2 += "0") ;
          M2.c.push(+w2);
        }
      } else M2.c = [M2.e = 0];
    }
    b.clone = Cl, b.ROUND_UP = 0, b.ROUND_DOWN = 1, b.ROUND_CEIL = 2, b.ROUND_FLOOR = 3, b.ROUND_HALF_UP = 4, b.ROUND_HALF_DOWN = 5, b.ROUND_HALF_EVEN = 6, b.ROUND_HALF_CEIL = 7, b.ROUND_HALF_FLOOR = 8, b.EUCLID = 9, b.config = b.set = function(h2) {
      var c, p2;
      if (h2 != null) if (typeof h2 == "object") {
        if (h2.hasOwnProperty(c = "DECIMAL_PLACES") && (p2 = h2[c], J2(p2, 0, tt, c), a = p2), h2.hasOwnProperty(c = "ROUNDING_MODE") && (p2 = h2[c], J2(p2, 0, 8, c), o = p2), h2.hasOwnProperty(c = "EXPONENTIAL_AT") && (p2 = h2[c], p2 && p2.pop ? (J2(p2[0], -tt, 0, c), J2(p2[1], 0, tt, c), l2 = p2[0], u2 = p2[1]) : (J2(p2, -tt, tt, c), l2 = -(u2 = p2 < 0 ? -p2 : p2))), h2.hasOwnProperty(c = "RANGE")) if (p2 = h2[c], p2 && p2.pop) J2(p2[0], -tt, -1, c), J2(p2[1], 1, tt, c), f2 = p2[0], d = p2[1];
        else if (J2(p2, -tt, tt, c), p2) f2 = -(d = p2 < 0 ? -p2 : p2);
        else throw Error(ht + c + " cannot be zero: " + p2);
        if (h2.hasOwnProperty(c = "CRYPTO")) if (p2 = h2[c], p2 === !!p2) if (p2) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) P2 = p2;
        else throw P2 = !p2, Error(ht + "crypto unavailable");
        else P2 = p2;
        else throw Error(ht + c + " not true or false: " + p2);
        if (h2.hasOwnProperty(c = "MODULO_MODE") && (p2 = h2[c], J2(p2, 0, 9, c), E2 = p2), h2.hasOwnProperty(c = "POW_PRECISION") && (p2 = h2[c], J2(p2, 0, tt, c), T2 = p2), h2.hasOwnProperty(c = "FORMAT")) if (p2 = h2[c], typeof p2 == "object") G2 = p2;
        else throw Error(ht + c + " not an object: " + p2);
        if (h2.hasOwnProperty(c = "ALPHABET")) if (p2 = h2[c], typeof p2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(p2)) x2 = p2.slice(0, 10) == "0123456789", _ = p2;
        else throw Error(ht + c + " invalid: " + p2);
      } else throw Error(ht + "Object expected: " + h2);
      return { DECIMAL_PLACES: a, ROUNDING_MODE: o, EXPONENTIAL_AT: [l2, u2], RANGE: [f2, d], CRYPTO: P2, MODULO_MODE: E2, POW_PRECISION: T2, FORMAT: G2, ALPHABET: _ };
    }, b.isBigNumber = function(h2) {
      if (!h2 || h2._isBigNumber !== true) return false;
      if (!b.DEBUG) return true;
      var c, p2, y2 = h2.c, g2 = h2.e, k2 = h2.s;
      t: if ({}.toString.call(y2) == "[object Array]") {
        if ((k2 === 1 || k2 === -1) && g2 >= -tt && g2 <= tt && g2 === dt(g2)) {
          if (y2[0] === 0) {
            if (g2 === 0 && y2.length === 1) return true;
            break t;
          }
          if (c = (g2 + 1) % F2, c < 1 && (c += F2), String(y2[0]).length == c) {
            for (c = 0; c < y2.length; c++) if (p2 = y2[c], p2 < 0 || p2 >= Lt || p2 !== dt(p2)) break t;
            if (p2 !== 0) return true;
          }
        }
      } else if (y2 === null && g2 === null && (k2 === null || k2 === 1 || k2 === -1)) return true;
      throw Error(ht + "Invalid BigNumber: " + h2);
    }, b.maximum = b.max = function() {
      return D2(arguments, -1);
    }, b.minimum = b.min = function() {
      return D2(arguments, 1);
    }, b.random = function() {
      var h2 = 9007199254740992, c = Math.random() * h2 & 2097151 ? function() {
        return dt(Math.random() * h2);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(p2) {
        var y2, g2, k2, C2, m2, v2 = 0, w2 = [], M2 = new b(s2);
        if (p2 == null ? p2 = a : J2(p2, 0, tt), C2 = $i2(p2 / F2), P2) if (crypto.getRandomValues) {
          for (y2 = crypto.getRandomValues(new Uint32Array(C2 *= 2)); v2 < C2; ) m2 = y2[v2] * 131072 + (y2[v2 + 1] >>> 11), m2 >= 9e15 ? (g2 = crypto.getRandomValues(new Uint32Array(2)), y2[v2] = g2[0], y2[v2 + 1] = g2[1]) : (w2.push(m2 % 1e14), v2 += 2);
          v2 = C2 / 2;
        } else if (crypto.randomBytes) {
          for (y2 = crypto.randomBytes(C2 *= 7); v2 < C2; ) m2 = (y2[v2] & 31) * 281474976710656 + y2[v2 + 1] * 1099511627776 + y2[v2 + 2] * 4294967296 + y2[v2 + 3] * 16777216 + (y2[v2 + 4] << 16) + (y2[v2 + 5] << 8) + y2[v2 + 6], m2 >= 9e15 ? crypto.randomBytes(7).copy(y2, v2) : (w2.push(m2 % 1e14), v2 += 7);
          v2 = C2 / 7;
        } else throw P2 = false, Error(ht + "crypto unavailable");
        if (!P2) for (; v2 < C2; ) m2 = c(), m2 < 9e15 && (w2[v2++] = m2 % 1e14);
        for (C2 = w2[--v2], p2 %= F2, C2 && p2 && (m2 = Wi2[F2 - p2], w2[v2] = dt(C2 / m2) * m2); w2[v2] === 0; w2.pop(), v2--) ;
        if (v2 < 0) w2 = [k2 = 0];
        else {
          for (k2 = -1; w2[0] === 0; w2.splice(0, 1), k2 -= F2) ;
          for (v2 = 1, m2 = w2[0]; m2 >= 10; m2 /= 10, v2++) ;
          v2 < F2 && (k2 -= F2 - v2);
        }
        return M2.e = k2, M2.c = w2, M2;
      };
    }(), b.sum = function() {
      for (var h2 = 1, c = arguments, p2 = new b(c[0]); h2 < c.length; ) p2 = p2.plus(c[h2++]);
      return p2;
    }, i = /* @__PURE__ */ function() {
      var h2 = "0123456789";
      function c(p2, y2, g2, k2) {
        for (var C2, m2 = [0], v2, w2 = 0, M2 = p2.length; w2 < M2; ) {
          for (v2 = m2.length; v2--; m2[v2] *= y2) ;
          for (m2[0] += k2.indexOf(p2.charAt(w2++)), C2 = 0; C2 < m2.length; C2++) m2[C2] > g2 - 1 && (m2[C2 + 1] == null && (m2[C2 + 1] = 0), m2[C2 + 1] += m2[C2] / g2 | 0, m2[C2] %= g2);
        }
        return m2.reverse();
      }
      return function(p2, y2, g2, k2, C2) {
        var m2, v2, w2, M2, B2, I2, N2, j, $ = p2.indexOf("."), W2 = a, U2 = o;
        for ($ >= 0 && (M2 = T2, T2 = 0, p2 = p2.replace(".", ""), j = new b(y2), I2 = j.pow(p2.length - $), T2 = M2, j.c = c(Et(ft(I2.c), I2.e, "0"), 10, g2, h2), j.e = j.c.length), N2 = c(p2, y2, g2, C2 ? (m2 = _, h2) : (m2 = h2, _)), w2 = M2 = N2.length; N2[--M2] == 0; N2.pop()) ;
        if (!N2[0]) return m2.charAt(0);
        if ($ < 0 ? --w2 : (I2.c = N2, I2.e = w2, I2.s = k2, I2 = e2(I2, j, W2, U2, g2), N2 = I2.c, B2 = I2.r, w2 = I2.e), v2 = w2 + W2 + 1, $ = N2[v2], M2 = g2 / 2, B2 = B2 || v2 < 0 || N2[v2 + 1] != null, B2 = U2 < 4 ? ($ != null || B2) && (U2 == 0 || U2 == (I2.s < 0 ? 3 : 2)) : $ > M2 || $ == M2 && (U2 == 4 || B2 || U2 == 6 && N2[v2 - 1] & 1 || U2 == (I2.s < 0 ? 8 : 7)), v2 < 1 || !N2[0]) p2 = B2 ? Et(m2.charAt(1), -W2, m2.charAt(0)) : m2.charAt(0);
        else {
          if (N2.length = v2, B2) for (--g2; ++N2[--v2] > g2; ) N2[v2] = 0, v2 || (++w2, N2 = [1].concat(N2));
          for (M2 = N2.length; !N2[--M2]; ) ;
          for ($ = 0, p2 = ""; $ <= M2; p2 += m2.charAt(N2[$++])) ;
          p2 = Et(p2, w2, m2.charAt(0));
        }
        return p2;
      };
    }(), e2 = /* @__PURE__ */ function() {
      function h2(y2, g2, k2) {
        var C2, m2, v2, w2, M2 = 0, B2 = y2.length, I2 = g2 % At, N2 = g2 / At | 0;
        for (y2 = y2.slice(); B2--; ) v2 = y2[B2] % At, w2 = y2[B2] / At | 0, C2 = N2 * v2 + w2 * I2, m2 = I2 * v2 + C2 % At * At + M2, M2 = (m2 / k2 | 0) + (C2 / At | 0) + N2 * w2, y2[B2] = m2 % k2;
        return M2 && (y2 = [M2].concat(y2)), y2;
      }
      function c(y2, g2, k2, C2) {
        var m2, v2;
        if (k2 != C2) v2 = k2 > C2 ? 1 : -1;
        else for (m2 = v2 = 0; m2 < k2; m2++) if (y2[m2] != g2[m2]) {
          v2 = y2[m2] > g2[m2] ? 1 : -1;
          break;
        }
        return v2;
      }
      function p2(y2, g2, k2, C2) {
        for (var m2 = 0; k2--; ) y2[k2] -= m2, m2 = y2[k2] < g2[k2] ? 1 : 0, y2[k2] = m2 * C2 + y2[k2] - g2[k2];
        for (; !y2[0] && y2.length > 1; y2.splice(0, 1)) ;
      }
      return function(y2, g2, k2, C2, m2) {
        var v2, w2, M2, B2, I2, N2, j, $, W2, U2, K2, it, De2, si2, ai2, bt, le2, ct = y2.s == g2.s ? 1 : -1, st = y2.c, Z2 = g2.c;
        if (!st || !st[0] || !Z2 || !Z2[0]) return new b(!y2.s || !g2.s || (st ? Z2 && st[0] == Z2[0] : !Z2) ? NaN : st && st[0] == 0 || !Z2 ? ct * 0 : ct / 0);
        for ($ = new b(ct), W2 = $.c = [], w2 = y2.e - g2.e, ct = k2 + w2 + 1, m2 || (m2 = Lt, w2 = gt(y2.e / F2) - gt(g2.e / F2), ct = ct / F2 | 0), M2 = 0; Z2[M2] == (st[M2] || 0); M2++) ;
        if (Z2[M2] > (st[M2] || 0) && w2--, ct < 0) W2.push(1), B2 = true;
        else {
          for (si2 = st.length, bt = Z2.length, M2 = 0, ct += 2, I2 = dt(m2 / (Z2[0] + 1)), I2 > 1 && (Z2 = h2(Z2, I2, m2), st = h2(st, I2, m2), bt = Z2.length, si2 = st.length), De2 = bt, U2 = st.slice(0, bt), K2 = U2.length; K2 < bt; U2[K2++] = 0) ;
          le2 = Z2.slice(), le2 = [0].concat(le2), ai2 = Z2[0], Z2[1] >= m2 / 2 && ai2++;
          do {
            if (I2 = 0, v2 = c(Z2, U2, bt, K2), v2 < 0) {
              if (it = U2[0], bt != K2 && (it = it * m2 + (U2[1] || 0)), I2 = dt(it / ai2), I2 > 1) for (I2 >= m2 && (I2 = m2 - 1), N2 = h2(Z2, I2, m2), j = N2.length, K2 = U2.length; c(N2, U2, j, K2) == 1; ) I2--, p2(N2, bt < j ? le2 : Z2, j, m2), j = N2.length, v2 = 1;
              else I2 == 0 && (v2 = I2 = 1), N2 = Z2.slice(), j = N2.length;
              if (j < K2 && (N2 = [0].concat(N2)), p2(U2, N2, K2, m2), K2 = U2.length, v2 == -1) for (; c(Z2, U2, bt, K2) < 1; ) I2++, p2(U2, bt < K2 ? le2 : Z2, K2, m2), K2 = U2.length;
            } else v2 === 0 && (I2++, U2 = [0]);
            W2[M2++] = I2, U2[0] ? U2[K2++] = st[De2] || 0 : (U2 = [st[De2]], K2 = 1);
          } while ((De2++ < si2 || U2[0] != null) && ct--);
          B2 = U2[0] != null, W2[0] || W2.splice(0, 1);
        }
        if (m2 == Lt) {
          for (M2 = 1, ct = W2[0]; ct >= 10; ct /= 10, M2++) ;
          A2($, k2 + ($.e = M2 + w2 * F2 - 1) + 1, C2, B2);
        } else $.e = w2, $.r = +B2;
        return $;
      };
    }();
    function R2(h2, c, p2, y2) {
      var g2, k2, C2, m2, v2;
      if (p2 == null ? p2 = o : J2(p2, 0, 8), !h2.c) return h2.toString();
      if (g2 = h2.c[0], C2 = h2.e, c == null) v2 = ft(h2.c), v2 = y2 == 1 || y2 == 2 && (C2 <= l2 || C2 >= u2) ? Je2(v2, C2) : Et(v2, C2, "0");
      else if (h2 = A2(new b(h2), c, p2), k2 = h2.e, v2 = ft(h2.c), m2 = v2.length, y2 == 1 || y2 == 2 && (c <= k2 || k2 <= l2)) {
        for (; m2 < c; v2 += "0", m2++) ;
        v2 = Je2(v2, k2);
      } else if (c -= C2, v2 = Et(v2, k2, "0"), k2 + 1 > m2) {
        if (--c > 0) for (v2 += "."; c--; v2 += "0") ;
      } else if (c += k2 - m2, c > 0) for (k2 + 1 == m2 && (v2 += "."); c--; v2 += "0") ;
      return h2.s < 0 && g2 ? "-" + v2 : v2;
    }
    function D2(h2, c) {
      for (var p2, y2, g2 = 1, k2 = new b(h2[0]); g2 < h2.length; g2++) y2 = new b(h2[g2]), (!y2.s || (p2 = Ut(k2, y2)) === c || p2 === 0 && k2.s === c) && (k2 = y2);
      return k2;
    }
    function O2(h2, c, p2) {
      for (var y2 = 1, g2 = c.length; !c[--g2]; c.pop()) ;
      for (g2 = c[0]; g2 >= 10; g2 /= 10, y2++) ;
      return (p2 = y2 + p2 * F2 - 1) > d ? h2.c = h2.e = null : p2 < f2 ? h2.c = [h2.e = 0] : (h2.e = p2, h2.c = c), h2;
    }
    r2 = /* @__PURE__ */ function() {
      var h2 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, c = /^([^.]+)\.$/, p2 = /^\.([^.]+)$/, y2 = /^-?(Infinity|NaN)$/, g2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(k2, C2, m2, v2) {
        var w2, M2 = m2 ? C2 : C2.replace(g2, "");
        if (y2.test(M2)) k2.s = isNaN(M2) ? null : M2 < 0 ? -1 : 1;
        else {
          if (!m2 && (M2 = M2.replace(h2, function(B2, I2, N2) {
            return w2 = (N2 = N2.toLowerCase()) == "x" ? 16 : N2 == "b" ? 2 : 8, !v2 || v2 == w2 ? I2 : B2;
          }), v2 && (w2 = v2, M2 = M2.replace(c, "$1").replace(p2, "0.$1")), C2 != M2)) return new b(M2, w2);
          if (b.DEBUG) throw Error(ht + "Not a" + (v2 ? " base " + v2 : "") + " number: " + C2);
          k2.s = null;
        }
        k2.c = k2.e = null;
      };
    }();
    function A2(h2, c, p2, y2) {
      var g2, k2, C2, m2, v2, w2, M2, B2 = h2.c, I2 = Wi2;
      if (B2) {
        t: {
          for (g2 = 1, m2 = B2[0]; m2 >= 10; m2 /= 10, g2++) ;
          if (k2 = c - g2, k2 < 0) k2 += F2, C2 = c, v2 = B2[w2 = 0], M2 = dt(v2 / I2[g2 - C2 - 1] % 10);
          else if (w2 = $i2((k2 + 1) / F2), w2 >= B2.length) if (y2) {
            for (; B2.length <= w2; B2.push(0)) ;
            v2 = M2 = 0, g2 = 1, k2 %= F2, C2 = k2 - F2 + 1;
          } else break t;
          else {
            for (v2 = m2 = B2[w2], g2 = 1; m2 >= 10; m2 /= 10, g2++) ;
            k2 %= F2, C2 = k2 - F2 + g2, M2 = C2 < 0 ? 0 : dt(v2 / I2[g2 - C2 - 1] % 10);
          }
          if (y2 = y2 || c < 0 || B2[w2 + 1] != null || (C2 < 0 ? v2 : v2 % I2[g2 - C2 - 1]), y2 = p2 < 4 ? (M2 || y2) && (p2 == 0 || p2 == (h2.s < 0 ? 3 : 2)) : M2 > 5 || M2 == 5 && (p2 == 4 || y2 || p2 == 6 && (k2 > 0 ? C2 > 0 ? v2 / I2[g2 - C2] : 0 : B2[w2 - 1]) % 10 & 1 || p2 == (h2.s < 0 ? 8 : 7)), c < 1 || !B2[0]) return B2.length = 0, y2 ? (c -= h2.e + 1, B2[0] = I2[(F2 - c % F2) % F2], h2.e = -c || 0) : B2[0] = h2.e = 0, h2;
          if (k2 == 0 ? (B2.length = w2, m2 = 1, w2--) : (B2.length = w2 + 1, m2 = I2[F2 - k2], B2[w2] = C2 > 0 ? dt(v2 / I2[g2 - C2] % I2[C2]) * m2 : 0), y2) for (; ; ) if (w2 == 0) {
            for (k2 = 1, C2 = B2[0]; C2 >= 10; C2 /= 10, k2++) ;
            for (C2 = B2[0] += m2, m2 = 1; C2 >= 10; C2 /= 10, m2++) ;
            k2 != m2 && (h2.e++, B2[0] == Lt && (B2[0] = 1));
            break;
          } else {
            if (B2[w2] += m2, B2[w2] != Lt) break;
            B2[w2--] = 0, m2 = 1;
          }
          for (k2 = B2.length; B2[--k2] === 0; B2.pop()) ;
        }
        h2.e > d ? h2.c = h2.e = null : h2.e < f2 && (h2.c = [h2.e = 0]);
      }
      return h2;
    }
    function q2(h2) {
      var c, p2 = h2.e;
      return p2 === null ? h2.toString() : (c = ft(h2.c), c = p2 <= l2 || p2 >= u2 ? Je2(c, p2) : Et(c, p2, "0"), h2.s < 0 ? "-" + c : c);
    }
    return n2.absoluteValue = n2.abs = function() {
      var h2 = new b(this);
      return h2.s < 0 && (h2.s = 1), h2;
    }, n2.comparedTo = function(h2, c) {
      return Ut(this, new b(h2, c));
    }, n2.decimalPlaces = n2.dp = function(h2, c) {
      var p2, y2, g2, k2 = this;
      if (h2 != null) return J2(h2, 0, tt), c == null ? c = o : J2(c, 0, 8), A2(new b(k2), h2 + k2.e + 1, c);
      if (!(p2 = k2.c)) return null;
      if (y2 = ((g2 = p2.length - 1) - gt(this.e / F2)) * F2, g2 = p2[g2]) for (; g2 % 10 == 0; g2 /= 10, y2--) ;
      return y2 < 0 && (y2 = 0), y2;
    }, n2.dividedBy = n2.div = function(h2, c) {
      return e2(this, new b(h2, c), a, o);
    }, n2.dividedToIntegerBy = n2.idiv = function(h2, c) {
      return e2(this, new b(h2, c), 0, 1);
    }, n2.exponentiatedBy = n2.pow = function(h2, c) {
      var p2, y2, g2, k2, C2, m2, v2, w2, M2, B2 = this;
      if (h2 = new b(h2), h2.c && !h2.isInteger()) throw Error(ht + "Exponent not an integer: " + q2(h2));
      if (c != null && (c = new b(c)), m2 = h2.e > 14, !B2.c || !B2.c[0] || B2.c[0] == 1 && !B2.e && B2.c.length == 1 || !h2.c || !h2.c[0]) return M2 = new b(Math.pow(+q2(B2), m2 ? h2.s * (2 - Ye2(h2)) : +q2(h2))), c ? M2.mod(c) : M2;
      if (v2 = h2.s < 0, c) {
        if (c.c ? !c.c[0] : !c.s) return new b(NaN);
        y2 = !v2 && B2.isInteger() && c.isInteger(), y2 && (B2 = B2.mod(c));
      } else {
        if (h2.e > 9 && (B2.e > 0 || B2.e < -1 || (B2.e == 0 ? B2.c[0] > 1 || m2 && B2.c[1] >= 24e7 : B2.c[0] < 8e13 || m2 && B2.c[0] <= 9999975e7))) return k2 = B2.s < 0 && Ye2(h2) ? -0 : 0, B2.e > -1 && (k2 = 1 / k2), new b(v2 ? 1 / k2 : k2);
        T2 && (k2 = $i2(T2 / F2 + 2));
      }
      for (m2 ? (p2 = new b(0.5), v2 && (h2.s = 1), w2 = Ye2(h2)) : (g2 = Math.abs(+q2(h2)), w2 = g2 % 2), M2 = new b(s2); ; ) {
        if (w2) {
          if (M2 = M2.times(B2), !M2.c) break;
          k2 ? M2.c.length > k2 && (M2.c.length = k2) : y2 && (M2 = M2.mod(c));
        }
        if (g2) {
          if (g2 = dt(g2 / 2), g2 === 0) break;
          w2 = g2 % 2;
        } else if (h2 = h2.times(p2), A2(h2, h2.e + 1, 1), h2.e > 14) w2 = Ye2(h2);
        else {
          if (g2 = +q2(h2), g2 === 0) break;
          w2 = g2 % 2;
        }
        B2 = B2.times(B2), k2 ? B2.c && B2.c.length > k2 && (B2.c.length = k2) : y2 && (B2 = B2.mod(c));
      }
      return y2 ? M2 : (v2 && (M2 = s2.div(M2)), c ? M2.mod(c) : k2 ? A2(M2, T2, o, C2) : M2);
    }, n2.integerValue = function(h2) {
      var c = new b(this);
      return h2 == null ? h2 = o : J2(h2, 0, 8), A2(c, c.e + 1, h2);
    }, n2.isEqualTo = n2.eq = function(h2, c) {
      return Ut(this, new b(h2, c)) === 0;
    }, n2.isFinite = function() {
      return !!this.c;
    }, n2.isGreaterThan = n2.gt = function(h2, c) {
      return Ut(this, new b(h2, c)) > 0;
    }, n2.isGreaterThanOrEqualTo = n2.gte = function(h2, c) {
      return (c = Ut(this, new b(h2, c))) === 1 || c === 0;
    }, n2.isInteger = function() {
      return !!this.c && gt(this.e / F2) > this.c.length - 2;
    }, n2.isLessThan = n2.lt = function(h2, c) {
      return Ut(this, new b(h2, c)) < 0;
    }, n2.isLessThanOrEqualTo = n2.lte = function(h2, c) {
      return (c = Ut(this, new b(h2, c))) === -1 || c === 0;
    }, n2.isNaN = function() {
      return !this.s;
    }, n2.isNegative = function() {
      return this.s < 0;
    }, n2.isPositive = function() {
      return this.s > 0;
    }, n2.isZero = function() {
      return !!this.c && this.c[0] == 0;
    }, n2.minus = function(h2, c) {
      var p2, y2, g2, k2, C2 = this, m2 = C2.s;
      if (h2 = new b(h2, c), c = h2.s, !m2 || !c) return new b(NaN);
      if (m2 != c) return h2.s = -c, C2.plus(h2);
      var v2 = C2.e / F2, w2 = h2.e / F2, M2 = C2.c, B2 = h2.c;
      if (!v2 || !w2) {
        if (!M2 || !B2) return M2 ? (h2.s = -c, h2) : new b(B2 ? C2 : NaN);
        if (!M2[0] || !B2[0]) return B2[0] ? (h2.s = -c, h2) : new b(M2[0] ? C2 : o == 3 ? -0 : 0);
      }
      if (v2 = gt(v2), w2 = gt(w2), M2 = M2.slice(), m2 = v2 - w2) {
        for ((k2 = m2 < 0) ? (m2 = -m2, g2 = M2) : (w2 = v2, g2 = B2), g2.reverse(), c = m2; c--; g2.push(0)) ;
        g2.reverse();
      } else for (y2 = (k2 = (m2 = M2.length) < (c = B2.length)) ? m2 : c, m2 = c = 0; c < y2; c++) if (M2[c] != B2[c]) {
        k2 = M2[c] < B2[c];
        break;
      }
      if (k2 && (g2 = M2, M2 = B2, B2 = g2, h2.s = -h2.s), c = (y2 = B2.length) - (p2 = M2.length), c > 0) for (; c--; M2[p2++] = 0) ;
      for (c = Lt - 1; y2 > m2; ) {
        if (M2[--y2] < B2[y2]) {
          for (p2 = y2; p2 && !M2[--p2]; M2[p2] = c) ;
          --M2[p2], M2[y2] += Lt;
        }
        M2[y2] -= B2[y2];
      }
      for (; M2[0] == 0; M2.splice(0, 1), --w2) ;
      return M2[0] ? O2(h2, M2, w2) : (h2.s = o == 3 ? -1 : 1, h2.c = [h2.e = 0], h2);
    }, n2.modulo = n2.mod = function(h2, c) {
      var p2, y2, g2 = this;
      return h2 = new b(h2, c), !g2.c || !h2.s || h2.c && !h2.c[0] ? new b(NaN) : !h2.c || g2.c && !g2.c[0] ? new b(g2) : (E2 == 9 ? (y2 = h2.s, h2.s = 1, p2 = e2(g2, h2, 0, 3), h2.s = y2, p2.s *= y2) : p2 = e2(g2, h2, 0, E2), h2 = g2.minus(p2.times(h2)), !h2.c[0] && E2 == 1 && (h2.s = g2.s), h2);
    }, n2.multipliedBy = n2.times = function(h2, c) {
      var p2, y2, g2, k2, C2, m2, v2, w2, M2, B2, I2, N2, j, $, W2, U2 = this, K2 = U2.c, it = (h2 = new b(h2, c)).c;
      if (!K2 || !it || !K2[0] || !it[0]) return !U2.s || !h2.s || K2 && !K2[0] && !it || it && !it[0] && !K2 ? h2.c = h2.e = h2.s = null : (h2.s *= U2.s, !K2 || !it ? h2.c = h2.e = null : (h2.c = [0], h2.e = 0)), h2;
      for (y2 = gt(U2.e / F2) + gt(h2.e / F2), h2.s *= U2.s, v2 = K2.length, B2 = it.length, v2 < B2 && (j = K2, K2 = it, it = j, g2 = v2, v2 = B2, B2 = g2), g2 = v2 + B2, j = []; g2--; j.push(0)) ;
      for ($ = Lt, W2 = At, g2 = B2; --g2 >= 0; ) {
        for (p2 = 0, I2 = it[g2] % W2, N2 = it[g2] / W2 | 0, C2 = v2, k2 = g2 + C2; k2 > g2; ) w2 = K2[--C2] % W2, M2 = K2[C2] / W2 | 0, m2 = N2 * w2 + M2 * I2, w2 = I2 * w2 + m2 % W2 * W2 + j[k2] + p2, p2 = (w2 / $ | 0) + (m2 / W2 | 0) + N2 * M2, j[k2--] = w2 % $;
        j[k2] = p2;
      }
      return p2 ? ++y2 : j.splice(0, 1), O2(h2, j, y2);
    }, n2.negated = function() {
      var h2 = new b(this);
      return h2.s = -h2.s || null, h2;
    }, n2.plus = function(h2, c) {
      var p2, y2 = this, g2 = y2.s;
      if (h2 = new b(h2, c), c = h2.s, !g2 || !c) return new b(NaN);
      if (g2 != c) return h2.s = -c, y2.minus(h2);
      var k2 = y2.e / F2, C2 = h2.e / F2, m2 = y2.c, v2 = h2.c;
      if (!k2 || !C2) {
        if (!m2 || !v2) return new b(g2 / 0);
        if (!m2[0] || !v2[0]) return v2[0] ? h2 : new b(m2[0] ? y2 : g2 * 0);
      }
      if (k2 = gt(k2), C2 = gt(C2), m2 = m2.slice(), g2 = k2 - C2) {
        for (g2 > 0 ? (C2 = k2, p2 = v2) : (g2 = -g2, p2 = m2), p2.reverse(); g2--; p2.push(0)) ;
        p2.reverse();
      }
      for (g2 = m2.length, c = v2.length, g2 - c < 0 && (p2 = v2, v2 = m2, m2 = p2, c = g2), g2 = 0; c; ) g2 = (m2[--c] = m2[c] + v2[c] + g2) / Lt | 0, m2[c] = Lt === m2[c] ? 0 : m2[c] % Lt;
      return g2 && (m2 = [g2].concat(m2), ++C2), O2(h2, m2, C2);
    }, n2.precision = n2.sd = function(h2, c) {
      var p2, y2, g2, k2 = this;
      if (h2 != null && h2 !== !!h2) return J2(h2, 1, tt), c == null ? c = o : J2(c, 0, 8), A2(new b(k2), h2, c);
      if (!(p2 = k2.c)) return null;
      if (g2 = p2.length - 1, y2 = g2 * F2 + 1, g2 = p2[g2]) {
        for (; g2 % 10 == 0; g2 /= 10, y2--) ;
        for (g2 = p2[0]; g2 >= 10; g2 /= 10, y2++) ;
      }
      return h2 && k2.e + 1 > y2 && (y2 = k2.e + 1), y2;
    }, n2.shiftedBy = function(h2) {
      return J2(h2, -Zi2, Zi2), this.times("1e" + h2);
    }, n2.squareRoot = n2.sqrt = function() {
      var h2, c, p2, y2, g2, k2 = this, C2 = k2.c, m2 = k2.s, v2 = k2.e, w2 = a + 4, M2 = new b("0.5");
      if (m2 !== 1 || !C2 || !C2[0]) return new b(!m2 || m2 < 0 && (!C2 || C2[0]) ? NaN : C2 ? k2 : 1 / 0);
      if (m2 = Math.sqrt(+q2(k2)), m2 == 0 || m2 == 1 / 0 ? (c = ft(C2), (c.length + v2) % 2 == 0 && (c += "0"), m2 = Math.sqrt(+c), v2 = gt((v2 + 1) / 2) - (v2 < 0 || v2 % 2), m2 == 1 / 0 ? c = "5e" + v2 : (c = m2.toExponential(), c = c.slice(0, c.indexOf("e") + 1) + v2), p2 = new b(c)) : p2 = new b(m2 + ""), p2.c[0]) {
        for (v2 = p2.e, m2 = v2 + w2, m2 < 3 && (m2 = 0); ; ) if (g2 = p2, p2 = M2.times(g2.plus(e2(k2, g2, w2, 1))), ft(g2.c).slice(0, m2) === (c = ft(p2.c)).slice(0, m2)) if (p2.e < v2 && --m2, c = c.slice(m2 - 3, m2 + 1), c == "9999" || !y2 && c == "4999") {
          if (!y2 && (A2(g2, g2.e + a + 2, 0), g2.times(g2).eq(k2))) {
            p2 = g2;
            break;
          }
          w2 += 4, m2 += 4, y2 = 1;
        } else {
          (!+c || !+c.slice(1) && c.charAt(0) == "5") && (A2(p2, p2.e + a + 2, 1), h2 = !p2.times(p2).eq(k2));
          break;
        }
      }
      return A2(p2, p2.e + a + 1, o, h2);
    }, n2.toExponential = function(h2, c) {
      return h2 != null && (J2(h2, 0, tt), h2++), R2(this, h2, c, 1);
    }, n2.toFixed = function(h2, c) {
      return h2 != null && (J2(h2, 0, tt), h2 = h2 + this.e + 1), R2(this, h2, c);
    }, n2.toFormat = function(h2, c, p2) {
      var y2, g2 = this;
      if (p2 == null) h2 != null && c && typeof c == "object" ? (p2 = c, c = null) : h2 && typeof h2 == "object" ? (p2 = h2, h2 = c = null) : p2 = G2;
      else if (typeof p2 != "object") throw Error(ht + "Argument not an object: " + p2);
      if (y2 = g2.toFixed(h2, c), g2.c) {
        var k2, C2 = y2.split("."), m2 = +p2.groupSize, v2 = +p2.secondaryGroupSize, w2 = p2.groupSeparator || "", M2 = C2[0], B2 = C2[1], I2 = g2.s < 0, N2 = I2 ? M2.slice(1) : M2, j = N2.length;
        if (v2 && (k2 = m2, m2 = v2, v2 = k2, j -= k2), m2 > 0 && j > 0) {
          for (k2 = j % m2 || m2, M2 = N2.substr(0, k2); k2 < j; k2 += m2) M2 += w2 + N2.substr(k2, m2);
          v2 > 0 && (M2 += w2 + N2.slice(k2)), I2 && (M2 = "-" + M2);
        }
        y2 = B2 ? M2 + (p2.decimalSeparator || "") + ((v2 = +p2.fractionGroupSize) ? B2.replace(new RegExp("\\d{" + v2 + "}\\B", "g"), "$&" + (p2.fractionGroupSeparator || "")) : B2) : M2;
      }
      return (p2.prefix || "") + y2 + (p2.suffix || "");
    }, n2.toFraction = function(h2) {
      var c, p2, y2, g2, k2, C2, m2, v2, w2, M2, B2, I2, N2 = this, j = N2.c;
      if (h2 != null && (m2 = new b(h2), !m2.isInteger() && (m2.c || m2.s !== 1) || m2.lt(s2))) throw Error(ht + "Argument " + (m2.isInteger() ? "out of range: " : "not an integer: ") + q2(m2));
      if (!j) return new b(N2);
      for (c = new b(s2), w2 = p2 = new b(s2), y2 = v2 = new b(s2), I2 = ft(j), k2 = c.e = I2.length - N2.e - 1, c.c[0] = Wi2[(C2 = k2 % F2) < 0 ? F2 + C2 : C2], h2 = !h2 || m2.comparedTo(c) > 0 ? k2 > 0 ? c : w2 : m2, C2 = d, d = 1 / 0, m2 = new b(I2), v2.c[0] = 0; M2 = e2(m2, c, 0, 1), g2 = p2.plus(M2.times(y2)), g2.comparedTo(h2) != 1; ) p2 = y2, y2 = g2, w2 = v2.plus(M2.times(g2 = w2)), v2 = g2, c = m2.minus(M2.times(g2 = c)), m2 = g2;
      return g2 = e2(h2.minus(p2), y2, 0, 1), v2 = v2.plus(g2.times(w2)), p2 = p2.plus(g2.times(y2)), v2.s = w2.s = N2.s, k2 = k2 * 2, B2 = e2(w2, y2, k2, o).minus(N2).abs().comparedTo(e2(v2, p2, k2, o).minus(N2).abs()) < 1 ? [w2, y2] : [v2, p2], d = C2, B2;
    }, n2.toNumber = function() {
      return +q2(this);
    }, n2.toPrecision = function(h2, c) {
      return h2 != null && J2(h2, 1, tt), R2(this, h2, c, 2);
    }, n2.toString = function(h2) {
      var c, p2 = this, y2 = p2.s, g2 = p2.e;
      return g2 === null ? y2 ? (c = "Infinity", y2 < 0 && (c = "-" + c)) : c = "NaN" : (h2 == null ? c = g2 <= l2 || g2 >= u2 ? Je2(ft(p2.c), g2) : Et(ft(p2.c), g2, "0") : h2 === 10 && x2 ? (p2 = A2(new b(p2), a + g2 + 1, o), c = Et(ft(p2.c), p2.e, "0")) : (J2(h2, 2, _.length, "Base"), c = i(Et(ft(p2.c), g2, "0"), 10, h2, y2, true)), y2 < 0 && p2.c[0] && (c = "-" + c)), c;
    }, n2.valueOf = n2.toJSON = function() {
      return q2(this);
    }, n2._isBigNumber = true, n2[Symbol.toStringTag] = "BigNumber", n2[Symbol.for("nodejs.util.inspect.custom")] = n2.valueOf, t2 != null && b.set(t2), b;
  }
  function gt(t2) {
    var e2 = t2 | 0;
    return t2 > 0 || t2 === e2 ? e2 : e2 - 1;
  }
  function ft(t2) {
    for (var e2, i, r2 = 1, n2 = t2.length, s2 = t2[0] + ""; r2 < n2; ) {
      for (e2 = t2[r2++] + "", i = F2 - e2.length; i--; e2 = "0" + e2) ;
      s2 += e2;
    }
    for (n2 = s2.length; s2.charCodeAt(--n2) === 48; ) ;
    return s2.slice(0, n2 + 1 || 1);
  }
  function Ut(t2, e2) {
    var i, r2, n2 = t2.c, s2 = e2.c, a = t2.s, o = e2.s, l2 = t2.e, u2 = e2.e;
    if (!a || !o) return null;
    if (i = n2 && !n2[0], r2 = s2 && !s2[0], i || r2) return i ? r2 ? 0 : -o : a;
    if (a != o) return a;
    if (i = a < 0, r2 = l2 == u2, !n2 || !s2) return r2 ? 0 : !n2 ^ i ? 1 : -1;
    if (!r2) return l2 > u2 ^ i ? 1 : -1;
    for (o = (l2 = n2.length) < (u2 = s2.length) ? l2 : u2, a = 0; a < o; a++) if (n2[a] != s2[a]) return n2[a] > s2[a] ^ i ? 1 : -1;
    return l2 == u2 ? 0 : l2 > u2 ^ i ? 1 : -1;
  }
  function J2(t2, e2, i, r2) {
    if (t2 < e2 || t2 > i || t2 !== dt(t2)) throw Error(ht + (r2 || "Argument") + (typeof t2 == "number" ? t2 < e2 || t2 > i ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t2));
  }
  function Ye2(t2) {
    var e2 = t2.c.length - 1;
    return gt(t2.e / F2) == e2 && t2.c[e2] % 2 != 0;
  }
  function Je2(t2, e2) {
    return (t2.length > 1 ? t2.charAt(0) + "." + t2.slice(1) : t2) + (e2 < 0 ? "e" : "e+") + e2;
  }
  function Et(t2, e2, i) {
    var r2, n2;
    if (e2 < 0) {
      for (n2 = i + "."; ++e2; n2 += i) ;
      t2 = n2 + t2;
    } else if (r2 = t2.length, ++e2 > r2) {
      for (n2 = i, e2 -= r2; --e2; n2 += i) ;
      t2 += n2;
    } else e2 < r2 && (t2 = t2.slice(0, e2) + "." + t2.slice(e2));
    return t2;
  }
  var u_ = Cl(), mt = u_;
  var Qi2 = class {
    constructor(e2) {
      __publicField(this, "key");
      __publicField(this, "left", null);
      __publicField(this, "right", null);
      this.key = e2;
    }
  }, jt = class extends Qi2 {
    constructor(e2) {
      super(e2);
    }
  };
  var tr = class {
    constructor() {
      __publicField(this, "size", 0);
      __publicField(this, "modificationCount", 0);
      __publicField(this, "splayCount", 0);
    }
    splay(e2) {
      let i = this.root;
      if (i == null) return this.compare(e2, e2), -1;
      let r2 = null, n2 = null, s2 = null, a = null, o = i, l2 = this.compare, u2;
      for (; ; ) if (u2 = l2(o.key, e2), u2 > 0) {
        let f2 = o.left;
        if (f2 == null || (u2 = l2(f2.key, e2), u2 > 0 && (o.left = f2.right, f2.right = o, o = f2, f2 = o.left, f2 == null))) break;
        r2 == null ? n2 = o : r2.left = o, r2 = o, o = f2;
      } else if (u2 < 0) {
        let f2 = o.right;
        if (f2 == null || (u2 = l2(f2.key, e2), u2 < 0 && (o.right = f2.left, f2.left = o, o = f2, f2 = o.right, f2 == null))) break;
        s2 == null ? a = o : s2.right = o, s2 = o, o = f2;
      } else break;
      return s2 != null && (s2.right = o.left, o.left = a), r2 != null && (r2.left = o.right, o.right = n2), this.root !== o && (this.root = o, this.splayCount++), u2;
    }
    splayMin(e2) {
      let i = e2, r2 = i.left;
      for (; r2 != null; ) {
        let n2 = r2;
        i.left = n2.right, n2.right = i, i = n2, r2 = i.left;
      }
      return i;
    }
    splayMax(e2) {
      let i = e2, r2 = i.right;
      for (; r2 != null; ) {
        let n2 = r2;
        i.right = n2.left, n2.left = i, i = n2, r2 = i.right;
      }
      return i;
    }
    _delete(e2) {
      if (this.root == null || this.splay(e2) != 0) return null;
      let r2 = this.root, n2 = r2, s2 = r2.left;
      if (this.size--, s2 == null) this.root = r2.right;
      else {
        let a = r2.right;
        r2 = this.splayMax(s2), r2.right = a, this.root = r2;
      }
      return this.modificationCount++, n2;
    }
    addNewRoot(e2, i) {
      this.size++, this.modificationCount++;
      let r2 = this.root;
      if (r2 == null) {
        this.root = e2;
        return;
      }
      i < 0 ? (e2.left = r2, e2.right = r2.right, r2.right = null) : (e2.right = r2, e2.left = r2.left, r2.left = null), this.root = e2;
    }
    _first() {
      let e2 = this.root;
      return e2 == null ? null : (this.root = this.splayMin(e2), this.root);
    }
    _last() {
      let e2 = this.root;
      return e2 == null ? null : (this.root = this.splayMax(e2), this.root);
    }
    clear() {
      this.root = null, this.size = 0, this.modificationCount++;
    }
    has(e2) {
      return this.validKey(e2) && this.splay(e2) == 0;
    }
    defaultCompare() {
      return (e2, i) => e2 < i ? -1 : e2 > i ? 1 : 0;
    }
    wrap() {
      return { getRoot: () => this.root, setRoot: (e2) => {
        this.root = e2;
      }, getSize: () => this.size, getModificationCount: () => this.modificationCount, getSplayCount: () => this.splayCount, setSplayCount: (e2) => {
        this.splayCount = e2;
      }, splay: (e2) => this.splay(e2), has: (e2) => this.has(e2) };
    }
  };
  var Pt = class t2 extends tr {
    constructor(e2, i) {
      super();
      __publicField(this, "root", null);
      __publicField(this, "compare");
      __publicField(this, "validKey");
      __publicField(this, _a2, "[object Set]");
      this.compare = e2 ?? this.defaultCompare(), this.validKey = i ?? ((r2) => r2 != null && r2 != null);
    }
    delete(e2) {
      return this.validKey(e2) ? this._delete(e2) != null : false;
    }
    deleteAll(e2) {
      for (let i of e2) this.delete(i);
    }
    forEach(e2) {
      let i = this[Symbol.iterator](), r2;
      for (; r2 = i.next(), !r2.done; ) e2(r2.value, r2.value, this);
    }
    add(e2) {
      let i = this.splay(e2);
      return i != 0 && this.addNewRoot(new jt(e2), i), this;
    }
    addAndReturn(e2) {
      let i = this.splay(e2);
      return i != 0 && this.addNewRoot(new jt(e2), i), this.root.key;
    }
    addAll(e2) {
      for (let i of e2) this.add(i);
    }
    isEmpty() {
      return this.root == null;
    }
    isNotEmpty() {
      return this.root != null;
    }
    single() {
      if (this.size == 0) throw "Bad state: No element";
      if (this.size > 1) throw "Bad state: Too many element";
      return this.root.key;
    }
    first() {
      if (this.size == 0) throw "Bad state: No element";
      return this._first().key;
    }
    last() {
      if (this.size == 0) throw "Bad state: No element";
      return this._last().key;
    }
    lastBefore(e2) {
      if (e2 == null) throw "Invalid arguments(s)";
      if (this.root == null) return null;
      if (this.splay(e2) < 0) return this.root.key;
      let r2 = this.root.left;
      if (r2 == null) return null;
      let n2 = r2.right;
      for (; n2 != null; ) r2 = n2, n2 = r2.right;
      return r2.key;
    }
    firstAfter(e2) {
      if (e2 == null) throw "Invalid arguments(s)";
      if (this.root == null) return null;
      if (this.splay(e2) > 0) return this.root.key;
      let r2 = this.root.right;
      if (r2 == null) return null;
      let n2 = r2.left;
      for (; n2 != null; ) r2 = n2, n2 = r2.left;
      return r2.key;
    }
    retainAll(e2) {
      let i = new t2(this.compare, this.validKey), r2 = this.modificationCount;
      for (let n2 of e2) {
        if (r2 != this.modificationCount) throw "Concurrent modification during iteration.";
        this.validKey(n2) && this.splay(n2) == 0 && i.add(this.root.key);
      }
      i.size != this.size && (this.root = i.root, this.size = i.size, this.modificationCount++);
    }
    lookup(e2) {
      return !this.validKey(e2) || this.splay(e2) != 0 ? null : this.root.key;
    }
    intersection(e2) {
      let i = new t2(this.compare, this.validKey);
      for (let r2 of this) e2.has(r2) && i.add(r2);
      return i;
    }
    difference(e2) {
      let i = new t2(this.compare, this.validKey);
      for (let r2 of this) e2.has(r2) || i.add(r2);
      return i;
    }
    union(e2) {
      let i = this.clone();
      return i.addAll(e2), i;
    }
    clone() {
      let e2 = new t2(this.compare, this.validKey);
      return e2.size = this.size, e2.root = this.copyNode(this.root), e2;
    }
    copyNode(e2) {
      if (e2 == null) return null;
      function i(n2, s2) {
        let a, o;
        do {
          if (a = n2.left, o = n2.right, a != null) {
            let l2 = new jt(a.key);
            s2.left = l2, i(a, l2);
          }
          if (o != null) {
            let l2 = new jt(o.key);
            s2.right = l2, n2 = o, s2 = l2;
          }
        } while (o != null);
      }
      let r2 = new jt(e2.key);
      return i(e2, r2), r2;
    }
    toSet() {
      return this.clone();
    }
    entries() {
      return new ir(this.wrap());
    }
    keys() {
      return this[Symbol.iterator]();
    }
    values() {
      return this[Symbol.iterator]();
    }
    [(_b = Symbol.iterator, _a2 = Symbol.toStringTag, _b)]() {
      return new er(this.wrap());
    }
  }, $e2 = class {
    constructor(e2) {
      __publicField(this, "tree");
      __publicField(this, "path", new Array());
      __publicField(this, "modificationCount", null);
      __publicField(this, "splayCount");
      this.tree = e2, this.splayCount = e2.getSplayCount();
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      return this.moveNext() ? { done: false, value: this.current() } : { done: true, value: null };
    }
    current() {
      if (!this.path.length) return null;
      let e2 = this.path[this.path.length - 1];
      return this.getValue(e2);
    }
    rebuildPath(e2) {
      this.path.splice(0, this.path.length), this.tree.splay(e2), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
    }
    findLeftMostDescendent(e2) {
      for (; e2 != null; ) this.path.push(e2), e2 = e2.left;
    }
    moveNext() {
      if (this.modificationCount != this.tree.getModificationCount()) {
        if (this.modificationCount == null) {
          this.modificationCount = this.tree.getModificationCount();
          let r2 = this.tree.getRoot();
          for (; r2 != null; ) this.path.push(r2), r2 = r2.left;
          return this.path.length > 0;
        }
        throw "Concurrent modification during iteration.";
      }
      if (!this.path.length) return false;
      this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
      let e2 = this.path[this.path.length - 1], i = e2.right;
      if (i != null) {
        for (; i != null; ) this.path.push(i), i = i.left;
        return true;
      }
      for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === e2; ) e2 = this.path.pop();
      return this.path.length > 0;
    }
  }, er = class extends $e2 {
    getValue(e2) {
      return e2.key;
    }
  }, ir = class extends $e2 {
    getValue(e2) {
      return [e2.key, e2.key];
    }
  };
  var El = (t2) => t2;
  var Pl = (t2) => {
    if (t2) {
      let e2 = new Pt(Ee2(t2)), i = new Pt(Ee2(t2)), r2 = (s2, a) => a.addAndReturn(s2), n2 = (s2) => ({ x: r2(s2.x, e2), y: r2(s2.y, i) });
      return n2({ x: new mt(0), y: new mt(0) }), n2;
    }
    return El;
  };
  var rr = (t2) => ({ set: (e2) => {
    ut = rr(e2);
  }, reset: () => rr(t2), compare: Ee2(t2), snap: Pl(t2), orient: xl(t2) }), ut = rr();
  var ae2 = (t2, e2) => t2.ll.x.isLessThanOrEqualTo(e2.x) && e2.x.isLessThanOrEqualTo(t2.ur.x) && t2.ll.y.isLessThanOrEqualTo(e2.y) && e2.y.isLessThanOrEqualTo(t2.ur.y), Pe2 = (t2, e2) => {
    if (e2.ur.x.isLessThan(t2.ll.x) || t2.ur.x.isLessThan(e2.ll.x) || e2.ur.y.isLessThan(t2.ll.y) || t2.ur.y.isLessThan(e2.ll.y)) return null;
    let i = t2.ll.x.isLessThan(e2.ll.x) ? e2.ll.x : t2.ll.x, r2 = t2.ur.x.isLessThan(e2.ur.x) ? t2.ur.x : e2.ur.x, n2 = t2.ll.y.isLessThan(e2.ll.y) ? e2.ll.y : t2.ll.y, s2 = t2.ur.y.isLessThan(e2.ur.y) ? t2.ur.y : e2.ur.y;
    return { ll: { x: i, y: n2 }, ur: { x: r2, y: s2 } };
  };
  var Ze2 = (t2, e2) => t2.x.times(e2.y).minus(t2.y.times(e2.x)), Tl = (t2, e2) => t2.x.times(e2.x).plus(t2.y.times(e2.y)), We2 = (t2) => Tl(t2, t2).sqrt(), Rl = (t2, e2, i) => {
    let r2 = { x: e2.x.minus(t2.x), y: e2.y.minus(t2.y) }, n2 = { x: i.x.minus(t2.x), y: i.y.minus(t2.y) };
    return Ze2(n2, r2).div(We2(n2)).div(We2(r2));
  }, Dl = (t2, e2, i) => {
    let r2 = { x: e2.x.minus(t2.x), y: e2.y.minus(t2.y) }, n2 = { x: i.x.minus(t2.x), y: i.y.minus(t2.y) };
    return Tl(n2, r2).div(We2(n2)).div(We2(r2));
  }, Sl = (t2, e2, i) => e2.y.isZero() ? null : { x: t2.x.plus(e2.x.div(e2.y).times(i.minus(t2.y))), y: i }, Bl = (t2, e2, i) => e2.x.isZero() ? null : { x: i, y: t2.y.plus(e2.y.div(e2.x).times(i.minus(t2.x))) }, Ol = (t2, e2, i, r2) => {
    if (e2.x.isZero()) return Bl(i, r2, t2.x);
    if (r2.x.isZero()) return Bl(t2, e2, i.x);
    if (e2.y.isZero()) return Sl(i, r2, t2.y);
    if (r2.y.isZero()) return Sl(t2, e2, i.y);
    let n2 = Ze2(e2, r2);
    if (n2.isZero()) return null;
    let s2 = { x: i.x.minus(t2.x), y: i.y.minus(t2.y) }, a = Ze2(s2, e2).div(n2), o = Ze2(s2, r2).div(n2), l2 = t2.x.plus(o.times(e2.x)), u2 = i.x.plus(a.times(r2.x)), f2 = t2.y.plus(o.times(e2.y)), d = i.y.plus(a.times(r2.y)), P2 = l2.plus(u2).div(2), E2 = f2.plus(d).div(2);
    return { x: P2, y: E2 };
  };
  var et = class t2 {
    constructor(e2, i) {
      __publicField(this, "point");
      __publicField(this, "isLeft");
      __publicField(this, "segment");
      __publicField(this, "otherSE");
      __publicField(this, "consumedBy");
      e2.events === void 0 ? e2.events = [this] : e2.events.push(this), this.point = e2, this.isLeft = i;
    }
    static compare(e2, i) {
      let r2 = t2.comparePoints(e2.point, i.point);
      return r2 !== 0 ? r2 : (e2.point !== i.point && e2.link(i), e2.isLeft !== i.isLeft ? e2.isLeft ? 1 : -1 : Mt.compare(e2.segment, i.segment));
    }
    static comparePoints(e2, i) {
      return e2.x.isLessThan(i.x) ? -1 : e2.x.isGreaterThan(i.x) ? 1 : e2.y.isLessThan(i.y) ? -1 : e2.y.isGreaterThan(i.y) ? 1 : 0;
    }
    link(e2) {
      if (e2.point === this.point) throw new Error("Tried to link already linked events");
      let i = e2.point.events;
      for (let r2 = 0, n2 = i.length; r2 < n2; r2++) {
        let s2 = i[r2];
        this.point.events.push(s2), s2.point = this.point;
      }
      this.checkForConsuming();
    }
    checkForConsuming() {
      let e2 = this.point.events.length;
      for (let i = 0; i < e2; i++) {
        let r2 = this.point.events[i];
        if (r2.segment.consumedBy === void 0) for (let n2 = i + 1; n2 < e2; n2++) {
          let s2 = this.point.events[n2];
          s2.consumedBy === void 0 && r2.otherSE.point.events === s2.otherSE.point.events && r2.segment.consume(s2.segment);
        }
      }
    }
    getAvailableLinkedEvents() {
      let e2 = [];
      for (let i = 0, r2 = this.point.events.length; i < r2; i++) {
        let n2 = this.point.events[i];
        n2 !== this && !n2.segment.ringOut && n2.segment.isInResult() && e2.push(n2);
      }
      return e2;
    }
    getLeftmostComparator(e2) {
      let i = /* @__PURE__ */ new Map(), r2 = (n2) => {
        let s2 = n2.otherSE;
        i.set(n2, { sine: Rl(this.point, e2.point, s2.point), cosine: Dl(this.point, e2.point, s2.point) });
      };
      return (n2, s2) => {
        i.has(n2) || r2(n2), i.has(s2) || r2(s2);
        let { sine: a, cosine: o } = i.get(n2), { sine: l2, cosine: u2 } = i.get(s2);
        return a.isGreaterThanOrEqualTo(0) && l2.isGreaterThanOrEqualTo(0) ? o.isLessThan(u2) ? 1 : o.isGreaterThan(u2) ? -1 : 0 : a.isLessThan(0) && l2.isLessThan(0) ? o.isLessThan(u2) ? -1 : o.isGreaterThan(u2) ? 1 : 0 : l2.isLessThan(a) ? -1 : l2.isGreaterThan(a) ? 1 : 0;
      };
    }
  };
  var c_ = 0, Mt = class t2 {
    constructor(e2, i, r2, n2) {
      __publicField(this, "id");
      __publicField(this, "leftSE");
      __publicField(this, "rightSE");
      __publicField(this, "rings");
      __publicField(this, "windings");
      __publicField(this, "ringOut");
      __publicField(this, "consumedBy");
      __publicField(this, "prev");
      __publicField(this, "_prevInResult");
      __publicField(this, "_beforeState");
      __publicField(this, "_afterState");
      __publicField(this, "_isInResult");
      this.id = ++c_, this.leftSE = e2, e2.segment = this, e2.otherSE = i, this.rightSE = i, i.segment = this, i.otherSE = e2, this.rings = r2, this.windings = n2;
    }
    static compare(e2, i) {
      let r2 = e2.leftSE.point.x, n2 = i.leftSE.point.x, s2 = e2.rightSE.point.x, a = i.rightSE.point.x;
      if (a.isLessThan(r2)) return 1;
      if (s2.isLessThan(n2)) return -1;
      let o = e2.leftSE.point.y, l2 = i.leftSE.point.y, u2 = e2.rightSE.point.y, f2 = i.rightSE.point.y;
      if (r2.isLessThan(n2)) {
        if (l2.isLessThan(o) && l2.isLessThan(u2)) return 1;
        if (l2.isGreaterThan(o) && l2.isGreaterThan(u2)) return -1;
        let d = e2.comparePoint(i.leftSE.point);
        if (d < 0) return 1;
        if (d > 0) return -1;
        let P2 = i.comparePoint(e2.rightSE.point);
        return P2 !== 0 ? P2 : -1;
      }
      if (r2.isGreaterThan(n2)) {
        if (o.isLessThan(l2) && o.isLessThan(f2)) return -1;
        if (o.isGreaterThan(l2) && o.isGreaterThan(f2)) return 1;
        let d = i.comparePoint(e2.leftSE.point);
        if (d !== 0) return d;
        let P2 = e2.comparePoint(i.rightSE.point);
        return P2 < 0 ? 1 : P2 > 0 ? -1 : 1;
      }
      if (o.isLessThan(l2)) return -1;
      if (o.isGreaterThan(l2)) return 1;
      if (s2.isLessThan(a)) {
        let d = i.comparePoint(e2.rightSE.point);
        if (d !== 0) return d;
      }
      if (s2.isGreaterThan(a)) {
        let d = e2.comparePoint(i.rightSE.point);
        if (d < 0) return 1;
        if (d > 0) return -1;
      }
      if (!s2.eq(a)) {
        let d = u2.minus(o), P2 = s2.minus(r2), E2 = f2.minus(l2), T2 = a.minus(n2);
        if (d.isGreaterThan(P2) && E2.isLessThan(T2)) return 1;
        if (d.isLessThan(P2) && E2.isGreaterThan(T2)) return -1;
      }
      return s2.isGreaterThan(a) ? 1 : s2.isLessThan(a) || u2.isLessThan(f2) ? -1 : u2.isGreaterThan(f2) ? 1 : e2.id < i.id ? -1 : e2.id > i.id ? 1 : 0;
    }
    static fromRing(e2, i, r2) {
      let n2, s2, a, o = et.comparePoints(e2, i);
      if (o < 0) n2 = e2, s2 = i, a = 1;
      else if (o > 0) n2 = i, s2 = e2, a = -1;
      else throw new Error(`Tried to create degenerate segment at [${e2.x}, ${e2.y}]`);
      let l2 = new et(n2, true), u2 = new et(s2, false);
      return new t2(l2, u2, [r2], [a]);
    }
    replaceRightSE(e2) {
      this.rightSE = e2, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
    }
    bbox() {
      let e2 = this.leftSE.point.y, i = this.rightSE.point.y;
      return { ll: { x: this.leftSE.point.x, y: e2.isLessThan(i) ? e2 : i }, ur: { x: this.rightSE.point.x, y: e2.isGreaterThan(i) ? e2 : i } };
    }
    vector() {
      return { x: this.rightSE.point.x.minus(this.leftSE.point.x), y: this.rightSE.point.y.minus(this.leftSE.point.y) };
    }
    isAnEndpoint(e2) {
      return e2.x.eq(this.leftSE.point.x) && e2.y.eq(this.leftSE.point.y) || e2.x.eq(this.rightSE.point.x) && e2.y.eq(this.rightSE.point.y);
    }
    comparePoint(e2) {
      return ut.orient(this.leftSE.point, e2, this.rightSE.point);
    }
    getIntersection(e2) {
      let i = this.bbox(), r2 = e2.bbox(), n2 = Pe2(i, r2);
      if (n2 === null) return null;
      let s2 = this.leftSE.point, a = this.rightSE.point, o = e2.leftSE.point, l2 = e2.rightSE.point, u2 = ae2(i, o) && this.comparePoint(o) === 0, f2 = ae2(r2, s2) && e2.comparePoint(s2) === 0, d = ae2(i, l2) && this.comparePoint(l2) === 0, P2 = ae2(r2, a) && e2.comparePoint(a) === 0;
      if (f2 && u2) return P2 && !d ? a : !P2 && d ? l2 : null;
      if (f2) return d && s2.x.eq(l2.x) && s2.y.eq(l2.y) ? null : s2;
      if (u2) return P2 && a.x.eq(o.x) && a.y.eq(o.y) ? null : o;
      if (P2 && d) return null;
      if (P2) return a;
      if (d) return l2;
      let E2 = Ol(s2, this.vector(), o, e2.vector());
      return E2 === null || !ae2(n2, E2) ? null : ut.snap(E2);
    }
    split(e2) {
      let i = [], r2 = e2.events !== void 0, n2 = new et(e2, true), s2 = new et(e2, false), a = this.rightSE;
      this.replaceRightSE(s2), i.push(s2), i.push(n2);
      let o = new t2(n2, a, this.rings.slice(), this.windings.slice());
      return et.comparePoints(o.leftSE.point, o.rightSE.point) > 0 && o.swapEvents(), et.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r2 && (n2.checkForConsuming(), s2.checkForConsuming()), i;
    }
    swapEvents() {
      let e2 = this.rightSE;
      this.rightSE = this.leftSE, this.leftSE = e2, this.leftSE.isLeft = true, this.rightSE.isLeft = false;
      for (let i = 0, r2 = this.windings.length; i < r2; i++) this.windings[i] *= -1;
    }
    consume(e2) {
      let i = this, r2 = e2;
      for (; i.consumedBy; ) i = i.consumedBy;
      for (; r2.consumedBy; ) r2 = r2.consumedBy;
      let n2 = t2.compare(i, r2);
      if (n2 !== 0) {
        if (n2 > 0) {
          let s2 = i;
          i = r2, r2 = s2;
        }
        if (i.prev === r2) {
          let s2 = i;
          i = r2, r2 = s2;
        }
        for (let s2 = 0, a = r2.rings.length; s2 < a; s2++) {
          let o = r2.rings[s2], l2 = r2.windings[s2], u2 = i.rings.indexOf(o);
          u2 === -1 ? (i.rings.push(o), i.windings.push(l2)) : i.windings[u2] += l2;
        }
        r2.rings = null, r2.windings = null, r2.consumedBy = i, r2.leftSE.consumedBy = i.leftSE, r2.rightSE.consumedBy = i.rightSE;
      }
    }
    prevInResult() {
      return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
    }
    beforeState() {
      if (this._beforeState !== void 0) return this._beforeState;
      if (!this.prev) this._beforeState = { rings: [], windings: [], multiPolys: [] };
      else {
        let e2 = this.prev.consumedBy || this.prev;
        this._beforeState = e2.afterState();
      }
      return this._beforeState;
    }
    afterState() {
      if (this._afterState !== void 0) return this._afterState;
      let e2 = this.beforeState();
      this._afterState = { rings: e2.rings.slice(0), windings: e2.windings.slice(0), multiPolys: [] };
      let i = this._afterState.rings, r2 = this._afterState.windings, n2 = this._afterState.multiPolys;
      for (let o = 0, l2 = this.rings.length; o < l2; o++) {
        let u2 = this.rings[o], f2 = this.windings[o], d = i.indexOf(u2);
        d === -1 ? (i.push(u2), r2.push(f2)) : r2[d] += f2;
      }
      let s2 = [], a = [];
      for (let o = 0, l2 = i.length; o < l2; o++) {
        if (r2[o] === 0) continue;
        let u2 = i[o], f2 = u2.poly;
        if (a.indexOf(f2) === -1) if (u2.isExterior) s2.push(f2);
        else {
          a.indexOf(f2) === -1 && a.push(f2);
          let d = s2.indexOf(u2.poly);
          d !== -1 && s2.splice(d, 1);
        }
      }
      for (let o = 0, l2 = s2.length; o < l2; o++) {
        let u2 = s2[o].multiPoly;
        n2.indexOf(u2) === -1 && n2.push(u2);
      }
      return this._afterState;
    }
    isInResult() {
      if (this.consumedBy) return false;
      if (this._isInResult !== void 0) return this._isInResult;
      let e2 = this.beforeState().multiPolys, i = this.afterState().multiPolys;
      switch (oe2.type) {
        case "union": {
          let r2 = e2.length === 0, n2 = i.length === 0;
          this._isInResult = r2 !== n2;
          break;
        }
        case "intersection": {
          let r2, n2;
          e2.length < i.length ? (r2 = e2.length, n2 = i.length) : (r2 = i.length, n2 = e2.length), this._isInResult = n2 === oe2.numMultiPolys && r2 < n2;
          break;
        }
        case "xor": {
          let r2 = Math.abs(e2.length - i.length);
          this._isInResult = r2 % 2 === 1;
          break;
        }
        case "difference": {
          let r2 = (n2) => n2.length === 1 && n2[0].isSubject;
          this._isInResult = r2(e2) !== r2(i);
          break;
        }
      }
      return this._isInResult;
    }
  };
  var Qe2 = class {
    constructor(e2, i, r2) {
      __publicField(this, "poly");
      __publicField(this, "isExterior");
      __publicField(this, "segments");
      __publicField(this, "bbox");
      if (!Array.isArray(e2) || e2.length === 0) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      if (this.poly = i, this.isExterior = r2, this.segments = [], typeof e2[0][0] != "number" || typeof e2[0][1] != "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let n2 = ut.snap({ x: new mt(e2[0][0]), y: new mt(e2[0][1]) });
      this.bbox = { ll: { x: n2.x, y: n2.y }, ur: { x: n2.x, y: n2.y } };
      let s2 = n2;
      for (let a = 1, o = e2.length; a < o; a++) {
        if (typeof e2[a][0] != "number" || typeof e2[a][1] != "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        let l2 = ut.snap({ x: new mt(e2[a][0]), y: new mt(e2[a][1]) });
        l2.x.eq(s2.x) && l2.y.eq(s2.y) || (this.segments.push(Mt.fromRing(s2, l2, this)), l2.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = l2.x), l2.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = l2.y), l2.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = l2.x), l2.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = l2.y), s2 = l2);
      }
      (!n2.x.eq(s2.x) || !n2.y.eq(s2.y)) && this.segments.push(Mt.fromRing(s2, n2, this));
    }
    getSweepEvents() {
      let e2 = [];
      for (let i = 0, r2 = this.segments.length; i < r2; i++) {
        let n2 = this.segments[i];
        e2.push(n2.leftSE), e2.push(n2.rightSE);
      }
      return e2;
    }
  }, nr = class {
    constructor(e2, i) {
      __publicField(this, "multiPoly");
      __publicField(this, "exteriorRing");
      __publicField(this, "interiorRings");
      __publicField(this, "bbox");
      if (!Array.isArray(e2)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      this.exteriorRing = new Qe2(e2[0], this, true), this.bbox = { ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y }, ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y } }, this.interiorRings = [];
      for (let r2 = 1, n2 = e2.length; r2 < n2; r2++) {
        let s2 = new Qe2(e2[r2], this, false);
        s2.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = s2.bbox.ll.x), s2.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = s2.bbox.ll.y), s2.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = s2.bbox.ur.x), s2.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = s2.bbox.ur.y), this.interiorRings.push(s2);
      }
      this.multiPoly = i;
    }
    getSweepEvents() {
      let e2 = this.exteriorRing.getSweepEvents();
      for (let i = 0, r2 = this.interiorRings.length; i < r2; i++) {
        let n2 = this.interiorRings[i].getSweepEvents();
        for (let s2 = 0, a = n2.length; s2 < a; s2++) e2.push(n2[s2]);
      }
      return e2;
    }
  }, Se2 = class {
    constructor(e2, i) {
      __publicField(this, "isSubject");
      __publicField(this, "polys");
      __publicField(this, "bbox");
      if (!Array.isArray(e2)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      try {
        typeof e2[0][0][0] == "number" && (e2 = [e2]);
      } catch {
      }
      this.polys = [], this.bbox = { ll: { x: new mt(Number.POSITIVE_INFINITY), y: new mt(Number.POSITIVE_INFINITY) }, ur: { x: new mt(Number.NEGATIVE_INFINITY), y: new mt(Number.NEGATIVE_INFINITY) } };
      for (let r2 = 0, n2 = e2.length; r2 < n2; r2++) {
        let s2 = new nr(e2[r2], this);
        s2.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = s2.bbox.ll.x), s2.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = s2.bbox.ll.y), s2.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = s2.bbox.ur.x), s2.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = s2.bbox.ur.y), this.polys.push(s2);
      }
      this.isSubject = i;
    }
    getSweepEvents() {
      let e2 = [];
      for (let i = 0, r2 = this.polys.length; i < r2; i++) {
        let n2 = this.polys[i].getSweepEvents();
        for (let s2 = 0, a = n2.length; s2 < a; s2++) e2.push(n2[s2]);
      }
      return e2;
    }
  };
  var ti2 = class t2 {
    constructor(e2) {
      __publicField(this, "events");
      __publicField(this, "poly");
      __publicField(this, "_isExteriorRing");
      __publicField(this, "_enclosingRing");
      this.events = e2;
      for (let i = 0, r2 = e2.length; i < r2; i++) e2[i].segment.ringOut = this;
      this.poly = null;
    }
    static factory(e2) {
      let i = [];
      for (let r2 = 0, n2 = e2.length; r2 < n2; r2++) {
        let s2 = e2[r2];
        if (!s2.isInResult() || s2.ringOut) continue;
        let a = null, o = s2.leftSE, l2 = s2.rightSE, u2 = [o], f2 = o.point, d = [];
        for (; a = o, o = l2, u2.push(o), o.point !== f2; ) for (; ; ) {
          let P2 = o.getAvailableLinkedEvents();
          if (P2.length === 0) {
            let G2 = u2[0].point, _ = u2[u2.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${G2.x}, ${G2.y}]. Last matching segment found ends at [${_.x}, ${_.y}].`);
          }
          if (P2.length === 1) {
            l2 = P2[0].otherSE;
            break;
          }
          let E2 = null;
          for (let G2 = 0, _ = d.length; G2 < _; G2++) if (d[G2].point === o.point) {
            E2 = G2;
            break;
          }
          if (E2 !== null) {
            let G2 = d.splice(E2)[0], _ = u2.splice(G2.index);
            _.unshift(_[0].otherSE), i.push(new t2(_.reverse()));
            continue;
          }
          d.push({ index: u2.length, point: o.point });
          let T2 = o.getLeftmostComparator(a);
          l2 = P2.sort(T2)[0].otherSE;
          break;
        }
        i.push(new t2(u2));
      }
      return i;
    }
    getGeom() {
      let e2 = this.events[0].point, i = [e2];
      for (let u2 = 1, f2 = this.events.length - 1; u2 < f2; u2++) {
        let d = this.events[u2].point, P2 = this.events[u2 + 1].point;
        ut.orient(d, e2, P2) !== 0 && (i.push(d), e2 = d);
      }
      if (i.length === 1) return null;
      let r2 = i[0], n2 = i[1];
      ut.orient(r2, e2, n2) === 0 && i.shift(), i.push(i[0]);
      let s2 = this.isExteriorRing() ? 1 : -1, a = this.isExteriorRing() ? 0 : i.length - 1, o = this.isExteriorRing() ? i.length : -1, l2 = [];
      for (let u2 = a; u2 != o; u2 += s2) l2.push([i[u2].x.toNumber(), i[u2].y.toNumber()]);
      return l2;
    }
    isExteriorRing() {
      if (this._isExteriorRing === void 0) {
        let e2 = this.enclosingRing();
        this._isExteriorRing = e2 ? !e2.isExteriorRing() : true;
      }
      return this._isExteriorRing;
    }
    enclosingRing() {
      return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
    }
    _calcEnclosingRing() {
      var _a3, _b2;
      let e2 = this.events[0];
      for (let n2 = 1, s2 = this.events.length; n2 < s2; n2++) {
        let a = this.events[n2];
        et.compare(e2, a) > 0 && (e2 = a);
      }
      let i = e2.segment.prevInResult(), r2 = i ? i.prevInResult() : null;
      for (; ; ) {
        if (!i) return null;
        if (!r2) return i.ringOut;
        if (r2.ringOut !== i.ringOut) return ((_a3 = r2.ringOut) == null ? void 0 : _a3.enclosingRing()) !== i.ringOut ? i.ringOut : (_b2 = i.ringOut) == null ? void 0 : _b2.enclosingRing();
        i = r2.prevInResult(), r2 = i ? i.prevInResult() : null;
      }
    }
  }, ei2 = class {
    constructor(e2) {
      __publicField(this, "exteriorRing");
      __publicField(this, "interiorRings");
      this.exteriorRing = e2, e2.poly = this, this.interiorRings = [];
    }
    addInterior(e2) {
      this.interiorRings.push(e2), e2.poly = this;
    }
    getGeom() {
      let e2 = this.exteriorRing.getGeom();
      if (e2 === null) return null;
      let i = [e2];
      for (let r2 = 0, n2 = this.interiorRings.length; r2 < n2; r2++) {
        let s2 = this.interiorRings[r2].getGeom();
        s2 !== null && i.push(s2);
      }
      return i;
    }
  }, ii2 = class {
    constructor(e2) {
      __publicField(this, "rings");
      __publicField(this, "polys");
      this.rings = e2, this.polys = this._composePolys(e2);
    }
    getGeom() {
      let e2 = [];
      for (let i = 0, r2 = this.polys.length; i < r2; i++) {
        let n2 = this.polys[i].getGeom();
        n2 !== null && e2.push(n2);
      }
      return e2;
    }
    _composePolys(e2) {
      var _a3;
      let i = [];
      for (let r2 = 0, n2 = e2.length; r2 < n2; r2++) {
        let s2 = e2[r2];
        if (!s2.poly) if (s2.isExteriorRing()) i.push(new ei2(s2));
        else {
          let a = s2.enclosingRing();
          (a == null ? void 0 : a.poly) || i.push(new ei2(a)), (_a3 = a == null ? void 0 : a.poly) == null ? void 0 : _a3.addInterior(s2);
        }
      }
      return i;
    }
  };
  var Be2 = class {
    constructor(e2, i = Mt.compare) {
      __publicField(this, "queue");
      __publicField(this, "tree");
      __publicField(this, "segments");
      this.queue = e2, this.tree = new Pt(i), this.segments = [];
    }
    process(e2) {
      let i = e2.segment, r2 = [];
      if (e2.consumedBy) return e2.isLeft ? this.queue.delete(e2.otherSE) : this.tree.delete(i), r2;
      e2.isLeft && this.tree.add(i);
      let n2 = i, s2 = i;
      do
        n2 = this.tree.lastBefore(n2);
      while (n2 != null && n2.consumedBy != null);
      do
        s2 = this.tree.firstAfter(s2);
      while (s2 != null && s2.consumedBy != null);
      if (e2.isLeft) {
        let a = null;
        if (n2) {
          let l2 = n2.getIntersection(i);
          if (l2 !== null && (i.isAnEndpoint(l2) || (a = l2), !n2.isAnEndpoint(l2))) {
            let u2 = this._splitSafely(n2, l2);
            for (let f2 = 0, d = u2.length; f2 < d; f2++) r2.push(u2[f2]);
          }
        }
        let o = null;
        if (s2) {
          let l2 = s2.getIntersection(i);
          if (l2 !== null && (i.isAnEndpoint(l2) || (o = l2), !s2.isAnEndpoint(l2))) {
            let u2 = this._splitSafely(s2, l2);
            for (let f2 = 0, d = u2.length; f2 < d; f2++) r2.push(u2[f2]);
          }
        }
        if (a !== null || o !== null) {
          let l2 = null;
          a === null ? l2 = o : o === null ? l2 = a : l2 = et.comparePoints(a, o) <= 0 ? a : o, this.queue.delete(i.rightSE), r2.push(i.rightSE);
          let u2 = i.split(l2);
          for (let f2 = 0, d = u2.length; f2 < d; f2++) r2.push(u2[f2]);
        }
        r2.length > 0 ? (this.tree.delete(i), r2.push(e2)) : (this.segments.push(i), i.prev = n2);
      } else {
        if (n2 && s2) {
          let a = n2.getIntersection(s2);
          if (a !== null) {
            if (!n2.isAnEndpoint(a)) {
              let o = this._splitSafely(n2, a);
              for (let l2 = 0, u2 = o.length; l2 < u2; l2++) r2.push(o[l2]);
            }
            if (!s2.isAnEndpoint(a)) {
              let o = this._splitSafely(s2, a);
              for (let l2 = 0, u2 = o.length; l2 < u2; l2++) r2.push(o[l2]);
            }
          }
        }
        this.tree.delete(i);
      }
      return r2;
    }
    _splitSafely(e2, i) {
      this.tree.delete(e2);
      let r2 = e2.rightSE;
      this.queue.delete(r2);
      let n2 = e2.split(i);
      return n2.push(r2), e2.consumedBy === void 0 && this.tree.add(e2), n2;
    }
  };
  var sr = class {
    constructor() {
      __publicField(this, "type");
      __publicField(this, "numMultiPolys");
    }
    run(e2, i, r2) {
      Te2.type = e2;
      let n2 = [new Se2(i, true)];
      for (let f2 = 0, d = r2.length; f2 < d; f2++) n2.push(new Se2(r2[f2], false));
      if (Te2.numMultiPolys = n2.length, Te2.type === "difference") {
        let f2 = n2[0], d = 1;
        for (; d < n2.length; ) Pe2(n2[d].bbox, f2.bbox) !== null ? d++ : n2.splice(d, 1);
      }
      if (Te2.type === "intersection") for (let f2 = 0, d = n2.length; f2 < d; f2++) {
        let P2 = n2[f2];
        for (let E2 = f2 + 1, T2 = n2.length; E2 < T2; E2++) if (Pe2(P2.bbox, n2[E2].bbox) === null) return [];
      }
      let s2 = new Pt(et.compare);
      for (let f2 = 0, d = n2.length; f2 < d; f2++) {
        let P2 = n2[f2].getSweepEvents();
        for (let E2 = 0, T2 = P2.length; E2 < T2; E2++) s2.add(P2[E2]);
      }
      let a = new Be2(s2), o = null;
      for (s2.size != 0 && (o = s2.first(), s2.delete(o)); o; ) {
        let f2 = a.process(o);
        for (let d = 0, P2 = f2.length; d < P2; d++) {
          let E2 = f2[d];
          E2.consumedBy === void 0 && s2.add(E2);
        }
        s2.size != 0 ? (o = s2.first(), s2.delete(o)) : o = null;
      }
      ut.reset();
      let l2 = ti2.factory(a.segments);
      return new ii2(l2).getGeom();
    }
  }, Te2 = new sr(), oe2 = Te2;
  var Al = (t2, ...e2) => oe2.run("intersection", t2, e2);
  var Il = (t2, ...e2) => oe2.run("difference", t2, e2);
  ut.set;
  function ni2(t2) {
    let e2 = { type: "Feature" };
    return e2.geometry = t2, e2;
  }
  function ri2(t2) {
    return t2.type === "Feature" ? t2.geometry : t2;
  }
  function Gl(t2) {
    return t2 && t2.geometry && t2.geometry.coordinates ? t2.geometry.coordinates : t2;
  }
  function g_(t2) {
    return ni2({ type: "LineString", coordinates: t2 });
  }
  function m_(t2) {
    return ni2({ type: "MultiLineString", coordinates: t2 });
  }
  function ql2(t2) {
    return ni2({ type: "Polygon", coordinates: t2 });
  }
  function Nl(t2) {
    return ni2({ type: "MultiPolygon", coordinates: t2 });
  }
  function zl(t2, e2) {
    let i = ri2(t2), r2 = ri2(e2), n2 = Al(i.coordinates, r2.coordinates);
    return n2.length === 0 ? null : n2.length === 1 ? ql2(n2[0]) : Nl(n2);
  }
  function Fl(t2, e2) {
    let i = ri2(t2), r2 = ri2(e2), n2 = Il(i.coordinates, r2.coordinates);
    return n2.length === 0 ? null : n2.length === 1 ? ql2(n2[0]) : Nl(n2);
  }
  function Vl(t2) {
    return Array.isArray(t2) ? 1 + Vl(t2[0]) : -1;
  }
  function Ul(t2) {
    t2 instanceof L.Polyline && (t2 = t2.toGeoJSON(15));
    let e2 = Gl(t2), i = Vl(e2), r2 = [];
    return i > 1 ? e2.forEach((n2) => {
      r2.push(g_(n2));
    }) : r2.push(t2), r2;
  }
  function jl2(t2) {
    let e2 = [];
    return t2.eachLayer((i) => {
      e2.push(Gl(i.toGeoJSON(15)));
    }), m_(e2);
  }
  X2.Cut = X2.Polygon.extend({ initialize(t2) {
    this._map = t2, this._shape = "Cut", this.toolbarButtonName = "cutPolygon";
  }, _finishShape() {
    if (this._editedLayers = [], !this.options.allowSelfIntersection && (this._handleSelfIntersection(true, this._layer.getLatLngs()[0]), this._doesSelfIntersect) || this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer()) return;
    let t2 = this._layer.getLatLngs();
    if (t2.length <= 2) return;
    let e2 = L.polygon(t2, this.options.pathOptions);
    e2._latlngInfos = this._layer._latlngInfo, this.cut(e2), this._cleanupSnapping(), this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1), delete this._tempSnapLayerIndex, this._editedLayers.forEach(({ layer: i, originalLayer: r2 }) => {
      this._fireCut(r2, i, r2), this._fireCut(this._map, i, r2), r2.pm._fireEdit();
    }), this._editedLayers = [], this.disable(), this.options.continueDrawing && this.enable();
  }, cut(t2) {
    let e2 = this._map._layers, i = t2._latlngInfos || [];
    Object.keys(e2).map((n2) => e2[n2]).filter((n2) => n2.pm).filter((n2) => !n2._pmTempLayer).filter((n2) => !L.PM.optIn && !n2.options.pmIgnore || L.PM.optIn && n2.options.pmIgnore === false).filter((n2) => n2 instanceof L.Polyline).filter((n2) => n2 !== t2).filter((n2) => n2.pm.options.allowCutting).filter((n2) => this.options.layersToCut && L.Util.isArray(this.options.layersToCut) && this.options.layersToCut.length > 0 ? this.options.layersToCut.indexOf(n2) > -1 : true).filter((n2) => !this._layerGroup.hasLayer(n2)).filter((n2) => {
      try {
        let s2 = !!pt(t2.toGeoJSON(15), n2.toGeoJSON(15)).features.length > 0;
        return s2 || n2 instanceof L.Polyline && !(n2 instanceof L.Polygon) ? s2 : !!zl(t2.toGeoJSON(15), n2.toGeoJSON(15));
      } catch {
        return n2 instanceof L.Polygon && console.error("You can't cut polygons with self-intersections"), false;
      }
    }).forEach((n2) => {
      let s2;
      if (n2 instanceof L.Polygon) {
        s2 = L.polygon(n2.getLatLngs());
        let u2 = s2.getLatLngs();
        i.forEach((f2) => {
          if (f2 && f2.snapInfo) {
            let { latlng: d } = f2, P2 = this._calcClosestLayer(d, [s2]);
            if (P2 && P2.segment && P2.distance < this.options.snapDistance) {
              let { segment: E2 } = P2;
              if (E2 && E2.length === 2) {
                let { indexPath: T2, parentPath: G2, newIndex: _ } = L.PM.Utils._getIndexFromSegment(u2, E2);
                (T2.length > 1 ? (0, Kl.default)(u2, G2) : u2).splice(_, 0, d);
              }
            }
          }
        });
      } else s2 = n2;
      let a = this._cutLayer(t2, s2), o = L.geoJSON(a, n2.options);
      o.getLayers().length === 1 && ([o] = o.getLayers()), this._setPane(o, "layerPane");
      let l2 = o.addTo(this._map.pm._getContainingLayer());
      if (l2.pm.enable(n2.pm.options), l2.pm.disable(), n2._pmTempLayer = true, t2._pmTempLayer = true, n2.remove(), n2.removeFrom(this._map.pm._getContainingLayer()), t2.remove(), t2.removeFrom(this._map.pm._getContainingLayer()), l2.getLayers && l2.getLayers().length === 0 && this._map.pm.removeLayer({ target: l2 }), l2 instanceof L.LayerGroup ? (l2.eachLayer((u2) => {
        this._addDrawnLayerProp(u2);
      }), this._addDrawnLayerProp(l2)) : this._addDrawnLayerProp(l2), this.options.layersToCut && L.Util.isArray(this.options.layersToCut) && this.options.layersToCut.length > 0) {
        let u2 = this.options.layersToCut.indexOf(n2);
        u2 > -1 && this.options.layersToCut.splice(u2, 1);
      }
      this._editedLayers.push({ layer: l2, originalLayer: n2 });
    });
  }, _cutLayer(t2, e2) {
    let i = L.geoJSON(), r2;
    if (e2 instanceof L.Polygon) r2 = Fl(e2.toGeoJSON(15), t2.toGeoJSON(15));
    else {
      let n2 = Ul(e2);
      n2.forEach((s2) => {
        let a = vl(s2, t2.toGeoJSON(15)), o;
        a && a.features.length > 0 ? o = L.geoJSON(a) : o = L.geoJSON(s2), o.getLayers().forEach((l2) => {
          Yi2(t2.toGeoJSON(15), l2.toGeoJSON(15)) || l2.addTo(i);
        });
      }), n2.length > 1 ? r2 = jl2(i) : r2 = i.toGeoJSON(15);
    }
    return r2;
  }, _change: L.Util.falseFn });
  X2.Text = X2.extend({ initialize(t2) {
    this._map = t2, this._shape = "Text", this.toolbarButtonName = "drawText";
  }, enable(t2) {
    L.Util.setOptions(this, t2), this._enabled = true, this._map.on("click", this._createMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true), this._hintMarker = L.marker(this._map.getCenter(), { interactive: false, zIndexOffset: 100, icon: L.divIcon({ className: "marker-icon cursor-marker" }) }), this._setPane(this._hintMarker, "vertexPane"), this._hintMarker._pmTempLayer = true, this._hintMarker.addTo(this._map), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, "visible"), this.options.tooltips && this._hintMarker.bindTooltip(V2("tooltips.placeText"), { permanent: true, offset: L.point(0, 10), direction: "bottom", opacity: 0.8 }).openTooltip(), this._layer = this._hintMarker, this._map.on("mousemove", this._syncHintMarker, this), this._map.getContainer().classList.add("geoman-draw-cursor"), this._fireDrawStart(), this._setGlobalDrawMode();
  }, disable() {
    var _a3;
    this._enabled && (this._enabled = false, this._map.off("click", this._createMarker, this), (_a3 = this._hintMarker) == null ? void 0 : _a3.remove(), this._map.getContainer().classList.remove("geoman-draw-cursor"), this._map.off("mousemove", this._syncHintMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false), this.options.snappable && this._cleanupSnapping(), this._fireDrawEnd(), this._setGlobalDrawMode());
  }, enabled() {
    return this._enabled;
  }, toggle(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, _syncHintMarker(t2) {
    if (this._hintMarker.setLatLng(t2.latlng), this.options.snappable) {
      let e2 = t2;
      e2.target = this._hintMarker, this._handleSnapping(e2);
    }
  }, _createMarker(t2) {
    var _a3, _b2, _c, _d;
    if (!t2.latlng || this.options.requireSnapToFinish && !this._hintMarker._snapped && !this._isFirstLayer()) return;
    this._hintMarker._snapped || this._hintMarker.setLatLng(t2.latlng);
    let e2 = this._hintMarker.getLatLng();
    if (this.textArea = this._createTextArea(), (_a3 = this.options.textOptions) == null ? void 0 : _a3.className) {
      let n2 = this.options.textOptions.className.split(" ");
      this.textArea.classList.add(...n2);
    }
    let i = this._createTextIcon(this.textArea), r2 = new L.Marker(e2, { textMarker: true, _textMarkerOverPM: true, icon: i });
    if (this._setPane(r2, "markerPane"), this._finishLayer(r2), r2.pm || (r2.options.draggable = false), r2.addTo(this._map.pm._getContainingLayer()), r2.pm) {
      r2.pm.textArea = this.textArea, L.setOptions(r2.pm, { removeIfEmpty: ((_b2 = this.options.textOptions) == null ? void 0 : _b2.removeIfEmpty) ?? true });
      let n2 = ((_c = this.options.textOptions) == null ? void 0 : _c.focusAfterDraw) ?? true;
      r2.pm._createTextMarker(n2), ((_d = this.options.textOptions) == null ? void 0 : _d.text) && r2.pm.setText(this.options.textOptions.text);
    }
    this._fireCreate(r2), this._cleanupSnapping(), this.disable(), this.options.continueDrawing && this.enable();
  }, _createTextArea() {
    let t2 = document.createElement("textarea");
    return t2.readOnly = true, t2.classList.add("pm-textarea", "pm-disabled"), t2;
  }, _createTextIcon(t2) {
    return L.divIcon({ className: "pm-text-marker", html: t2 });
  } });
  var __ = { enableLayerDrag() {
    if (!this.options.draggable || !this._layer._map) return;
    this.disable(), this._layerDragEnabled = true, this._map || (this._map = this._layer._map), (this._layer instanceof L.Marker || this._layer instanceof L.ImageOverlay) && L.DomEvent.on(this._getDOMElem(), "dragstart", this._stopDOMImageDrag), this._layer.dragging && this._layer.dragging.disable(), this._tempDragCoord = null, Rt(this._layer) instanceof L.Canvas ? (this._layer.on("mouseout", this.removeDraggingClass, this), this._layer.on("mouseover", this.addDraggingClass, this)) : this.addDraggingClass(), this._originalMapDragState = this._layer._map.dragging._enabled, this._safeToCacheDragState = true;
    let t2 = this._getDOMElem();
    t2 && (Rt(this._layer) instanceof L.Canvas ? (this._layer.on("touchstart mousedown", this._dragMixinOnMouseDown, this), this._map.pm._addTouchEvents(t2)) : L.DomEvent.on(t2, "touchstart mousedown", this._simulateMouseDownEvent, this)), this._fireDragEnable();
  }, disableLayerDrag() {
    this._layerDragEnabled = false, Rt(this._layer) instanceof L.Canvas ? (this._layer.off("mouseout", this.removeDraggingClass, this), this._layer.off("mouseover", this.addDraggingClass, this)) : this.removeDraggingClass(), this._originalMapDragState && this._dragging && this._map.dragging.enable(), this._safeToCacheDragState = false, this._layer.dragging && this._layer.dragging.disable();
    let t2 = this._getDOMElem();
    t2 && (Rt(this._layer) instanceof L.Canvas ? (this._layer.off("touchstart mousedown", this._dragMixinOnMouseDown, this), this._map.pm._removeTouchEvents(t2)) : L.DomEvent.off(t2, "touchstart mousedown", this._simulateMouseDownEvent, this)), this._layerDragged && this._fireUpdate(), this._layerDragged = false, this._fireDragDisable();
  }, dragging() {
    return this._dragging;
  }, layerDragEnabled() {
    return !!this._layerDragEnabled;
  }, _simulateMouseDownEvent(t2) {
    let e2 = t2.touches ? t2.touches[0] : t2, i = { originalEvent: e2, target: this._layer };
    return i.containerPoint = this._map.mouseEventToContainerPoint(e2), i.latlng = this._map.containerPointToLatLng(i.containerPoint), this._dragMixinOnMouseDown(i), false;
  }, _simulateMouseMoveEvent(t2) {
    let e2 = t2.touches ? t2.touches[0] : t2, i = { originalEvent: e2, target: this._layer };
    return i.containerPoint = this._map.mouseEventToContainerPoint(e2), i.latlng = this._map.containerPointToLatLng(i.containerPoint), this._dragMixinOnMouseMove(i), false;
  }, _simulateMouseUpEvent(t2) {
    let i = { originalEvent: t2.touches ? t2.touches[0] : t2, target: this._layer };
    return t2.type.indexOf("touch") === -1 && (i.containerPoint = this._map.mouseEventToContainerPoint(t2), i.latlng = this._map.containerPointToLatLng(i.containerPoint)), this._dragMixinOnMouseUp(i), false;
  }, _dragMixinOnMouseDown(t2) {
    if (t2.originalEvent.button > 0) return;
    this._overwriteEventIfItComesFromMarker(t2);
    let e2 = t2._fromLayerSync, i = this._syncLayers("_dragMixinOnMouseDown", t2);
    if (this._layer instanceof L.Marker && (this.options.snappable && !e2 && !i ? this._initSnappableMarkers() : this._disableSnapping()), this._layer instanceof L.CircleMarker) {
      let r2 = "resizeableCircleMarker";
      this._layer instanceof L.Circle && (r2 = "resizableCircle"), this.options.snappable && !e2 && !i ? this._layer.pm.options[r2] || this._initSnappableMarkersDrag() : this._layer.pm.options[r2] ? this._layer.pm._disableSnapping() : this._layer.pm._disableSnappingDrag();
    }
    this._safeToCacheDragState && (this._originalMapDragState = this._layer._map.dragging._enabled, this._safeToCacheDragState = false), this._tempDragCoord = t2.latlng, L.DomEvent.on(this._map.getContainer(), "touchend mouseup", this._simulateMouseUpEvent, this), L.DomEvent.on(this._map.getContainer(), "touchmove mousemove", this._simulateMouseMoveEvent, this);
  }, _dragMixinOnMouseMove(t2) {
    this._overwriteEventIfItComesFromMarker(t2);
    let e2 = this._getDOMElem();
    this._syncLayers("_dragMixinOnMouseMove", t2), this._dragging || (this._dragging = true, L.DomUtil.addClass(e2, "leaflet-pm-dragging"), this._layer instanceof L.Marker || this._layer.bringToFront(), this._originalMapDragState && this._map.dragging.disable(), this._fireDragStart()), this._tempDragCoord || (this._tempDragCoord = t2.latlng), this._onLayerDrag(t2), this._layer instanceof L.CircleMarker && this._layer.pm._updateHiddenPolyCircle();
  }, _dragMixinOnMouseUp(t2) {
    let e2 = this._getDOMElem();
    return this._syncLayers("_dragMixinOnMouseUp", t2), this._originalMapDragState && this._map.dragging.enable(), this._safeToCacheDragState = true, L.DomEvent.off(this._map.getContainer(), "touchmove mousemove", this._simulateMouseMoveEvent, this), L.DomEvent.off(this._map.getContainer(), "touchend mouseup", this._simulateMouseUpEvent, this), this._dragging ? (this._layer instanceof L.CircleMarker && this._layer.pm._updateHiddenPolyCircle(), this._layerDragged = true, window.setTimeout(() => {
      this._dragging = false, e2 && L.DomUtil.removeClass(e2, "leaflet-pm-dragging"), this._fireDragEnd(), this._fireEdit(), this._layerEdited = true;
    }, 10), true) : false;
  }, _onLayerDrag(t2) {
    let { latlng: e2 } = t2, i = { lat: e2.lat - this._tempDragCoord.lat, lng: e2.lng - this._tempDragCoord.lng }, r2 = (n2) => n2.map((s2) => {
      if (Array.isArray(s2)) return r2(s2);
      let a = { lat: s2.lat + i.lat, lng: s2.lng + i.lng };
      return (s2.alt || s2.alt === 0) && (a.alt = s2.alt), a;
    });
    if (this._layer instanceof L.Circle && this._layer.options.resizableCircle || this._layer instanceof L.CircleMarker && this._layer.options.resizeableCircleMarker) {
      let n2 = r2([this._layer.getLatLng()]);
      this._layer.setLatLng(n2[0]), this._fireChange(this._layer.getLatLng(), "Edit");
    } else if (this._layer instanceof L.CircleMarker || this._layer instanceof L.Marker) {
      let n2 = this._layer.getLatLng();
      this._layer._snapped && (n2 = this._layer._orgLatLng);
      let s2 = r2([n2]);
      this._layer.setLatLng(s2[0]), this._fireChange(this._layer.getLatLng(), "Edit");
    } else if (this._layer instanceof L.ImageOverlay) {
      let n2 = r2([this._layer.getBounds().getNorthWest(), this._layer.getBounds().getSouthEast()]);
      this._layer.setBounds(n2), this._fireChange(this._layer.getBounds(), "Edit");
    } else {
      let n2 = r2(this._layer.getLatLngs());
      this._layer.setLatLngs(n2), this._fireChange(this._layer.getLatLngs(), "Edit");
    }
    this._tempDragCoord = e2, t2.layer = this._layer, this._fireDrag(t2);
  }, addDraggingClass() {
    let t2 = this._getDOMElem();
    t2 && L.DomUtil.addClass(t2, "leaflet-pm-draggable");
  }, removeDraggingClass() {
    let t2 = this._getDOMElem();
    t2 && L.DomUtil.removeClass(t2, "leaflet-pm-draggable");
  }, _getDOMElem() {
    let t2 = null;
    return this._layer._path ? t2 = this._layer._path : this._layer._renderer && this._layer._renderer._container ? t2 = this._layer._renderer._container : this._layer._image ? t2 = this._layer._image : this._layer._icon && (t2 = this._layer._icon), t2;
  }, _overwriteEventIfItComesFromMarker(t2) {
    t2.target.getLatLng && (!t2.target._radius || t2.target._radius <= 10) && (t2.containerPoint = this._map.mouseEventToContainerPoint(t2.originalEvent), t2.latlng = this._map.containerPointToLatLng(t2.containerPoint));
  }, _syncLayers(t2, e2) {
    if (this.enabled()) return false;
    if (!e2._fromLayerSync && this._layer === e2.target && this.options.syncLayersOnDrag) {
      e2._fromLayerSync = true;
      let i = [];
      if (L.Util.isArray(this.options.syncLayersOnDrag)) i = this.options.syncLayersOnDrag, this.options.syncLayersOnDrag.forEach((r2) => {
        r2 instanceof L.LayerGroup && (i = i.concat(r2.pm.getLayers(true)));
      });
      else if (this.options.syncLayersOnDrag === true && this._parentLayerGroup) for (let r2 in this._parentLayerGroup) {
        let n2 = this._parentLayerGroup[r2];
        n2.pm && (i = n2.pm.getLayers(true));
      }
      return L.Util.isArray(i) && i.length > 0 && (i = i.filter((r2) => !!r2.pm).filter((r2) => !!r2.pm.options.draggable), i.forEach((r2) => {
        r2 !== this._layer && r2.pm[t2] && (r2._snapped = false, r2.pm[t2](e2));
      })), i.length > 0;
    }
    return false;
  }, _stopDOMImageDrag(t2) {
    return t2.preventDefault(), false;
  } }, Hl = __;
  var Xl = xt(Le2());
  function y_(t2, e2, i, r2) {
    return i.unproject(e2.transform(i.project(t2, r2)), r2);
  }
  function ar(t2, e2, i) {
    let r2 = i.getMaxZoom();
    if (r2 === 1 / 0 && (r2 = i.getZoom()), L.Util.isArray(t2)) {
      let n2 = [];
      return t2.forEach((s2) => {
        n2.push(ar(s2, e2, i));
      }), n2;
    }
    return t2 instanceof L.LatLng ? y_(t2, e2, i, r2) : null;
  }
  function It(t2, e2) {
    e2 instanceof L.Layer && (e2 = e2.getLatLng());
    let i = t2.getMaxZoom();
    return i === 1 / 0 && (i = t2.getZoom()), t2.project(e2, i);
  }
  function Re2(t2, e2) {
    let i = t2.getMaxZoom();
    return i === 1 / 0 && (i = t2.getZoom()), t2.unproject(e2, i);
  }
  var L_ = { _onRotateStart(t2) {
    this._preventRenderingMarkers(true), this._rotationOriginLatLng = this._getRotationCenter().clone(), this._rotationOriginPoint = It(this._map, this._rotationOriginLatLng), this._rotationStartPoint = It(this._map, t2.target.getLatLng()), this._initialRotateLatLng = vt(this._layer), this._startAngle = this.getAngle();
    let e2 = vt(this._rotationLayer, this._rotationLayer.pm._rotateOrgLatLng);
    this._fireRotationStart(this._rotationLayer, e2), this._fireRotationStart(this._map, e2);
  }, _onRotate(t2) {
    let e2 = It(this._map, t2.target.getLatLng()), i = this._rotationStartPoint, r2 = this._rotationOriginPoint, n2 = Math.atan2(e2.y - r2.y, e2.x - r2.x) - Math.atan2(i.y - r2.y, i.x - r2.x);
    this._layer.setLatLngs(this._rotateLayer(n2, this._initialRotateLatLng, this._rotationOriginLatLng, L.PM.Matrix.init(), this._map));
    let s2 = this;
    function a(f2, d = [], P2 = -1) {
      if (P2 > -1 && d.push(P2), L.Util.isArray(f2[0])) f2.forEach((E2, T2) => a(E2, d.slice(), T2));
      else {
        let E2 = (0, Xl.default)(s2._markers, d);
        f2.forEach((T2, G2) => {
          E2[G2].setLatLng(T2);
        });
      }
    }
    a(this._layer.getLatLngs());
    let o = vt(this._rotationLayer);
    this._rotationLayer.setLatLngs(this._rotateLayer(n2, this._rotationLayer.pm._rotateOrgLatLng, this._rotationOriginLatLng, L.PM.Matrix.init(), this._map));
    let l2 = n2 * 180 / Math.PI;
    l2 = l2 < 0 ? l2 + 360 : l2;
    let u2 = l2 + this._startAngle;
    this._setAngle(u2), this._rotationLayer.pm._setAngle(u2), this._fireRotation(this._rotationLayer, l2, o), this._fireRotation(this._map, l2, o), this._rotationLayer.pm._fireChange(this._rotationLayer.getLatLngs(), "Rotation");
  }, _onRotateEnd() {
    let t2 = this._startAngle;
    delete this._rotationOriginLatLng, delete this._rotationOriginPoint, delete this._rotationStartPoint, delete this._initialRotateLatLng, delete this._startAngle;
    let e2 = vt(this._rotationLayer, this._rotationLayer.pm._rotateOrgLatLng);
    this._rotationLayer.pm._rotateOrgLatLng = vt(this._rotationLayer), this._fireRotationEnd(this._rotationLayer, t2, e2), this._fireRotationEnd(this._map, t2, e2), this._rotationLayer.pm._fireEdit(this._rotationLayer, "Rotation"), this._preventRenderingMarkers(false), this._layerRotated = true;
  }, _rotateLayer(t2, e2, i, r2, n2) {
    let s2 = It(n2, i);
    return this._matrix = r2.clone().rotate(t2, s2).flip(), ar(e2, this._matrix, n2);
  }, _setAngle(t2) {
    t2 = t2 < 0 ? t2 + 360 : t2, this._angle = t2 % 360;
  }, _getRotationCenter() {
    if (this._rotationCenter) return this._rotationCenter;
    let t2 = L.polygon(this._layer.getLatLngs(), { stroke: false, fill: false, pmIgnore: true }).addTo(this._layer._map), e2 = t2.getCenter();
    return t2.removeFrom(this._layer._map), e2;
  }, enableRotate() {
    if (!this.options.allowRotation) {
      this.disableRotate();
      return;
    }
    this.rotateEnabled() && this.disableRotate(), this._layer instanceof L.Rectangle && this._angle === void 0 && this.setInitAngle(ke2(this._layer._map, this._layer.getLatLngs()[0][0], this._layer.getLatLngs()[0][1]) || 0);
    let t2 = { fill: false, stroke: false, pmIgnore: false, snapIgnore: true };
    this._rotatePoly = L.polygon(this._layer.getLatLngs(), t2), this._rotatePoly._pmTempLayer = true, this._rotatePoly.addTo(this._layer._map), this._rotatePoly.pm._setAngle(this.getAngle()), this._rotatePoly.pm.setRotationCenter(this.getRotationCenter()), this._rotatePoly.pm.setOptions(this._layer._map.pm.getGlobalOptions()), this._rotatePoly.pm.setOptions({ rotate: true, snappable: false, hideMiddleMarkers: true }), this._rotatePoly.pm._rotationLayer = this._layer, this._rotatePoly.pm.enable(), this._rotateOrgLatLng = vt(this._layer), this._rotateEnabled = true, this._layer.on("remove", this.disableRotate, this), this._fireRotationEnable(this._layer), this._fireRotationEnable(this._layer._map);
  }, disableRotate() {
    this.rotateEnabled() && (this._rotatePoly.pm._layerRotated && this._fireUpdate(), this._rotatePoly.pm._layerRotated = false, this._rotatePoly.pm.disable(), this._rotatePoly.remove(), this._rotatePoly.pm.setOptions({ rotate: false }), this._rotatePoly = void 0, this._rotateOrgLatLng = void 0, this._layer.off("remove", this.disableRotate, this), this._rotateEnabled = false, this._fireRotationDisable(this._layer), this._fireRotationDisable(this._layer._map));
  }, rotateEnabled() {
    return !!this._rotateEnabled;
  }, rotateLayer(t2) {
    let e2 = this.getAngle(), i = this._layer.getLatLngs(), r2 = t2 * (Math.PI / 180);
    this._layer.setLatLngs(this._rotateLayer(r2, this._layer.getLatLngs(), this._getRotationCenter(), L.PM.Matrix.init(), this._layer._map)), this._rotateOrgLatLng = L.polygon(this._layer.getLatLngs()).getLatLngs(), this._setAngle(this.getAngle() + t2), this.rotateEnabled() && this._rotatePoly && this._rotatePoly.pm.enabled() && (this._rotatePoly.setLatLngs(this._rotateLayer(r2, this._rotatePoly.getLatLngs(), this._getRotationCenter(), L.PM.Matrix.init(), this._rotatePoly._map)), this._rotatePoly.pm._initMarkers());
    let n2 = this.getAngle() - e2;
    n2 = n2 < 0 ? n2 + 360 : n2, this._startAngle = e2, this._fireRotation(this._layer, n2, i, this._layer), this._fireRotation(this._map || this._layer._map, n2, i, this._layer), delete this._startAngle, this._fireChange(this._layer.getLatLngs(), "Rotation");
  }, rotateLayerToAngle(t2) {
    let e2 = t2 - this.getAngle();
    this.rotateLayer(e2);
  }, getAngle() {
    return this._angle || 0;
  }, setInitAngle(t2) {
    this._setAngle(t2);
  }, getRotationCenter() {
    return this._getRotationCenter();
  }, setRotationCenter(t2) {
    this._rotationCenter = t2, this._rotatePoly && this._rotatePoly.pm.setRotationCenter(t2);
  } }, Yl = L_;
  var b_ = L.Class.extend({ includes: [Hl, Fe2, Yl, Tt], options: { snappable: true, snapDistance: 20, allowSelfIntersection: true, allowSelfIntersectionEdit: false, preventMarkerRemoval: false, removeLayerBelowMinVertexCount: true, limitMarkersToCount: -1, hideMiddleMarkers: false, snapSegment: true, syncLayersOnDrag: false, draggable: true, allowEditing: true, allowRemoval: true, allowCutting: true, allowRotation: true, addVertexOn: "click", removeVertexOn: "contextmenu", removeVertexValidation: void 0, addVertexValidation: void 0, moveVertexValidation: void 0, resizeableCircleMarker: false, resizableCircle: true }, setOptions(t2) {
    L.Util.setOptions(this, t2);
  }, getOptions() {
    return this.options;
  }, applyOptions() {
  }, isPolygon() {
    return this._layer instanceof L.Polygon;
  }, getShape() {
    return this._shape;
  }, _setPane(t2, e2) {
    e2 === "layerPane" ? t2.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.layerPane || "overlayPane" : e2 === "vertexPane" ? t2.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.vertexPane || "markerPane" : e2 === "markerPane" && (t2.options.pane = this._map.pm.globalOptions.panes && this._map.pm.globalOptions.panes.markerPane || "markerPane");
  }, remove() {
    (this._map || this._layer._map).pm.removeLayer({ target: this._layer });
  }, _vertexValidation(t2, e2) {
    let i = e2.target, r2 = { layer: this._layer, marker: i, event: e2 }, n2 = "";
    return t2 === "move" ? n2 = "moveVertexValidation" : t2 === "add" ? n2 = "addVertexValidation" : t2 === "remove" && (n2 = "removeVertexValidation"), this.options[n2] && typeof this.options[n2] == "function" && !this.options[n2](r2) ? (t2 === "move" && (i._cancelDragEventChain = i.getLatLng()), false) : (i._cancelDragEventChain = null, true);
  }, _vertexValidationDrag(t2) {
    return t2._cancelDragEventChain ? (t2._latlng = t2._cancelDragEventChain, t2.update(), false) : true;
  }, _vertexValidationDragEnd(t2) {
    return t2._cancelDragEventChain ? (t2._cancelDragEventChain = null, false) : true;
  } }), H2 = b_;
  H2.LayerGroup = L.Class.extend({ initialize(t2) {
    this._layerGroup = t2, this._layers = this.getLayers(), this._getMap(), this._layers.forEach((r2) => this._initLayer(r2));
    let e2 = (r2) => {
      if (r2.layer._pmTempLayer) return;
      this._layers = this.getLayers();
      let n2 = this._layers.filter((s2) => !s2.pm._parentLayerGroup || !(this._layerGroup._leaflet_id in s2.pm._parentLayerGroup));
      n2.forEach((s2) => {
        this._initLayer(s2);
      }), n2.length > 0 && this._getMap() && this._getMap().pm.globalEditModeEnabled() && this.enabled() && this.enable(this.getOptions());
    };
    this._layerGroup.on("layeradd", L.Util.throttle(e2, 100, this), this), this._layerGroup.on("layerremove", (r2) => {
      this._removeLayerFromGroup(r2.target);
    }, this);
    let i = (r2) => {
      r2.target._pmTempLayer || (this._layers = this.getLayers());
    };
    this._layerGroup.on("layerremove", L.Util.throttle(i, 100, this), this);
  }, enable(t2, e2 = []) {
    e2.length === 0 && (this._layers = this.getLayers()), this._options = t2, this._layers.forEach((i) => {
      i instanceof L.LayerGroup ? e2.indexOf(i._leaflet_id) === -1 && (e2.push(i._leaflet_id), i.pm.enable(t2, e2)) : i.pm.enable(t2);
    });
  }, disable(t2 = []) {
    t2.length === 0 && (this._layers = this.getLayers()), this._layers.forEach((e2) => {
      e2 instanceof L.LayerGroup ? t2.indexOf(e2._leaflet_id) === -1 && (t2.push(e2._leaflet_id), e2.pm.disable(t2)) : e2.pm.disable();
    });
  }, enabled(t2 = []) {
    return t2.length === 0 && (this._layers = this.getLayers()), !!this._layers.find((i) => i instanceof L.LayerGroup ? t2.indexOf(i._leaflet_id) === -1 ? (t2.push(i._leaflet_id), i.pm.enabled(t2)) : false : i.pm.enabled());
  }, toggleEdit(t2, e2 = []) {
    e2.length === 0 && (this._layers = this.getLayers()), this._options = t2, this._layers.forEach((i) => {
      i instanceof L.LayerGroup ? e2.indexOf(i._leaflet_id) === -1 && (e2.push(i._leaflet_id), i.pm.toggleEdit(t2, e2)) : i.pm.toggleEdit(t2);
    });
  }, _initLayer(t2) {
    let e2 = L.Util.stamp(this._layerGroup);
    t2.pm._parentLayerGroup || (t2.pm._parentLayerGroup = {}), t2.pm._parentLayerGroup[e2] = this._layerGroup;
  }, _removeLayerFromGroup(t2) {
    if (t2.pm && t2.pm._layerGroup) {
      let e2 = L.Util.stamp(this._layerGroup);
      delete t2.pm._layerGroup[e2];
    }
  }, dragging() {
    return this._layers = this.getLayers(), this._layers ? !!this._layers.find((e2) => e2.pm.dragging()) : false;
  }, getOptions() {
    return this.options;
  }, _getMap() {
    var _a3;
    return this._map || ((_a3 = this._layers.find((t2) => !!t2._map)) == null ? void 0 : _a3._map) || null;
  }, getLayers(t2 = false, e2 = true, i = true, r2 = []) {
    let n2 = [];
    return t2 ? this._layerGroup.getLayers().forEach((s2) => {
      n2.push(s2), s2 instanceof L.LayerGroup && r2.indexOf(s2._leaflet_id) === -1 && (r2.push(s2._leaflet_id), n2 = n2.concat(s2.pm.getLayers(true, true, true, r2)));
    }) : n2 = this._layerGroup.getLayers(), i && (n2 = n2.filter((s2) => !(s2 instanceof L.LayerGroup))), e2 && (n2 = n2.filter((s2) => !!s2.pm), n2 = n2.filter((s2) => !s2._pmTempLayer), n2 = n2.filter((s2) => !L.PM.optIn && !s2.options.pmIgnore || L.PM.optIn && s2.options.pmIgnore === false)), n2;
  }, setOptions(t2, e2 = []) {
    e2.length === 0 && (this._layers = this.getLayers()), this.options = t2, this._layers.forEach((i) => {
      i.pm && (i instanceof L.LayerGroup ? e2.indexOf(i._leaflet_id) === -1 && (e2.push(i._leaflet_id), i.pm.setOptions(t2, e2)) : i.pm.setOptions(t2));
    });
  } });
  H2.Marker = H2.extend({ _shape: "Marker", initialize(t2) {
    this._layer = t2, this._enabled = false, this._layer.on("dragend", this._onDragEnd, this);
  }, enable(t2 = { draggable: true }) {
    if (L.Util.setOptions(this, t2), !this.options.allowEditing || !this._layer._map) {
      this.disable();
      return;
    }
    this._map = this._layer._map, this.enabled() && this.disable(), this.applyOptions(), this._layer.on("remove", this.disable, this), this._enabled = true, this._fireEnable();
  }, disable() {
    this.enabled() && (this.disableLayerDrag(), this._layer.off("remove", this.disable, this), this._layer.off("contextmenu", this._removeMarker, this), this._layerEdited && this._fireUpdate(), this._layerEdited = false, this._fireDisable(), this._enabled = false);
  }, enabled() {
    return this._enabled;
  }, toggleEdit(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, applyOptions() {
    this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping(), this.options.draggable ? this.enableLayerDrag() : this.disableLayerDrag(), this.options.preventMarkerRemoval || this._layer.on("contextmenu", this._removeMarker, this);
  }, _removeMarker(t2) {
    let e2 = t2.target;
    e2.remove(), this._fireRemove(e2), this._fireRemove(this._map, e2);
  }, _onDragEnd() {
    this._fireEdit(), this._layerEdited = true;
  }, _initSnappableMarkers() {
    let t2 = this._layer;
    this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === void 0 ? true : this.options.snapSegment, t2.off("pm:drag", this._handleSnapping, this), t2.on("pm:drag", this._handleSnapping, this), t2.off("pm:dragend", this._cleanupSnapping, this), t2.on("pm:dragend", this._cleanupSnapping, this), t2.off("pm:dragstart", this._unsnap, this), t2.on("pm:dragstart", this._unsnap, this);
  }, _disableSnapping() {
    let t2 = this._layer;
    t2.off("pm:drag", this._handleSnapping, this), t2.off("pm:dragend", this._cleanupSnapping, this), t2.off("pm:dragstart", this._unsnap, this);
  } });
  var St = xt(Le2());
  var v_ = { filterMarkerGroup() {
    this.markerCache = [], this.createCache(), this._layer.on("pm:edit", this.createCache, this), this.applyLimitFilters({}), this.throttledApplyLimitFilters || (this.throttledApplyLimitFilters = L.Util.throttle(this.applyLimitFilters, 100, this)), this._layer.on("pm:disable", this._removeMarkerLimitEvents, this), this._layer.on("remove", this._removeMarkerLimitEvents, this), this.options.limitMarkersToCount > -1 && (this._layer.on("pm:vertexremoved", this._initMarkers, this), this._map.on("mousemove", this.throttledApplyLimitFilters, this));
  }, _removeMarkerLimitEvents() {
    this._map.off("mousemove", this.throttledApplyLimitFilters, this), this._layer.off("pm:edit", this.createCache, this), this._layer.off("pm:disable", this._removeMarkerLimitEvents, this), this._layer.off("pm:vertexremoved", this._initMarkers, this);
  }, createCache() {
    let t2 = [...this._markerGroup.getLayers(), ...this.markerCache];
    this.markerCache = t2.filter((e2, i, r2) => r2.indexOf(e2) === i);
  }, _removeFromCache(t2) {
    let e2 = this.markerCache.indexOf(t2);
    e2 > -1 && this.markerCache.splice(e2, 1);
  }, renderLimits(t2) {
    this.markerCache.forEach((e2) => {
      t2.includes(e2) ? this._markerGroup.addLayer(e2) : this._markerGroup.removeLayer(e2);
    });
  }, applyLimitFilters({ latlng: t2 = { lat: 0, lng: 0 } }) {
    if (this._preventRenderMarkers) return;
    let i = [...this._filterClosestMarkers(t2)];
    this.renderLimits(i);
  }, _filterClosestMarkers(t2) {
    let e2 = [...this.markerCache], i = this.options.limitMarkersToCount;
    return i === -1 ? e2 : (e2.sort((n2, s2) => {
      let a = n2._latlng.distanceTo(t2), o = s2._latlng.distanceTo(t2);
      return a - o;
    }), e2.filter((n2, s2) => i > -1 ? s2 < i : true));
  }, _preventRenderMarkers: false, _preventRenderingMarkers(t2) {
    this._preventRenderMarkers = !!t2;
  } }, Jl = v_;
  H2.Line = H2.extend({ includes: [Jl], _shape: "Line", initialize(t2) {
    this._layer = t2, this._enabled = false;
  }, enable(t2) {
    if (L.Util.setOptions(this, t2), this._map = this._layer._map, !!this._map) {
      if (!this.options.allowEditing) {
        this.disable();
        return;
      }
      this.enabled() && this.disable(), this._enabled = true, this._initMarkers(), this.applyOptions(), this._layer.on("remove", this.disable, this), this.options.allowSelfIntersection || this._layer.on("pm:vertexremoved", this._handleSelfIntersectionOnVertexRemoval, this), this.options.allowSelfIntersection ? this.cachedColor = void 0 : (this._layer.options.color !== "#f00000ff" ? (this.cachedColor = this._layer.options.color, this.isRed = false) : this.isRed = true, this._handleLayerStyle()), this._fireEnable();
    }
  }, disable() {
    if (!this.enabled() || this._dragging) return;
    this._enabled = false, this._markerGroup.clearLayers(), this._markerGroup.removeFrom(this._map), this._layer.off("remove", this.disable, this), this.options.allowSelfIntersection || this._layer.off("pm:vertexremoved", this._handleSelfIntersectionOnVertexRemoval, this);
    let t2 = this._layer._path ? this._layer._path : this._layer._renderer._container;
    L.DomUtil.removeClass(t2, "leaflet-pm-draggable"), this._layerEdited && this._fireUpdate(), this._layerEdited = false, this._fireDisable();
  }, enabled() {
    return this._enabled;
  }, toggleEdit(t2) {
    return this.enabled() ? this.disable() : this.enable(t2), this.enabled();
  }, applyOptions() {
    this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping();
  }, _initMarkers() {
    let t2 = this._map, e2 = this._layer.getLatLngs();
    this._markerGroup && this._markerGroup.clearLayers(), this._markerGroup = new L.FeatureGroup(), this._markerGroup._pmTempLayer = true;
    let i = (r2) => {
      if (Array.isArray(r2[0])) return r2.map(i, this);
      let n2 = r2.map(this._createMarker, this);
      return this.options.hideMiddleMarkers !== true && r2.map((s2, a) => {
        let o = this.isPolygon() ? (a + 1) % r2.length : a + 1;
        return this._createMiddleMarker(n2[a], n2[o]);
      }), n2;
    };
    this._markers = i(e2), this.filterMarkerGroup(), t2.addLayer(this._markerGroup);
  }, _createMarker(t2) {
    let e2 = new L.Marker(t2, { draggable: true, icon: L.divIcon({ className: "marker-icon" }) });
    return this._setPane(e2, "vertexPane"), e2._pmTempLayer = true, this.options.rotate ? (e2.on("dragstart", this._onRotateStart, this), e2.on("drag", this._onRotate, this), e2.on("dragend", this._onRotateEnd, this)) : (e2.on("click", this._onVertexClick, this), e2.on("dragstart", this._onMarkerDragStart, this), e2.on("move", this._onMarkerDrag, this), e2.on("dragend", this._onMarkerDragEnd, this), this.options.preventMarkerRemoval || e2.on(this.options.removeVertexOn, this._removeMarker, this)), this._markerGroup.addLayer(e2), e2;
  }, _createMiddleMarker(t2, e2) {
    if (!t2 || !e2) return false;
    let i = L.PM.Utils.calcMiddleLatLng(this._map, t2.getLatLng(), e2.getLatLng()), r2 = this._createMarker(i), n2 = L.divIcon({ className: "marker-icon marker-icon-middle" });
    return r2.setIcon(n2), r2.leftM = t2, r2.rightM = e2, t2._middleMarkerNext = r2, e2._middleMarkerPrev = r2, r2.on(this.options.addVertexOn, this._onMiddleMarkerClick, this), r2.on("movestart", this._onMiddleMarkerMoveStart, this), r2;
  }, _onMiddleMarkerClick(t2) {
    let e2 = t2.target;
    if (!this._vertexValidation("add", t2)) return;
    let i = L.divIcon({ className: "marker-icon" });
    e2.setIcon(i), this._addMarker(e2, e2.leftM, e2.rightM);
  }, _onMiddleMarkerMoveStart(t2) {
    let e2 = t2.target;
    if (e2.on("moveend", this._onMiddleMarkerMoveEnd, this), !this._vertexValidation("add", t2)) {
      e2.on("move", this._onMiddleMarkerMovePrevent, this);
      return;
    }
    e2._dragging = true, this._addMarker(e2, e2.leftM, e2.rightM);
  }, _onMiddleMarkerMovePrevent(t2) {
    let e2 = t2.target;
    this._vertexValidationDrag(e2);
  }, _onMiddleMarkerMoveEnd(t2) {
    let e2 = t2.target;
    if (e2.off("move", this._onMiddleMarkerMovePrevent, this), e2.off("moveend", this._onMiddleMarkerMoveEnd, this), !this._vertexValidationDragEnd(e2)) return;
    let i = L.divIcon({ className: "marker-icon" });
    e2.setIcon(i), setTimeout(() => {
      delete e2._dragging;
    }, 100);
  }, _addMarker(t2, e2, i) {
    t2.off("movestart", this._onMiddleMarkerMoveStart, this), t2.off(this.options.addVertexOn, this._onMiddleMarkerClick, this);
    let r2 = t2.getLatLng(), n2 = this._layer._latlngs;
    delete t2.leftM, delete t2.rightM;
    let { indexPath: s2, index: a, parentPath: o } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2), l2 = s2.length > 1 ? (0, St.default)(n2, o) : n2, u2 = s2.length > 1 ? (0, St.default)(this._markers, o) : this._markers;
    l2.splice(a + 1, 0, r2), u2.splice(a + 1, 0, t2), this._layer.setLatLngs(n2), this.options.hideMiddleMarkers !== true && (this._createMiddleMarker(e2, t2), this._createMiddleMarker(t2, i)), this._fireEdit(), this._layerEdited = true, this._fireChange(this._layer.getLatLngs(), "Edit"), this._fireVertexAdded(t2, L.PM.Utils.findDeepMarkerIndex(this._markers, t2).indexPath, r2), this.options.snappable && this._initSnappableMarkers();
  }, hasSelfIntersection() {
    return zt(this._layer.toGeoJSON(15)).features.length > 0;
  }, _handleSelfIntersectionOnVertexRemoval() {
    this._handleLayerStyle(true) && (this._layer.setLatLngs(this._coordsBeforeEdit), this._coordsBeforeEdit = null, this._initMarkers());
  }, _handleLayerStyle(t2) {
    let e2 = this._layer, i, r2;
    if (this.options.allowSelfIntersection ? i = false : (r2 = zt(this._layer.toGeoJSON(15)), i = r2.features.length > 0), i) {
      if (!this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this._updateDisabledMarkerStyle(this._markers, true), this.isRed) return i;
      t2 ? this._flashLayer() : (e2.setStyle({ color: "#f00000ff" }), this.isRed = true), this._fireIntersect(r2);
    } else e2.setStyle({ color: this.cachedColor }), this.isRed = false, !this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this._updateDisabledMarkerStyle(this._markers, false);
    return i;
  }, _flashLayer() {
    this.cachedColor || (this.cachedColor = this._layer.options.color), this._layer.setStyle({ color: "#f00000ff" }), this.isRed = true, window.setTimeout(() => {
      this._layer.setStyle({ color: this.cachedColor }), this.isRed = false;
    }, 200);
  }, _updateDisabledMarkerStyle(t2, e2) {
    t2.forEach((i) => {
      Array.isArray(i) ? this._updateDisabledMarkerStyle(i, e2) : i._icon && (e2 && !this._checkMarkerAllowedToDrag(i) ? L.DomUtil.addClass(i._icon, "vertexmarker-disabled") : L.DomUtil.removeClass(i._icon, "vertexmarker-disabled"));
    });
  }, _removeMarker(t2) {
    let e2 = t2.target;
    if (!this._vertexValidation("remove", t2)) return;
    this.options.allowSelfIntersection || (this._coordsBeforeEdit = vt(this._layer, this._layer.getLatLngs()));
    let i = this._layer.getLatLngs(), { indexPath: r2, index: n2, parentPath: s2 } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    if (!r2) return;
    let a = r2.length > 1 ? (0, St.default)(i, s2) : i, o = r2.length > 1 ? (0, St.default)(this._markers, s2) : this._markers;
    if (!this.options.removeLayerBelowMinVertexCount && (a.length <= 2 || this.isPolygon() && a.length <= 3)) {
      this._flashLayer();
      return;
    }
    a.splice(n2, 1), this._layer.setLatLngs(i), this.isPolygon() && a.length <= 2 && a.splice(0, a.length);
    let l2 = false;
    if (a.length <= 1 && (a.splice(0, a.length), s2.length > 1 && r2.length > 1 && (i = ve2(i)), this._layer.setLatLngs(i), this._initMarkers(), l2 = true), be2(i) || this._layer.remove(), i = ve2(i), this._layer.setLatLngs(i), this._markers = ve2(this._markers), !l2 && (o = r2.length > 1 ? (0, St.default)(this._markers, s2) : this._markers, e2._middleMarkerPrev && (this._markerGroup.removeLayer(e2._middleMarkerPrev), this._removeFromCache(e2._middleMarkerPrev)), e2._middleMarkerNext && (this._markerGroup.removeLayer(e2._middleMarkerNext), this._removeFromCache(e2._middleMarkerNext)), this._markerGroup.removeLayer(e2), this._removeFromCache(e2), o)) {
      let u2, f2;
      if (this.isPolygon() ? (u2 = (n2 + 1) % o.length, f2 = (n2 + (o.length - 1)) % o.length) : (f2 = n2 - 1 < 0 ? void 0 : n2 - 1, u2 = n2 + 1 >= o.length ? void 0 : n2 + 1), u2 !== f2) {
        let d = o[f2], P2 = o[u2];
        this.options.hideMiddleMarkers !== true && this._createMiddleMarker(d, P2);
      }
      o.splice(n2, 1);
    }
    this._fireEdit(), this._layerEdited = true, this._fireVertexRemoved(e2, r2), this._fireChange(this._layer.getLatLngs(), "Edit");
  }, updatePolygonCoordsFromMarkerDrag(t2) {
    let e2 = this._layer.getLatLngs(), i = t2.getLatLng(), { indexPath: r2, index: n2, parentPath: s2 } = L.PM.Utils.findDeepMarkerIndex(this._markers, t2);
    (r2.length > 1 ? (0, St.default)(e2, s2) : e2).splice(n2, 1, i), this._layer.setLatLngs(e2);
  }, _getNeighborMarkers(t2) {
    let { indexPath: e2, index: i, parentPath: r2 } = L.PM.Utils.findDeepMarkerIndex(this._markers, t2), n2 = e2.length > 1 ? (0, St.default)(this._markers, r2) : this._markers, s2 = (i + 1) % n2.length, a = (i + (n2.length - 1)) % n2.length, o = n2[a], l2 = n2[s2];
    return { prevMarker: o, nextMarker: l2 };
  }, _checkMarkerAllowedToDrag(t2) {
    let { prevMarker: e2, nextMarker: i } = this._getNeighborMarkers(t2), r2 = L.polyline([e2.getLatLng(), t2.getLatLng()]), n2 = L.polyline([t2.getLatLng(), i.getLatLng()]), s2 = pt(this._layer.toGeoJSON(15), r2.toGeoJSON(15)).features.length, a = pt(this._layer.toGeoJSON(15), n2.toGeoJSON(15)).features.length;
    return t2.getLatLng() === this._markers[0][0].getLatLng() ? a += 1 : t2.getLatLng() === this._markers[0][this._markers[0].length - 1].getLatLng() && (s2 += 1), !(s2 <= 2 && a <= 2);
  }, _onMarkerDragStart(t2) {
    let e2 = t2.target;
    if (this.cachedColor || (this.cachedColor = this._layer.options.color), !this._vertexValidation("move", t2)) return;
    let { indexPath: i } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    this._fireMarkerDragStart(t2, i), this.options.allowSelfIntersection || (this._coordsBeforeEdit = vt(this._layer, this._layer.getLatLngs())), !this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this.hasSelfIntersection() ? this._markerAllowedToDrag = this._checkMarkerAllowedToDrag(e2) : this._markerAllowedToDrag = null;
  }, _onMarkerDrag(t2) {
    let e2 = t2.target;
    if (!this._vertexValidationDrag(e2)) return;
    let { indexPath: i, index: r2, parentPath: n2 } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    if (!i) return;
    if (!this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this.hasSelfIntersection() && this._markerAllowedToDrag === false) {
      this._layer.setLatLngs(this._coordsBeforeEdit), this._initMarkers(), this._handleLayerStyle();
      return;
    }
    this.updatePolygonCoordsFromMarkerDrag(e2);
    let s2 = i.length > 1 ? (0, St.default)(this._markers, n2) : this._markers, a = (r2 + 1) % s2.length, o = (r2 + (s2.length - 1)) % s2.length, l2 = e2.getLatLng(), u2 = s2[o].getLatLng(), f2 = s2[a].getLatLng();
    if (e2._middleMarkerNext) {
      let d = L.PM.Utils.calcMiddleLatLng(this._map, l2, f2);
      e2._middleMarkerNext.setLatLng(d);
    }
    if (e2._middleMarkerPrev) {
      let d = L.PM.Utils.calcMiddleLatLng(this._map, l2, u2);
      e2._middleMarkerPrev.setLatLng(d);
    }
    this.options.allowSelfIntersection || this._handleLayerStyle(), this._fireMarkerDrag(t2, i), this._fireChange(this._layer.getLatLngs(), "Edit");
  }, _onMarkerDragEnd(t2) {
    let e2 = t2.target;
    if (!this._vertexValidationDragEnd(e2)) return;
    let { indexPath: i } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2), r2 = this.hasSelfIntersection();
    r2 && this.options.allowSelfIntersectionEdit && this._markerAllowedToDrag && (r2 = false);
    let n2 = !this.options.allowSelfIntersection && r2;
    if (this._fireMarkerDragEnd(t2, i, n2), n2) {
      this._layer.setLatLngs(this._coordsBeforeEdit), this._coordsBeforeEdit = null, this._initMarkers(), this.options.snappable && this._initSnappableMarkers(), this._handleLayerStyle(), this._fireLayerReset(t2, i);
      return;
    }
    !this.options.allowSelfIntersection && this.options.allowSelfIntersectionEdit && this._handleLayerStyle(), this._fireEdit(), this._layerEdited = true, this._fireChange(this._layer.getLatLngs(), "Edit");
  }, _onVertexClick(t2) {
    let e2 = t2.target;
    if (e2._dragging) return;
    let { indexPath: i } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    this._fireVertexClick(t2, i);
  } });
  H2.Polygon = H2.Line.extend({ _shape: "Polygon", _checkMarkerAllowedToDrag(t2) {
    let { prevMarker: e2, nextMarker: i } = this._getNeighborMarkers(t2), r2 = L.polyline([e2.getLatLng(), t2.getLatLng()]), n2 = L.polyline([t2.getLatLng(), i.getLatLng()]), s2 = pt(this._layer.toGeoJSON(15), r2.toGeoJSON(15)).features.length, a = pt(this._layer.toGeoJSON(15), n2.toGeoJSON(15)).features.length;
    return !(s2 <= 2 && a <= 2);
  } });
  H2.Rectangle = H2.Polygon.extend({ _shape: "Rectangle", _initMarkers() {
    let t2 = this._map, e2 = this._findCorners();
    this._markerGroup && this._markerGroup.clearLayers(), this._markerGroup = new L.FeatureGroup(), this._markerGroup._pmTempLayer = true, t2.addLayer(this._markerGroup), this._markers = [], this._markers[0] = e2.map(this._createMarker, this), [this._cornerMarkers] = this._markers, this._layer.getLatLngs()[0].forEach((i, r2) => {
      let n2 = this._cornerMarkers.find((s2) => s2._index === r2);
      n2 && n2.setLatLng(i);
    });
  }, applyOptions() {
    this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping(), this._addMarkerEvents();
  }, _createMarker(t2, e2) {
    let i = new L.Marker(t2, { draggable: true, icon: L.divIcon({ className: "marker-icon" }) });
    return this._setPane(i, "vertexPane"), i._origLatLng = t2, i._index = e2, i._pmTempLayer = true, i.on("click", this._onVertexClick, this), this._markerGroup.addLayer(i), i;
  }, _addMarkerEvents() {
    this._markers[0].forEach((t2) => {
      t2.on("dragstart", this._onMarkerDragStart, this), t2.on("drag", this._onMarkerDrag, this), t2.on("dragend", this._onMarkerDragEnd, this), this.options.preventMarkerRemoval || t2.on("contextmenu", this._removeMarker, this);
    });
  }, _removeMarker() {
    return null;
  }, _onMarkerDragStart(t2) {
    if (!this._vertexValidation("move", t2)) return;
    let e2 = t2.target, i = this._cornerMarkers;
    e2._oppositeCornerLatLng = i.find((n2) => n2._index === (e2._index + 2) % 4).getLatLng(), e2._snapped = false;
    let { indexPath: r2 } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    this._fireMarkerDragStart(t2, r2);
  }, _onMarkerDrag(t2) {
    let e2 = t2.target;
    if (!this._vertexValidationDrag(e2) || e2._index === void 0) return;
    this._adjustRectangleForMarkerMove(e2);
    let { indexPath: i } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    this._fireMarkerDrag(t2, i), this._fireChange(this._layer.getLatLngs(), "Edit");
  }, _onMarkerDragEnd(t2) {
    let e2 = t2.target;
    if (!this._vertexValidationDragEnd(e2)) return;
    this._cornerMarkers.forEach((r2) => {
      delete r2._oppositeCornerLatLng;
    });
    let { indexPath: i } = L.PM.Utils.findDeepMarkerIndex(this._markers, e2);
    this._fireMarkerDragEnd(t2, i), this._fireEdit(), this._layerEdited = true, this._fireChange(this._layer.getLatLngs(), "Edit");
  }, _adjustRectangleForMarkerMove(t2) {
    L.extend(t2._origLatLng, t2._latlng);
    let e2 = L.PM.Utils._getRotatedRectangle(t2.getLatLng(), t2._oppositeCornerLatLng, this.getAngle(), this._map);
    this._layer.setLatLngs(e2), this._adjustAllMarkers(), this._layer.redraw();
  }, _adjustAllMarkers() {
    let t2 = this._layer.getLatLngs()[0];
    t2 && t2.length !== 4 && t2.length > 0 ? (t2.forEach((i, r2) => {
      this._cornerMarkers[r2].setLatLng(i);
    }), this._cornerMarkers.slice(t2.length).forEach((i) => {
      i.setLatLng(t2[0]);
    })) : !t2 || !t2.length ? console.error("The layer has no LatLngs") : this._cornerMarkers.forEach((e2) => {
      e2.setLatLng(t2[e2._index]);
    });
  }, _findCorners() {
    this._angle === void 0 && this.setInitAngle(ke2(this._map, this._layer.getLatLngs()[0][0], this._layer.getLatLngs()[0][1]) || 0);
    let t2 = this._layer.getLatLngs()[0];
    return L.PM.Utils._getRotatedRectangle(t2[0], t2[2], this.getAngle(), this._map || this);
  } });
  H2.CircleMarker = H2.extend({ _shape: "CircleMarker", initialize(t2) {
    this._layer = t2, this._enabled = false, this._minRadiusOption = "minRadiusCircleMarker", this._maxRadiusOption = "maxRadiusCircleMarker", this._editableOption = "resizeableCircleMarker", this._updateHiddenPolyCircle();
  }, enable(t2 = { draggable: true, snappable: true }) {
    if (L.Util.setOptions(this, t2), this.options.editable && (this.options.resizeableCircleMarker = this.options.editable, delete this.options.editable), !this.options.allowEditing || !this._layer._map) {
      this.disable();
      return;
    }
    this._map = this._layer._map, this.enabled() && this.disable(), this.applyOptions(), this._layer.on("remove", this.disable, this), this._enabled = true, this._extendingEnable(), this._updateHiddenPolyCircle(), this._fireEnable();
  }, _extendingEnable() {
    this._layer.on("pm:dragstart", this._onDragStart, this), this._layer.on("pm:drag", this._onMarkerDrag, this), this._layer.on("pm:dragend", this._onMarkerDragEnd, this);
  }, disable() {
    this.dragging() || (this._map || (this._map = this._layer._map), this._map && this.enabled() && (this.layerDragEnabled() && this.disableLayerDrag(), this.options[this._editableOption] ? (this._helperLayers && this._helperLayers.clearLayers(), this._map.off("move", this._syncMarkers, this), this._outerMarker.off("drag", this._handleOuterMarkerSnapping, this)) : this._map.off("move", this._updateHiddenPolyCircle, this), this._extendingDisable(), this._layer.off("remove", this.disable, this), this._layerEdited && this._fireUpdate(), this._layerEdited = false, this._fireDisable(), this._enabled = false));
  }, _extendingDisable() {
    this._layer.off("contextmenu", this._removeMarker, this);
  }, enabled() {
    return this._enabled;
  }, toggleEdit(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, applyOptions() {
    this.options[this._editableOption] ? (this._initMarkers(), this._map.on("move", this._syncMarkers, this), this.options.snappable ? (this._initSnappableMarkers(), this._outerMarker.on("drag", this._handleOuterMarkerSnapping, this), this._outerMarker.on("move", this._syncHintLine, this), this._outerMarker.on("move", this._syncCircleRadius, this), this._centerMarker.on("move", this._moveCircle, this)) : this._disableSnapping()) : (this.options.draggable && this.enableLayerDrag(), this._map.on("move", this._updateHiddenPolyCircle, this), this.options.snappable ? this._initSnappableMarkersDrag() : this._disableSnappingDrag()), this._extendingApplyOptions();
  }, _extendingApplyOptions() {
    this.options.preventMarkerRemoval || this._layer.on("contextmenu", this._removeMarker, this);
  }, _initMarkers() {
    let t2 = this._map;
    this._helperLayers && this._helperLayers.clearLayers(), this._helperLayers = new L.FeatureGroup(), this._helperLayers._pmTempLayer = true, this._helperLayers.addTo(t2);
    let e2 = this._layer.getLatLng(), i = this._layer._radius, r2 = this._getLatLngOnCircle(e2, i);
    this._centerMarker = this._createCenterMarker(e2), this._outerMarker = this._createOuterMarker(r2), this._markers = [this._centerMarker, this._outerMarker], this._createHintLine(this._centerMarker, this._outerMarker);
  }, _getLatLngOnCircle(t2, e2) {
    let i = this._map.project(t2), r2 = L.point(i.x + e2, i.y);
    return this._map.unproject(r2);
  }, _createHintLine(t2, e2) {
    let i = t2.getLatLng(), r2 = e2.getLatLng();
    this._hintline = L.polyline([i, r2], this.options.hintlineStyle), this._setPane(this._hintline, "layerPane"), this._hintline._pmTempLayer = true, this._helperLayers.addLayer(this._hintline);
  }, _createCenterMarker(t2) {
    let e2 = this._createMarker(t2);
    return this.options.draggable ? L.DomUtil.addClass(e2._icon, "leaflet-pm-draggable") : e2.dragging.disable(), e2;
  }, _createOuterMarker(t2) {
    let e2 = this._createMarker(t2);
    return e2.on("drag", this._resizeCircle, this), e2;
  }, _createMarker(t2) {
    let e2 = new L.Marker(t2, { draggable: true, icon: L.divIcon({ className: "marker-icon" }) });
    return this._setPane(e2, "vertexPane"), e2._origLatLng = t2, e2._pmTempLayer = true, e2.on("dragstart", this._onMarkerDragStart, this), e2.on("drag", this._onMarkerDrag, this), e2.on("dragend", this._onMarkerDragEnd, this), e2.on("click", this._onVertexClick, this), this._helperLayers.addLayer(e2), e2;
  }, _moveCircle(t2) {
    if (t2.target._cancelDragEventChain) return;
    let i = this._centerMarker.getLatLng();
    this._layer.setLatLng(i);
    let r2 = this._layer._radius, n2 = this._getLatLngOnCircle(i, r2);
    this._outerMarker._latlng = n2, this._outerMarker.update(), this._syncHintLine(), this._updateHiddenPolyCircle(), this._fireCenterPlaced("Edit"), this._fireChange(this._layer.getLatLng(), "Edit");
  }, _syncMarkers() {
    let t2 = this._layer.getLatLng(), e2 = this._layer._radius, i = this._getLatLngOnCircle(t2, e2);
    this._outerMarker.setLatLng(i), this._centerMarker.setLatLng(t2), this._syncHintLine(), this._updateHiddenPolyCircle();
  }, _resizeCircle() {
    this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker()), this._syncHintLine(), this._syncCircleRadius();
  }, _syncCircleRadius() {
    let t2 = this._centerMarker.getLatLng(), e2 = this._outerMarker.getLatLng(), i = this._distanceCalculation(t2, e2);
    this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? this._layer.setRadius(this.options[this._minRadiusOption]) : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] ? this._layer.setRadius(this.options[this._maxRadiusOption]) : this._layer.setRadius(i), this._updateHiddenPolyCircle(), this._fireChange(this._layer.getLatLng(), "Edit");
  }, _syncHintLine() {
    let t2 = this._centerMarker.getLatLng(), e2 = this._outerMarker.getLatLng();
    this._hintline.setLatLngs([t2, e2]);
  }, _removeMarker() {
    this.options[this._editableOption] && this.disable(), this._layer.remove(), this._fireRemove(this._layer), this._fireRemove(this._map, this._layer);
  }, _onDragStart() {
    this._map.pm.Draw.CircleMarker._layerIsDragging = true;
  }, _onMarkerDragStart(t2) {
    this._vertexValidation("move", t2) && this._fireMarkerDragStart(t2);
  }, _onMarkerDrag(t2) {
    let e2 = t2.target;
    e2 instanceof L.Marker && !this._vertexValidationDrag(e2) || this._fireMarkerDrag(t2);
  }, _onMarkerDragEnd(t2) {
    this._extedingMarkerDragEnd();
    let e2 = t2.target;
    this._vertexValidationDragEnd(e2) && (this.options[this._editableOption] && (this._fireEdit(), this._layerEdited = true), this._fireMarkerDragEnd(t2));
  }, _extedingMarkerDragEnd() {
    this._map.pm.Draw.CircleMarker._layerIsDragging = false;
  }, _initSnappableMarkersDrag() {
    let t2 = this._layer;
    this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === void 0 ? true : this.options.snapSegment, t2.off("pm:drag", this._handleSnapping, this), t2.on("pm:drag", this._handleSnapping, this), t2.off("pm:dragend", this._cleanupSnapping, this), t2.on("pm:dragend", this._cleanupSnapping, this), t2.off("pm:dragstart", this._unsnap, this), t2.on("pm:dragstart", this._unsnap, this);
  }, _disableSnappingDrag() {
    let t2 = this._layer;
    t2.off("pm:drag", this._handleSnapping, this), t2.off("pm:dragend", this._cleanupSnapping, this), t2.off("pm:dragstart", this._unsnap, this);
  }, _updateHiddenPolyCircle() {
    let t2 = this._layer._map || this._map;
    if (t2) {
      let e2 = L.PM.Utils.pxRadiusToMeterRadius(this._layer.getRadius(), t2, this._layer.getLatLng()), i = L.circle(this._layer.getLatLng(), this._layer.options);
      i.setRadius(e2);
      let r2 = t2 && t2.pm._isCRSSimple();
      this._hiddenPolyCircle ? this._hiddenPolyCircle.setLatLngs(L.PM.Utils.circleToPolygon(i, 200, !r2).getLatLngs()) : this._hiddenPolyCircle = L.PM.Utils.circleToPolygon(i, 200, !r2), this._hiddenPolyCircle._parentCopy || (this._hiddenPolyCircle._parentCopy = this._layer);
    }
  }, _getNewDestinationOfOuterMarker() {
    let t2 = this._centerMarker.getLatLng(), e2 = this._outerMarker.getLatLng(), i = this._distanceCalculation(t2, e2);
    return this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? e2 = te2(this._map, t2, e2, this._getMinDistanceInMeter(t2)) : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] && (e2 = te2(this._map, t2, e2, this._getMaxDistanceInMeter(t2))), e2;
  }, _handleOuterMarkerSnapping() {
    if (this._outerMarker._snapped) {
      let t2 = this._centerMarker.getLatLng(), e2 = this._outerMarker.getLatLng(), i = this._distanceCalculation(t2, e2);
      this.options[this._minRadiusOption] && i < this.options[this._minRadiusOption] ? this._outerMarker.setLatLng(this._outerMarker._orgLatLng) : this.options[this._maxRadiusOption] && i > this.options[this._maxRadiusOption] && this._outerMarker.setLatLng(this._outerMarker._orgLatLng);
    }
    this._outerMarker.setLatLng(this._getNewDestinationOfOuterMarker());
  }, _distanceCalculation(t2, e2) {
    return this._map.project(t2).distanceTo(this._map.project(e2));
  }, _getMinDistanceInMeter(t2) {
    return L.PM.Utils.pxRadiusToMeterRadius(this.options[this._minRadiusOption], this._map, t2);
  }, _getMaxDistanceInMeter(t2) {
    return L.PM.Utils.pxRadiusToMeterRadius(this.options[this._maxRadiusOption], this._map, t2);
  }, _onVertexClick(t2) {
    t2.target._dragging || this._fireVertexClick(t2, void 0);
  } });
  H2.Circle = H2.CircleMarker.extend({ _shape: "Circle", initialize(t2) {
    this._layer = t2, this._enabled = false, this._minRadiusOption = "minRadiusCircle", this._maxRadiusOption = "maxRadiusCircle", this._editableOption = "resizableCircle", this._updateHiddenPolyCircle();
  }, enable(t2) {
    L.PM.Edit.CircleMarker.prototype.enable.call(this, t2 || {});
  }, _extendingEnable() {
  }, _extendingDisable() {
    this._layer.off("remove", this.disable, this);
    let t2 = this._layer._path ? this._layer._path : this._layer._renderer._container;
    L.DomUtil.removeClass(t2, "leaflet-pm-draggable");
  }, _extendingApplyOptions() {
  }, _syncMarkers() {
  }, _removeMarker() {
  }, _onDragStart() {
  }, _extedingMarkerDragEnd() {
  }, _updateHiddenPolyCircle() {
    let t2 = this._map && this._map.pm._isCRSSimple();
    this._hiddenPolyCircle ? this._hiddenPolyCircle.setLatLngs(L.PM.Utils.circleToPolygon(this._layer, 200, !t2).getLatLngs()) : this._hiddenPolyCircle = L.PM.Utils.circleToPolygon(this._layer, 200, !t2), this._hiddenPolyCircle._parentCopy || (this._hiddenPolyCircle._parentCopy = this._layer);
  }, _distanceCalculation(t2, e2) {
    return this._map.distance(t2, e2);
  }, _getMinDistanceInMeter() {
    return this.options[this._minRadiusOption];
  }, _getMaxDistanceInMeter() {
    return this.options[this._maxRadiusOption];
  }, _onVertexClick(t2) {
    t2.target._dragging || this._fireVertexClick(t2, void 0);
  } });
  H2.ImageOverlay = H2.extend({ _shape: "ImageOverlay", initialize(t2) {
    this._layer = t2, this._enabled = false;
  }, toggleEdit(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, enabled() {
    return this._enabled;
  }, enable(t2 = { draggable: true, snappable: true }) {
    if (L.Util.setOptions(this, t2), this._map = this._layer._map, !!this._map) {
      if (!this.options.allowEditing) {
        this.disable();
        return;
      }
      this.enabled() || this.disable(), this.enableLayerDrag(), this._layer.on("remove", this.disable, this), this._enabled = true, this._otherSnapLayers = this._findCorners(), this._fireEnable();
    }
  }, disable() {
    this._dragging || (this._map || (this._map = this._layer._map), this.disableLayerDrag(), this._layer.off("remove", this.disable, this), this.enabled() || (this._layerEdited && this._fireUpdate(), this._layerEdited = false, this._fireDisable()), this._enabled = false);
  }, _findCorners() {
    let t2 = this._layer.getBounds(), e2 = t2.getNorthWest(), i = t2.getNorthEast(), r2 = t2.getSouthEast(), n2 = t2.getSouthWest();
    return [e2, i, r2, n2];
  } });
  H2.Text = H2.extend({ _shape: "Text", initialize(t2) {
    this._layer = t2, this._enabled = false;
  }, enable(t2) {
    if (L.Util.setOptions(this, t2), !!this.textArea) {
      if (!this.options.allowEditing || !this._layer._map) {
        this.disable();
        return;
      }
      this._map = this._layer._map, this.enabled() && this.disable(), this.applyOptions(), this._safeToCacheDragState = true, this._focusChange(), this.textArea.readOnly = false, this.textArea.classList.remove("pm-disabled"), this._layer.on("remove", this.disable, this), L.DomEvent.on(this.textArea, "input", this._autoResize, this), L.DomEvent.on(this.textArea, "focus", this._focusChange, this), L.DomEvent.on(this.textArea, "blur", this._focusChange, this), this._layer.on("dblclick", L.DomEvent.stop), L.DomEvent.off(this.textArea, "mousedown", this._preventTextSelection), this._enabled = true, this._fireEnable();
    }
  }, disable() {
    if (!this.enabled()) return;
    this._layer.off("remove", this.disable, this), L.DomEvent.off(this.textArea, "input", this._autoResize, this), L.DomEvent.off(this.textArea, "focus", this._focusChange, this), L.DomEvent.off(this.textArea, "blur", this._focusChange, this), L.DomEvent.off(document, "click", this._documentClick, this), this._focusChange(), this.textArea.readOnly = true, this.textArea.classList.add("pm-disabled");
    let t2 = document.activeElement;
    this.textArea.focus(), this.textArea.selectionStart = 0, this.textArea.selectionEnd = 0, L.DomEvent.on(this.textArea, "mousedown", this._preventTextSelection), t2.focus(), this._disableOnBlurActive = false, this._layerEdited && this._fireUpdate(), this._layerEdited = false, this._fireDisable(), this._enabled = false;
  }, enabled() {
    return this._enabled;
  }, toggleEdit(t2) {
    this.enabled() ? this.disable() : this.enable(t2);
  }, applyOptions() {
    this.options.snappable ? this._initSnappableMarkers() : this._disableSnapping();
  }, _initSnappableMarkers() {
    let t2 = this._layer;
    this.options.snapDistance = this.options.snapDistance || 30, this.options.snapSegment = this.options.snapSegment === void 0 ? true : this.options.snapSegment, t2.off("pm:drag", this._handleSnapping, this), t2.on("pm:drag", this._handleSnapping, this), t2.off("pm:dragend", this._cleanupSnapping, this), t2.on("pm:dragend", this._cleanupSnapping, this), t2.off("pm:dragstart", this._unsnap, this), t2.on("pm:dragstart", this._unsnap, this);
  }, _disableSnapping() {
    let t2 = this._layer;
    t2.off("pm:drag", this._handleSnapping, this), t2.off("pm:dragend", this._cleanupSnapping, this), t2.off("pm:dragstart", this._unsnap, this);
  }, _autoResize() {
    this.textArea.style.height = "1px", this.textArea.style.width = "1px";
    let t2 = this.textArea.scrollHeight > 21 ? this.textArea.scrollHeight : 21, e2 = this.textArea.scrollWidth > 16 ? this.textArea.scrollWidth : 16;
    this.textArea.style.height = `${t2}px`, this.textArea.style.width = `${e2}px`, this._layer.options.text = this.getText(), this._fireTextChange(this.getText());
  }, _disableOnBlur() {
    this._disableOnBlurActive = true, setTimeout(() => {
      this.enabled() && L.DomEvent.on(document, "click", this._documentClick, this);
    }, 100);
  }, _documentClick(t2) {
    t2.target !== this.textArea && (this.disable(), !this.getText() && this.options.removeIfEmpty && this.remove());
  }, _focusChange(t2 = {}) {
    let e2 = this._hasFocus;
    this._hasFocus = t2.type === "focus", !e2 != !this._hasFocus && (this._hasFocus ? (this._applyFocus(), this._focusText = this.getText(), this._fireTextFocus()) : (this._removeFocus(), this._fireTextBlur(), this._focusText !== this.getText() && (this._fireEdit(), this._layerEdited = true)));
  }, _applyFocus() {
    this.textArea.classList.add("pm-hasfocus"), this._map.dragging && (this._safeToCacheDragState && (this._originalMapDragState = this._map.dragging._enabled, this._safeToCacheDragState = false), this._map.dragging.disable());
  }, _removeFocus() {
    this._map.dragging && (this._originalMapDragState && this._map.dragging.enable(), this._safeToCacheDragState = true), this.textArea.classList.remove("pm-hasfocus");
  }, focus() {
    if (!this.enabled()) throw new TypeError("Layer is not enabled");
    this.textArea.focus();
  }, blur() {
    if (!this.enabled()) throw new TypeError("Layer is not enabled");
    this.textArea.blur(), this._disableOnBlurActive && this.disable();
  }, hasFocus() {
    return this._hasFocus;
  }, getElement() {
    return this.textArea;
  }, setText(t2) {
    this.textArea.value = t2, this._autoResize();
  }, getText() {
    return this.textArea.value;
  }, _initTextMarker() {
    if (this.textArea = L.PM.Draw.Text.prototype._createTextArea.call(this), this.options.className) {
      let e2 = this.options.className.split(" ");
      this.textArea.classList.add(...e2);
    }
    let t2 = L.PM.Draw.Text.prototype._createTextIcon.call(this, this.textArea);
    this._layer.setIcon(t2), this._layer.once("add", this._createTextMarker, this);
  }, _createTextMarker(t2 = false) {
    this._layer.off("add", this._createTextMarker, this), this._layer.getElement().tabIndex = -1, this.textArea.wrap = "off", this.textArea.style.overflow = "hidden", this.textArea.style.height = L.DomUtil.getStyle(this.textArea, "font-size"), this.textArea.style.width = "1px", this._layer.options.text && this.setText(this._layer.options.text), this._autoResize(), t2 === true && (this.enable(), this.focus(), this._disableOnBlur());
  }, _preventTextSelection(t2) {
    t2.preventDefault();
  } });
  var or = function(e2, i, r2, n2, s2, a) {
    this._matrix = [e2, i, r2, n2, s2, a];
  };
  or.init = () => new L.PM.Matrix(1, 0, 0, 1, 0, 0);
  or.prototype = { transform(t2) {
    return this._transform(t2.clone());
  }, _transform(t2) {
    let e2 = this._matrix, { x: i, y: r2 } = t2;
    return t2.x = e2[0] * i + e2[1] * r2 + e2[4], t2.y = e2[2] * i + e2[3] * r2 + e2[5], t2;
  }, untransform(t2) {
    let e2 = this._matrix;
    return new L.Point((t2.x / e2[0] - e2[4]) / e2[0], (t2.y / e2[2] - e2[5]) / e2[2]);
  }, clone() {
    let t2 = this._matrix;
    return new L.PM.Matrix(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
  }, translate(t2) {
    if (t2 === void 0) return new L.Point(this._matrix[4], this._matrix[5]);
    let e2, i;
    return typeof t2 == "number" ? (e2 = t2, i = t2) : (e2 = t2.x, i = t2.y), this._add(1, 0, 0, 1, e2, i);
  }, scale(t2, e2) {
    if (t2 === void 0) return new L.Point(this._matrix[0], this._matrix[3]);
    let i, r2;
    return e2 = e2 || L.point(0, 0), typeof t2 == "number" ? (i = t2, r2 = t2) : (i = t2.x, r2 = t2.y), this._add(i, 0, 0, r2, e2.x, e2.y)._add(1, 0, 0, 1, -e2.x, -e2.y);
  }, rotate(t2, e2) {
    let i = Math.cos(t2), r2 = Math.sin(t2);
    return e2 = e2 || new L.Point(0, 0), this._add(i, r2, -r2, i, e2.x, e2.y)._add(1, 0, 0, 1, -e2.x, -e2.y);
  }, flip() {
    return this._matrix[1] *= -1, this._matrix[2] *= -1, this;
  }, _add(t2, e2, i, r2, n2, s2) {
    let a = [[], [], []], o = this._matrix, l2 = [[o[0], o[2], o[4]], [o[1], o[3], o[5]], [0, 0, 1]], u2 = [[t2, i, n2], [e2, r2, s2], [0, 0, 1]], f2;
    t2 && t2 instanceof L.PM.Matrix && (o = t2._matrix, u2 = [[o[0], o[2], o[4]], [o[1], o[3], o[5]], [0, 0, 1]]);
    for (let d = 0; d < 3; d += 1) for (let P2 = 0; P2 < 3; P2 += 1) {
      f2 = 0;
      for (let E2 = 0; E2 < 3; E2 += 1) f2 += l2[d][E2] * u2[E2][P2];
      a[d][P2] = f2;
    }
    return this._matrix = [a[0][0], a[1][0], a[0][1], a[1][1], a[0][2], a[1][2]], this;
  } };
  var $l = or;
  var k_ = { calcMiddleLatLng(t2, e2, i) {
    let r2 = t2.project(e2), n2 = t2.project(i);
    return t2.unproject(r2._add(n2)._divideBy(2));
  }, findLayers(t2) {
    let e2 = [];
    return t2.eachLayer((i) => {
      (i instanceof L.Polyline || i instanceof L.Marker || i instanceof L.Circle || i instanceof L.CircleMarker || i instanceof L.ImageOverlay) && e2.push(i);
    }), e2 = e2.filter((i) => !!i.pm), e2 = e2.filter((i) => !i._pmTempLayer), e2 = e2.filter((i) => !L.PM.optIn && !i.options.pmIgnore || L.PM.optIn && i.options.pmIgnore === false), e2;
  }, circleToPolygon(t2, e2 = 60, i = true) {
    let r2 = t2.getLatLng(), n2 = t2.getRadius(), s2 = Ci2(r2, n2, e2, 0, i), a = [];
    for (let o = 0; o < s2.length; o += 1) {
      let l2 = [s2[o].lat, s2[o].lng];
      a.push(l2);
    }
    return L.polygon(a, t2.options);
  }, disablePopup(t2) {
    t2.getPopup() && (t2._tempPopupCopy = t2.getPopup(), t2.unbindPopup());
  }, enablePopup(t2) {
    t2._tempPopupCopy && (t2.bindPopup(t2._tempPopupCopy), delete t2._tempPopupCopy);
  }, _fireEvent(t2, e2, i, r2 = false) {
    t2.fire(e2, i, r2);
    let { groups: n2 } = this.getAllParentGroups(t2);
    n2.forEach((s2) => {
      s2.fire(e2, i, r2);
    });
  }, getAllParentGroups(t2) {
    let e2 = [], i = [], r2 = (n2) => {
      for (let s2 in n2._eventParents) if (e2.indexOf(s2) === -1) {
        e2.push(s2);
        let a = n2._eventParents[s2];
        i.push(a), r2(a);
      }
    };
    return !t2._pmLastGroupFetch || !t2._pmLastGroupFetch.time || (/* @__PURE__ */ new Date()).getTime() - t2._pmLastGroupFetch.time > 1e3 ? (r2(t2), t2._pmLastGroupFetch = { time: (/* @__PURE__ */ new Date()).getTime(), groups: i, groupIds: e2 }, { groupIds: e2, groups: i }) : { groups: t2._pmLastGroupFetch.groups, groupIds: t2._pmLastGroupFetch.groupIds };
  }, createGeodesicPolygon: Ci2, getTranslation: V2, findDeepCoordIndex(t2, e2, i = true) {
    let r2, n2 = (a) => (o, l2) => {
      let u2 = a.concat(l2);
      if (i) {
        if (o.lat && o.lat === e2.lat && o.lng === e2.lng) return r2 = u2, true;
      } else if (o.lat && L.latLng(o).equals(e2)) return r2 = u2, true;
      return Array.isArray(o) && o.some(n2(u2));
    };
    t2.some(n2([]));
    let s2 = {};
    return r2 && (s2 = { indexPath: r2, index: r2[r2.length - 1], parentPath: r2.slice(0, r2.length - 1) }), s2;
  }, findDeepMarkerIndex(t2, e2) {
    let i, r2 = (s2) => (a, o) => {
      let l2 = s2.concat(o);
      return a._leaflet_id === e2._leaflet_id ? (i = l2, true) : Array.isArray(a) && a.some(r2(l2));
    };
    t2.some(r2([]));
    let n2 = {};
    return i && (n2 = { indexPath: i, index: i[i.length - 1], parentPath: i.slice(0, i.length - 1) }), n2;
  }, _getIndexFromSegment(t2, e2) {
    if (e2 && e2.length === 2) {
      let i = this.findDeepCoordIndex(t2, e2[0]), r2 = this.findDeepCoordIndex(t2, e2[1]), n2 = Math.max(i.index, r2.index);
      return (i.index === 0 || r2.index === 0) && n2 !== 1 && (n2 += 1), { indexA: i, indexB: r2, newIndex: n2, indexPath: i.indexPath, parentPath: i.parentPath };
    }
    return null;
  }, _getRotatedRectangle(t2, e2, i, r2) {
    let n2 = It(r2, t2), s2 = It(r2, e2), a = i * Math.PI / 180, o = Math.cos(a), l2 = Math.sin(a), u2 = (s2.x - n2.x) * o + (s2.y - n2.y) * l2, f2 = (s2.y - n2.y) * o - (s2.x - n2.x) * l2, d = u2 * o + n2.x, P2 = u2 * l2 + n2.y, E2 = -f2 * l2 + n2.x, T2 = f2 * o + n2.y, G2 = Re2(r2, n2), _ = Re2(r2, { x: d, y: P2 }), x2 = Re2(r2, s2), b = Re2(r2, { x: E2, y: T2 });
    return [G2, _, x2, b];
  }, pxRadiusToMeterRadius(t2, e2, i) {
    let r2 = e2.project(i), n2 = L.point(r2.x + t2, r2.y);
    return e2.distance(e2.unproject(n2), i);
  } }, Zl = k_;
  L.PM = L.PM || { version: hr.version, Map: Ko, Toolbar: Xo, Draw: X2, Edit: H2, Utils: Zl, Matrix: $l, activeLang: "en", optIn: false, initialize(t2) {
    this.addInitHooks(t2);
  }, setOptIn(t2) {
    this.optIn = !!t2;
  }, addInitHooks() {
    function t2() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Map(this)) : this.options.pmIgnore || (this.pm = new L.PM.Map(this)), this.pm && this.pm.setGlobalOptions({});
    }
    L.Map.addInitHook(t2);
    function e2() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.LayerGroup(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.LayerGroup(this));
    }
    L.LayerGroup.addInitHook(e2);
    function i() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.options.textMarker ? (this.pm = new L.PM.Edit.Text(this), this.options._textMarkerOverPM || this.pm._initTextMarker(), delete this.options._textMarkerOverPM) : this.pm = new L.PM.Edit.Marker(this)) : this.options.pmIgnore || (this.options.textMarker ? (this.pm = new L.PM.Edit.Text(this), this.options._textMarkerOverPM || this.pm._initTextMarker(), delete this.options._textMarkerOverPM) : this.pm = new L.PM.Edit.Marker(this));
    }
    L.Marker.addInitHook(i);
    function r2() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.CircleMarker(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.CircleMarker(this));
    }
    L.CircleMarker.addInitHook(r2);
    function n2() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.Line(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Line(this));
    }
    L.Polyline.addInitHook(n2);
    function s2() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.Polygon(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Polygon(this));
    }
    L.Polygon.addInitHook(s2);
    function a() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.Rectangle(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Rectangle(this));
    }
    L.Rectangle.addInitHook(a);
    function o() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.Circle(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.Circle(this));
    }
    L.Circle.addInitHook(o);
    function l2() {
      this.pm = void 0, L.PM.optIn ? this.options.pmIgnore === false && (this.pm = new L.PM.Edit.ImageOverlay(this)) : this.options.pmIgnore || (this.pm = new L.PM.Edit.ImageOverlay(this));
    }
    L.ImageOverlay.addInitHook(l2);
  }, reInitLayer(t2) {
    t2 instanceof L.LayerGroup && t2.eachLayer((e2) => {
      this.reInitLayer(e2);
    }), t2.pm || L.PM.optIn && t2.options.pmIgnore !== false || t2.options.pmIgnore || (t2 instanceof L.Map ? t2.pm = new L.PM.Map(t2) : t2 instanceof L.Marker ? t2.options.textMarker ? (t2.pm = new L.PM.Edit.Text(t2), t2.pm._initTextMarker(), t2.pm._createTextMarker(false)) : t2.pm = new L.PM.Edit.Marker(t2) : t2 instanceof L.Circle ? t2.pm = new L.PM.Edit.Circle(t2) : t2 instanceof L.CircleMarker ? t2.pm = new L.PM.Edit.CircleMarker(t2) : t2 instanceof L.Rectangle ? t2.pm = new L.PM.Edit.Rectangle(t2) : t2 instanceof L.Polygon ? t2.pm = new L.PM.Edit.Polygon(t2) : t2 instanceof L.Polyline ? t2.pm = new L.PM.Edit.Line(t2) : t2 instanceof L.LayerGroup ? t2.pm = new L.PM.Edit.LayerGroup(t2) : t2 instanceof L.ImageOverlay && (t2.pm = new L.PM.Edit.ImageOverlay(t2)));
  } };
  L.version === "1.7.1" && L.Canvas.include({ _onClick(t2) {
    let e2 = this._map.mouseEventToLayerPoint(t2), i, r2;
    for (let n2 = this._drawFirst; n2; n2 = n2.next) i = n2.layer, i.options.interactive && i._containsPoint(e2) && (!(t2.type === "click" || t2.type === "preclick") || !this._map._draggableMoved(i)) && (r2 = i);
    r2 && (L.DomEvent.fakeStop(t2), this._fireEvent([r2], t2));
  } });
  L.PM.initialize();
})();
function globalEvents(map, handlers, method) {
  if (handlers.onGlobalCutModeToggled) {
    map[method]("pm:globalcutmodetoggled", handlers.onGlobalCutModeToggled);
  }
  if (handlers.onGlobalDragModeToggled) {
    map[method]("pm:globaldragmodetoggled", handlers.onGlobalDragModeToggled);
  }
  if (handlers.onGlobalDrawModeToggled) {
    map[method]("pm:globaldrawmodetoggled", handlers.onGlobalDrawModeToggled);
  }
  if (handlers.onGlobalEditModeToggled) {
    map[method]("pm:globaleditmodetoggled", handlers.onGlobalEditModeToggled);
  }
  if (handlers.onButtonClick) {
    map[method]("pm:buttonclick", handlers.onButtonClick);
  }
  if (handlers.onActionClick) {
    map[method]("pm:actionclick", handlers.onActionClick);
  }
  if (handlers.onKeyEvent) {
    map[method]("pm:keyevent", handlers.onKeyEvent);
  }
  if (handlers.onLangChange) {
    map[method]("pm:langchange", handlers.onLangChange);
  }
  if (handlers.onGlobalRemovalModeToggled) {
    map[method]("pm:globalremovalmodetoggled", handlers.onGlobalRemovalModeToggled);
  }
  if (handlers.onGlobalRotateModeToggled) {
    map[method]("pm:globalrotatemodetoggled", handlers.onGlobalRotateModeToggled);
  }
}
function layerEvents(layer, handlers, method) {
  if (handlers.onVertexAdded) {
    layer[method]("pm:vertexadded", handlers.onVertexAdded);
  }
  if (handlers.onSnapDrag) {
    layer[method]("pm:snapdrag", handlers.onSnapDrag);
  }
  if (handlers.onSnap) {
    layer[method]("pm:snap", handlers.onSnap);
  }
  if (handlers.onUnsnap) {
    layer[method]("pm:unsnap", handlers.onUnsnap);
  }
  if (handlers.onCenterPlaced) {
    layer[method]("pm:centerplaced", handlers.onCenterPlaced);
  }
  if (handlers.onChange) {
    layer[method]("pm:change", handlers.onChange);
  }
  if (handlers.onEdit) {
    layer[method]("pm:edit", handlers.onEdit);
  }
  if (handlers.onUpdate) {
    layer[method]("pm:update", handlers.onUpdate);
  }
  if (handlers.onEnable) {
    layer[method]("pm:enable", handlers.onEnable);
  }
  if (handlers.onDisable) {
    layer[method]("pm:disable", handlers.onDisable);
  }
  if (handlers.onVertexRemoved) {
    layer[method]("pm:vertexremoved", handlers.onVertexRemoved);
  }
  if (handlers.onVertexClick) {
    layer[method]("pm:vertexclick", handlers.onVertexClick);
  }
  if (handlers.onMarkerDragStart) {
    layer[method]("pm:markerdragstart", handlers.onMarkerDragStart);
  }
  if (handlers.onMarkerDrag) {
    layer[method]("pm:markerdrag", handlers.onMarkerDrag);
  }
  if (handlers.onMarkerDragEnd) {
    layer[method]("pm:markerdragend", handlers.onMarkerDragEnd);
  }
  if (handlers.onLayerReset) {
    layer[method]("pm:layerreset", handlers.onLayerReset);
  }
  if (handlers.onIntersect) {
    layer[method]("pm:intersect", handlers.onIntersect);
  }
  if (handlers.onDragStart) {
    layer[method]("pm:dragstart", handlers.onDragStart);
  }
  if (handlers.onDrag) {
    layer[method]("pm:drag", handlers.onDrag);
  }
  if (handlers.onDragEnd) {
    layer[method]("pm:dragend", handlers.onDragEnd);
  }
  if (handlers.onDragEnable) {
    layer[method]("pm:dragenable", handlers.onDragEnable);
  }
  if (handlers.onDragDisable) {
    layer[method]("pm:dragdisable", handlers.onDragDisable);
  }
  if (handlers.onLayerRemove) {
    layer[method]("pm:remove", handlers.onLayerRemove);
  }
  if (handlers.onLayerCut) {
    layer[method]("pm:cut", handlers.onLayerCut);
  }
  if (handlers.onLayerRotateEnable) {
    layer[method]("pm:rotateenable", handlers.onLayerRotateEnable);
  }
  if (handlers.onLayerRotateDisable) {
    layer[method]("pm:rotatedisable", handlers.onLayerRotateDisable);
  }
  if (handlers.onLayerRotateStart) {
    layer[method]("pm:rotatestart", handlers.onLayerRotateStart);
  }
  if (handlers.onLayerRotate) {
    layer[method]("pm:rotate", handlers.onLayerRotate);
  }
  if (handlers.onLayerRotateEnd) {
    layer[method]("pm:rotateend", handlers.onLayerRotateEnd);
  }
  if (handlers.onTextChange) {
    layer[method]("pm:textchange", handlers.onTextChange);
  }
}
function mapEvents(map, handlers, method) {
  if (handlers.onMapCut) {
    map[method]("pm:cut", (e2) => {
      layerEvents(e2.layer, handlers, "off");
      layerEvents(e2.layer, handlers, "on");
      if (handlers.onMapCut)
        handlers.onMapCut(e2);
    });
  }
  if (handlers.onCreate) {
    map[method]("pm:create", (e2) => {
      layerEvents(e2.layer, handlers, "off");
      layerEvents(e2.layer, handlers, "on");
      if (handlers.onCreate)
        handlers.onCreate(e2);
    });
  }
  if (handlers.onDrawStart) {
    map[method]("pm:drawstart", handlers.onDrawStart);
  }
  if (handlers.onDrawEnd) {
    map[method]("pm:drawend", handlers.onDrawEnd);
  }
  if (handlers.onMapRemove) {
    map[method]("pm:remove", handlers.onMapRemove);
  }
  if (handlers.onMapRotateEnable) {
    map[method]("pm:rotateenable", handlers.onMapRotateEnable);
  }
  if (handlers.onMapRotateDisable) {
    map[method]("pm:rotatedisable", handlers.onMapRotateDisable);
  }
  if (handlers.onMapRotate) {
    map[method]("pm:rotate", handlers.onMapRotate);
  }
  if (handlers.onMapRotateStart) {
    map[method]("pm:rotatestart", handlers.onMapRotateStart);
  }
  if (handlers.onMapRotateEnd) {
    map[method]("pm:rotateend", handlers.onMapRotateEnd);
  }
}
const reference = [
  "onMapRemove",
  "onLayerRemove",
  "onMapCut",
  "onLayerCut",
  "onMapRotateEnable",
  "onLayerRotateEnable",
  "onMapRotateDisable",
  "onLayerRotateDisable",
  "onMapRotateStart",
  "onLayerRotateStart",
  "onMapRotate",
  "onLayerRotate",
  "onMapRotateEnd",
  "onLayerRotateEnd",
  "onGlobalDrawModeToggled",
  "onDrawStart",
  "onDrawEnd",
  "onCreate",
  "onGlobalEditModeToggled",
  "onGlobalDragModeToggled",
  "onGlobalRemovalModeToggled",
  "onGlobalCutModeToggled",
  "onGlobalRotateModeToggled",
  "onLangChange",
  "onButtonClick",
  "onActionClick",
  "onKeyEvent",
  "onSnapDrag",
  "onSnap",
  "onUnsnap",
  "onCenterPlaced",
  "onEdit",
  "onUpdate",
  "onEnable",
  "onDisable",
  "onVertexAdded",
  "onVertexRemoved",
  "onVertexClick",
  "onMarkerDragStart",
  "onMarkerDrag",
  "onMarkerDragEnd",
  "onLayerReset",
  "onIntersect",
  "onChange",
  "onTextChange",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onDragEnable",
  "onDragDisable"
];
function GeomanControls({ options = {}, globalOptions = {}, pathOptions = {}, lang = "en", eventDebugFn, onMount, onUnmount, ...handlers }) {
  const [mounted, setMounted] = reactExports.useState(false);
  const [handlersRef, setHandlersRef] = reactExports.useState({});
  const { map, layerContainer } = useLeafletContext();
  const container = layerContainer || map;
  if (!container) {
    console.warn("[GEOMAN-CONTROLS] No map or container instance found");
    return null;
  }
  reactExports.useLayoutEffect(() => {
    if (!map.pm.controlsVisible()) {
      map.pm.addControls(options);
      if (onMount)
        onMount();
      setMounted(true);
    }
    return () => {
      map.pm.disableDraw();
      map.pm.disableGlobalEditMode();
      map.pm.disableGlobalRemovalMode();
      map.pm.disableGlobalDragMode();
      map.pm.disableGlobalCutMode();
      map.pm.disableGlobalRotateMode();
      map.pm.disableGlobalDragMode();
      map.pm.disableGlobalCutMode();
      if (onUnmount)
        onUnmount();
      map.pm.removeControls();
      setMounted(false);
    };
  }, []);
  reactExports.useEffect(() => {
    if (mounted)
      map.pm.setPathOptions(pathOptions);
  }, [pathOptions, mounted]);
  reactExports.useEffect(() => {
    if (mounted)
      map.pm.setGlobalOptions({ layerGroup: container, ...globalOptions });
  }, [globalOptions, mounted]);
  reactExports.useEffect(() => {
    if (mounted)
      map.pm.setLang(lang);
  }, [lang, mounted]);
  reactExports.useEffect(() => {
    if (mounted) {
      const withDebug = Object.fromEntries(reference.map((handler) => [handler, handlers[handler] ?? eventDebugFn]));
      const layers = layerContainer ? container.getLayers() : map.pm.getGeomanLayers();
      layers.forEach((layer) => layerEvents(layer, withDebug, "on"));
      globalEvents(map, withDebug, "on");
      mapEvents(map, withDebug, "on");
      return () => {
        globalEvents(map, withDebug, "off");
        mapEvents(map, withDebug, "off");
        layers.forEach((layer) => layerEvents(layer, withDebug, "off"));
        setHandlersRef(handlers);
      };
    }
  }, [
    mounted,
    true
  ]);
  return null;
}
var Control_FullScreen = { exports: {} };
(function(module) {
  (function(root, factory) {
    if (module.exports) {
      module.exports = factory(leafletSrcExports);
    } else {
      factory(root.L);
    }
  })(typeof self !== "undefined" ? self : commonjsGlobal, (leaflet) => {
    if (typeof document === "undefined") {
      console.warn('"window.document" is undefined; leaflet.fullscreen requires this object to access the DOM');
      return false;
    }
    const nativeAPI = (() => {
      const methodMap = [
        // Standard
        [
          "requestFullscreen",
          "exitFullscreen",
          "fullscreenElement",
          "fullscreenEnabled",
          "fullscreenchange",
          "fullscreenerror"
        ],
        // New WebKit
        [
          "webkitRequestFullscreen",
          "webkitExitFullscreen",
          "webkitFullscreenElement",
          "webkitFullscreenEnabled",
          "webkitfullscreenchange",
          "webkitfullscreenerror"
        ]
      ];
      const baseList = methodMap[0];
      const ret = {};
      for (const methodList of methodMap) {
        if (methodList[1] in document) {
          for (let i = 0; i < methodList.length; i++) {
            ret[baseList[i]] = methodList[i];
          }
          return ret;
        }
      }
      return false;
    })();
    const eventNameMap = {
      change: nativeAPI.fullscreenchange,
      error: nativeAPI.fullscreenerror
    };
    const fullscreenAPI = {
      request(element, options) {
        return new Promise((resolve, reject) => {
          const onFullScreenEntered = (function() {
            this.off("change", onFullScreenEntered);
            resolve();
          }).bind(this);
          this.on("change", onFullScreenEntered);
          element = element || document.documentElement;
          const returnPromise = element[nativeAPI.requestFullscreen](options);
          if (returnPromise instanceof Promise) {
            returnPromise.then(onFullScreenEntered).catch(reject);
          }
        });
      },
      exit() {
        return new Promise((resolve, reject) => {
          if (!this.isFullscreen) {
            resolve();
            return;
          }
          const onFullScreenExit = (function() {
            this.off("change", onFullScreenExit);
            resolve();
          }).bind(this);
          this.on("change", onFullScreenExit);
          const returnPromise = document[nativeAPI.exitFullscreen]();
          if (returnPromise instanceof Promise) {
            returnPromise.then(onFullScreenExit).catch(reject);
          }
        });
      },
      on(event, callback) {
        const eventName = eventNameMap[event];
        if (eventName) {
          document.addEventListener(eventName, callback, false);
        }
      },
      off(event, callback) {
        const eventName = eventNameMap[event];
        if (eventName) {
          document.removeEventListener(eventName, callback, false);
        }
      },
      nativeAPI
    };
    Object.defineProperties(fullscreenAPI, {
      isFullscreen: {
        get() {
          return Boolean(document[nativeAPI.fullscreenElement]);
        }
      },
      isEnabled: {
        enumerable: true,
        get() {
          return Boolean(document[nativeAPI.fullscreenEnabled]);
        }
      }
    });
    leaflet.Control.FullScreen = leaflet.Control.extend({
      options: {
        position: "topleft",
        title: "Full Screen",
        titleCancel: "Exit Full Screen",
        forceSeparateButton: false,
        forcePseudoFullscreen: false,
        fullscreenElement: false
      },
      _screenfull: fullscreenAPI,
      onAdd(map) {
        let className = "leaflet-control-zoom-fullscreen";
        let container;
        let content = "";
        if (map.zoomControl && !this.options.forceSeparateButton) {
          container = map.zoomControl._container;
        } else {
          container = leaflet.DomUtil.create("div", "leaflet-bar");
        }
        if (this.options.content) {
          content = this.options.content;
        } else {
          className += " fullscreen-icon";
        }
        this._createButton(this.options.title, className, content, container, this.toggleFullScreen, this);
        this._map.fullscreenControl = this;
        this._map.on("enterFullscreen exitFullscreen", this._toggleState, this);
        return container;
      },
      onRemove() {
        leaflet.DomEvent.off(this.link, "click", leaflet.DomEvent.stop).off(this.link, "click", this.toggleFullScreen, this);
        if (this._screenfull.isEnabled) {
          leaflet.DomEvent.off(this._container, this._screenfull.nativeAPI.fullscreenchange, leaflet.DomEvent.stop).off(this._container, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this);
          leaflet.DomEvent.off(document, this._screenfull.nativeAPI.fullscreenchange, leaflet.DomEvent.stop).off(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this);
        }
      },
      _createButton(title, className, content, container, fn, context) {
        this.link = leaflet.DomUtil.create("a", className, container);
        this.link.href = "#";
        this.link.title = title;
        this.link.innerHTML = content;
        this.link.setAttribute("role", "button");
        this.link.setAttribute("aria-label", title);
        L.DomEvent.disableClickPropagation(container);
        leaflet.DomEvent.on(this.link, "click", leaflet.DomEvent.stop).on(this.link, "click", fn, context);
        if (this._screenfull.isEnabled) {
          leaflet.DomEvent.on(container, this._screenfull.nativeAPI.fullscreenchange, leaflet.DomEvent.stop).on(container, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, context);
          leaflet.DomEvent.on(document, this._screenfull.nativeAPI.fullscreenchange, leaflet.DomEvent.stop).on(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, context);
        }
        return this.link;
      },
      toggleFullScreen() {
        const map = this._map;
        map._exitFired = false;
        if (map._isFullscreen) {
          if (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen) {
            this._screenfull.exit().then(() => map.invalidateSize());
          } else {
            leaflet.DomUtil.removeClass(this.options.fullscreenElement ? this.options.fullscreenElement : map._container, "leaflet-pseudo-fullscreen");
            map.invalidateSize();
          }
          map.fire("exitFullscreen");
          map._exitFired = true;
          map._isFullscreen = false;
        } else {
          if (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen) {
            this._screenfull.request(this.options.fullscreenElement ? this.options.fullscreenElement : map._container).then(() => map.invalidateSize());
          } else {
            leaflet.DomUtil.addClass(this.options.fullscreenElement ? this.options.fullscreenElement : map._container, "leaflet-pseudo-fullscreen");
            map.invalidateSize();
          }
          map.fire("enterFullscreen");
          map._isFullscreen = true;
        }
      },
      _toggleState() {
        this.link.title = this._map._isFullscreen ? this.options.title : this.options.titleCancel;
        this._map._isFullscreen ? L.DomUtil.removeClass(this.link, "leaflet-fullscreen-on") : L.DomUtil.addClass(this.link, "leaflet-fullscreen-on");
      },
      _handleFullscreenChange(ev) {
        const map = this._map;
        if (ev.target === map.getContainer() && !this._screenfull.isFullscreen && !map._exitFired) {
          this._screenfull.exit().then(() => map.invalidateSize());
          map.fire("exitFullscreen");
          map._exitFired = true;
          map._isFullscreen = false;
        }
      }
    });
    leaflet.Map.include({
      toggleFullscreen() {
        this.fullscreenControl.toggleFullScreen();
      }
    });
    leaflet.Map.addInitHook(function() {
      if (this.options.fullscreenControl) {
        this.addControl(leaflet.control.fullscreen(this.options.fullscreenControlOptions));
      }
    });
    leaflet.control.fullscreen = function(options) {
      return new leaflet.Control.FullScreen(options);
    };
    return { leaflet };
  });
})(Control_FullScreen);
var reactDomServerLegacy_browser_production_min = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$1 = reactExports;
function l$2(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var p$1 = Object.prototype.hasOwnProperty, fa$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ha$1 = {}, ia$1 = {};
function ja$1(a) {
  if (p$1.call(ia$1, a)) return true;
  if (p$1.call(ha$1, a)) return false;
  if (fa$1.test(a)) return ia$1[a] = true;
  ha$1[a] = true;
  return false;
}
function r(a, b, c, d, f2, e2, g2) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = f2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = e2;
  this.removeEmptyString = g2;
}
var t$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  t$1[a] = new r(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  t$1[b] = new r(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  t$1[a] = new r(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  t$1[a] = new r(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  t$1[a] = new r(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  t$1[a] = new r(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  t$1[a] = new r(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  t$1[a] = new r(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  t$1[a] = new r(a, 5, false, a.toLowerCase(), null, false, false);
});
var ka$1 = /[\-:]([a-z])/g;
function la$1(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ka$1,
    la$1
  );
  t$1[b] = new r(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ka$1, la$1);
  t$1[b] = new r(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ka$1, la$1);
  t$1[b] = new r(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  t$1[a] = new r(a, 1, false, a.toLowerCase(), null, false, false);
});
t$1.xlinkHref = new r("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  t$1[a] = new r(a, 1, false, a.toLowerCase(), null, true, true);
});
var u$1 = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, ma = ["Webkit", "ms", "Moz", "O"];
Object.keys(u$1).forEach(function(a) {
  ma.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    u$1[b] = u$1[a];
  });
});
var na = /["'&<>]/;
function v(a) {
  if ("boolean" === typeof a || "number" === typeof a) return "" + a;
  a = "" + a;
  var b = na.exec(a);
  if (b) {
    var c = "", d, f2 = 0;
    for (d = b.index; d < a.length; d++) {
      switch (a.charCodeAt(d)) {
        case 34:
          b = "&quot;";
          break;
        case 38:
          b = "&amp;";
          break;
        case 39:
          b = "&#x27;";
          break;
        case 60:
          b = "&lt;";
          break;
        case 62:
          b = "&gt;";
          break;
        default:
          continue;
      }
      f2 !== d && (c += a.substring(f2, d));
      f2 = d + 1;
      c += b;
    }
    a = f2 !== d ? c + a.substring(f2, d) : c;
  }
  return a;
}
var oa$1 = /([A-Z])/g, pa$1 = /^ms-/, qa$1 = Array.isArray;
function w$1(a, b) {
  return { insertionMode: a, selectedValue: b };
}
function ra$1(a, b, c) {
  switch (b) {
    case "select":
      return w$1(1, null != c.value ? c.value : c.defaultValue);
    case "svg":
      return w$1(2, null);
    case "math":
      return w$1(3, null);
    case "foreignObject":
      return w$1(1, null);
    case "table":
      return w$1(4, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return w$1(5, null);
    case "colgroup":
      return w$1(7, null);
    case "tr":
      return w$1(6, null);
  }
  return 4 <= a.insertionMode || 0 === a.insertionMode ? w$1(1, null) : a;
}
var sa$1 = /* @__PURE__ */ new Map();
function ta$1(a, b, c) {
  if ("object" !== typeof c) throw Error(l$2(62));
  b = true;
  for (var d in c) if (p$1.call(c, d)) {
    var f2 = c[d];
    if (null != f2 && "boolean" !== typeof f2 && "" !== f2) {
      if (0 === d.indexOf("--")) {
        var e2 = v(d);
        f2 = v(("" + f2).trim());
      } else {
        e2 = d;
        var g2 = sa$1.get(e2);
        void 0 !== g2 ? e2 = g2 : (g2 = v(e2.replace(oa$1, "-$1").toLowerCase().replace(pa$1, "-ms-")), sa$1.set(e2, g2), e2 = g2);
        f2 = "number" === typeof f2 ? 0 === f2 || p$1.call(u$1, d) ? "" + f2 : f2 + "px" : v(("" + f2).trim());
      }
      b ? (b = false, a.push(' style="', e2, ":", f2)) : a.push(";", e2, ":", f2);
    }
  }
  b || a.push('"');
}
function x$1(a, b, c, d) {
  switch (c) {
    case "style":
      ta$1(a, b, d);
      return;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }
  if (!(2 < c.length) || "o" !== c[0] && "O" !== c[0] || "n" !== c[1] && "N" !== c[1]) {
    if (b = t$1.hasOwnProperty(c) ? t$1[c] : null, null !== b) {
      switch (typeof d) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (!b.acceptsBooleans) return;
      }
      c = b.attributeName;
      switch (b.type) {
        case 3:
          d && a.push(" ", c, '=""');
          break;
        case 4:
          true === d ? a.push(" ", c, '=""') : false !== d && a.push(" ", c, '="', v(d), '"');
          break;
        case 5:
          isNaN(d) || a.push(" ", c, '="', v(d), '"');
          break;
        case 6:
          !isNaN(d) && 1 <= d && a.push(" ", c, '="', v(d), '"');
          break;
        default:
          b.sanitizeURL && (d = "" + d), a.push(" ", c, '="', v(d), '"');
      }
    } else if (ja$1(c)) {
      switch (typeof d) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (b = c.toLowerCase().slice(0, 5), "data-" !== b && "aria-" !== b) return;
      }
      a.push(" ", c, '="', v(d), '"');
    }
  }
}
function y$1(a, b, c) {
  if (null != b) {
    if (null != c) throw Error(l$2(60));
    if ("object" !== typeof b || !("__html" in b)) throw Error(l$2(61));
    b = b.__html;
    null !== b && void 0 !== b && a.push("" + b);
  }
}
function ua$1(a) {
  var b = "";
  aa$1.Children.forEach(a, function(a2) {
    null != a2 && (b += a2);
  });
  return b;
}
function va$1(a, b, c, d) {
  a.push(A(c));
  var f2 = c = null, e2;
  for (e2 in b) if (p$1.call(b, e2)) {
    var g2 = b[e2];
    if (null != g2) switch (e2) {
      case "children":
        c = g2;
        break;
      case "dangerouslySetInnerHTML":
        f2 = g2;
        break;
      default:
        x$1(a, d, e2, g2);
    }
  }
  a.push(">");
  y$1(a, f2, c);
  return "string" === typeof c ? (a.push(v(c)), null) : c;
}
var wa$1 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, xa$1 = /* @__PURE__ */ new Map();
function A(a) {
  var b = xa$1.get(a);
  if (void 0 === b) {
    if (!wa$1.test(a)) throw Error(l$2(65, a));
    b = "<" + a;
    xa$1.set(a, b);
  }
  return b;
}
function ya$1(a, b, c, d, f2) {
  switch (b) {
    case "select":
      a.push(A("select"));
      var e2 = null, g2 = null;
      for (n2 in c) if (p$1.call(c, n2)) {
        var h2 = c[n2];
        if (null != h2) switch (n2) {
          case "children":
            e2 = h2;
            break;
          case "dangerouslySetInnerHTML":
            g2 = h2;
            break;
          case "defaultValue":
          case "value":
            break;
          default:
            x$1(a, d, n2, h2);
        }
      }
      a.push(">");
      y$1(a, g2, e2);
      return e2;
    case "option":
      g2 = f2.selectedValue;
      a.push(A("option"));
      var k2 = h2 = null, m2 = null;
      var n2 = null;
      for (e2 in c) if (p$1.call(c, e2)) {
        var q2 = c[e2];
        if (null != q2) switch (e2) {
          case "children":
            h2 = q2;
            break;
          case "selected":
            m2 = q2;
            break;
          case "dangerouslySetInnerHTML":
            n2 = q2;
            break;
          case "value":
            k2 = q2;
          default:
            x$1(a, d, e2, q2);
        }
      }
      if (null != g2) if (c = null !== k2 ? "" + k2 : ua$1(h2), qa$1(g2)) for (d = 0; d < g2.length; d++) {
        if ("" + g2[d] === c) {
          a.push(' selected=""');
          break;
        }
      }
      else "" + g2 === c && a.push(' selected=""');
      else m2 && a.push(' selected=""');
      a.push(">");
      y$1(a, n2, h2);
      return h2;
    case "textarea":
      a.push(A("textarea"));
      n2 = g2 = e2 = null;
      for (h2 in c) if (p$1.call(c, h2) && (k2 = c[h2], null != k2)) switch (h2) {
        case "children":
          n2 = k2;
          break;
        case "value":
          e2 = k2;
          break;
        case "defaultValue":
          g2 = k2;
          break;
        case "dangerouslySetInnerHTML":
          throw Error(l$2(91));
        default:
          x$1(
            a,
            d,
            h2,
            k2
          );
      }
      null === e2 && null !== g2 && (e2 = g2);
      a.push(">");
      if (null != n2) {
        if (null != e2) throw Error(l$2(92));
        if (qa$1(n2) && 1 < n2.length) throw Error(l$2(93));
        e2 = "" + n2;
      }
      "string" === typeof e2 && "\n" === e2[0] && a.push("\n");
      null !== e2 && a.push(v("" + e2));
      return null;
    case "input":
      a.push(A("input"));
      k2 = n2 = h2 = e2 = null;
      for (g2 in c) if (p$1.call(c, g2) && (m2 = c[g2], null != m2)) switch (g2) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(l$2(399, "input"));
        case "defaultChecked":
          k2 = m2;
          break;
        case "defaultValue":
          h2 = m2;
          break;
        case "checked":
          n2 = m2;
          break;
        case "value":
          e2 = m2;
          break;
        default:
          x$1(a, d, g2, m2);
      }
      null !== n2 ? x$1(a, d, "checked", n2) : null !== k2 && x$1(a, d, "checked", k2);
      null !== e2 ? x$1(a, d, "value", e2) : null !== h2 && x$1(a, d, "value", h2);
      a.push("/>");
      return null;
    case "menuitem":
      a.push(A("menuitem"));
      for (var C2 in c) if (p$1.call(c, C2) && (e2 = c[C2], null != e2)) switch (C2) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(l$2(400));
        default:
          x$1(a, d, C2, e2);
      }
      a.push(">");
      return null;
    case "title":
      a.push(A("title"));
      e2 = null;
      for (q2 in c) if (p$1.call(c, q2) && (g2 = c[q2], null != g2)) switch (q2) {
        case "children":
          e2 = g2;
          break;
        case "dangerouslySetInnerHTML":
          throw Error(l$2(434));
        default:
          x$1(a, d, q2, g2);
      }
      a.push(">");
      return e2;
    case "listing":
    case "pre":
      a.push(A(b));
      g2 = e2 = null;
      for (k2 in c) if (p$1.call(c, k2) && (h2 = c[k2], null != h2)) switch (k2) {
        case "children":
          e2 = h2;
          break;
        case "dangerouslySetInnerHTML":
          g2 = h2;
          break;
        default:
          x$1(a, d, k2, h2);
      }
      a.push(">");
      if (null != g2) {
        if (null != e2) throw Error(l$2(60));
        if ("object" !== typeof g2 || !("__html" in g2)) throw Error(l$2(61));
        c = g2.__html;
        null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push("\n", c) : a.push("" + c));
      }
      "string" === typeof e2 && "\n" === e2[0] && a.push("\n");
      return e2;
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a.push(A(b));
      for (var D2 in c) if (p$1.call(c, D2) && (e2 = c[D2], null != e2)) switch (D2) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(l$2(399, b));
        default:
          x$1(a, d, D2, e2);
      }
      a.push("/>");
      return null;
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return va$1(
        a,
        c,
        b,
        d
      );
    case "html":
      return 0 === f2.insertionMode && a.push("<!DOCTYPE html>"), va$1(a, c, b, d);
    default:
      if (-1 === b.indexOf("-") && "string" !== typeof c.is) return va$1(a, c, b, d);
      a.push(A(b));
      g2 = e2 = null;
      for (m2 in c) if (p$1.call(c, m2) && (h2 = c[m2], null != h2)) switch (m2) {
        case "children":
          e2 = h2;
          break;
        case "dangerouslySetInnerHTML":
          g2 = h2;
          break;
        case "style":
          ta$1(a, d, h2);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          break;
        default:
          ja$1(m2) && "function" !== typeof h2 && "symbol" !== typeof h2 && a.push(" ", m2, '="', v(h2), '"');
      }
      a.push(">");
      y$1(a, g2, e2);
      return e2;
  }
}
function za$1(a, b, c) {
  a.push('<!--$?--><template id="');
  if (null === c) throw Error(l$2(395));
  a.push(c);
  return a.push('"></template>');
}
function Aa$1(a, b, c, d) {
  switch (c.insertionMode) {
    case 0:
    case 1:
      return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    case 2:
      return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    case 3:
      return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    case 4:
      return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    case 5:
      return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    case 6:
      return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    case 7:
      return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
    default:
      throw Error(l$2(397));
  }
}
function Ba$1(a, b) {
  switch (b.insertionMode) {
    case 0:
    case 1:
      return a.push("</div>");
    case 2:
      return a.push("</svg>");
    case 3:
      return a.push("</math>");
    case 4:
      return a.push("</table>");
    case 5:
      return a.push("</tbody></table>");
    case 6:
      return a.push("</tr></table>");
    case 7:
      return a.push("</colgroup></table>");
    default:
      throw Error(l$2(397));
  }
}
var Ca$1 = /[<\u2028\u2029]/g;
function Da$1(a) {
  return JSON.stringify(a).replace(Ca$1, function(a2) {
    switch (a2) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function Ea$1(a, b) {
  b = void 0 === b ? "" : b;
  return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b + "P:", segmentPrefix: b + "S:", boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false, generateStaticMarkup: a };
}
function Fa$1(a, b, c, d) {
  if (c.generateStaticMarkup) return a.push(v(b)), false;
  "" === b ? a = d : (d && a.push("<!-- -->"), a.push(v(b)), a = true);
  return a;
}
var B$1 = Object.assign, Ga$1 = Symbol.for("react.element"), Ha$1 = Symbol.for("react.portal"), Ia$1 = Symbol.for("react.fragment"), Ja$1 = Symbol.for("react.strict_mode"), Ka$1 = Symbol.for("react.profiler"), La$1 = Symbol.for("react.provider"), Ma$1 = Symbol.for("react.context"), Na$1 = Symbol.for("react.forward_ref"), Oa$1 = Symbol.for("react.suspense"), Pa$1 = Symbol.for("react.suspense_list"), Qa$1 = Symbol.for("react.memo"), Ra$1 = Symbol.for("react.lazy"), Sa$1 = Symbol.for("react.scope"), Ta$1 = Symbol.for("react.debug_trace_mode"), Ua$1 = Symbol.for("react.legacy_hidden"), Va$1 = Symbol.for("react.default_value"), Wa$1 = Symbol.iterator;
function Xa$1(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case Ia$1:
      return "Fragment";
    case Ha$1:
      return "Portal";
    case Ka$1:
      return "Profiler";
    case Ja$1:
      return "StrictMode";
    case Oa$1:
      return "Suspense";
    case Pa$1:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ma$1:
      return (a.displayName || "Context") + ".Consumer";
    case La$1:
      return (a._context.displayName || "Context") + ".Provider";
    case Na$1:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Qa$1:
      return b = a.displayName || null, null !== b ? b : Xa$1(a.type) || "Memo";
    case Ra$1:
      b = a._payload;
      a = a._init;
      try {
        return Xa$1(a(b));
      } catch (c) {
      }
  }
  return null;
}
var Ya$1 = {};
function Za$1(a, b) {
  a = a.contextTypes;
  if (!a) return Ya$1;
  var c = {}, d;
  for (d in a) c[d] = b[d];
  return c;
}
var E$1 = null;
function F(a, b) {
  if (a !== b) {
    a.context._currentValue2 = a.parentValue;
    a = a.parent;
    var c = b.parent;
    if (null === a) {
      if (null !== c) throw Error(l$2(401));
    } else {
      if (null === c) throw Error(l$2(401));
      F(a, c);
    }
    b.context._currentValue2 = b.value;
  }
}
function $a$1(a) {
  a.context._currentValue2 = a.parentValue;
  a = a.parent;
  null !== a && $a$1(a);
}
function ab$1(a) {
  var b = a.parent;
  null !== b && ab$1(b);
  a.context._currentValue2 = a.value;
}
function bb$1(a, b) {
  a.context._currentValue2 = a.parentValue;
  a = a.parent;
  if (null === a) throw Error(l$2(402));
  a.depth === b.depth ? F(a, b) : bb$1(a, b);
}
function cb$1(a, b) {
  var c = b.parent;
  if (null === c) throw Error(l$2(402));
  a.depth === c.depth ? F(a, c) : cb$1(a, c);
  b.context._currentValue2 = b.value;
}
function G(a) {
  var b = E$1;
  b !== a && (null === b ? ab$1(a) : null === a ? $a$1(b) : b.depth === a.depth ? F(b, a) : b.depth > a.depth ? bb$1(b, a) : cb$1(b, a), E$1 = a);
}
var db$1 = { isMounted: function() {
  return false;
}, enqueueSetState: function(a, b) {
  a = a._reactInternals;
  null !== a.queue && a.queue.push(b);
}, enqueueReplaceState: function(a, b) {
  a = a._reactInternals;
  a.replace = true;
  a.queue = [b];
}, enqueueForceUpdate: function() {
} };
function eb$1(a, b, c, d) {
  var f2 = void 0 !== a.state ? a.state : null;
  a.updater = db$1;
  a.props = c;
  a.state = f2;
  var e2 = { queue: [], replace: false };
  a._reactInternals = e2;
  var g2 = b.contextType;
  a.context = "object" === typeof g2 && null !== g2 ? g2._currentValue2 : d;
  g2 = b.getDerivedStateFromProps;
  "function" === typeof g2 && (g2 = g2(c, f2), f2 = null === g2 || void 0 === g2 ? f2 : B$1({}, f2, g2), a.state = f2);
  if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && db$1.enqueueReplaceState(a, a.state, null), null !== e2.queue && 0 < e2.queue.length) if (b = e2.queue, g2 = e2.replace, e2.queue = null, e2.replace = false, g2 && 1 === b.length) a.state = b[0];
  else {
    e2 = g2 ? b[0] : a.state;
    f2 = true;
    for (g2 = g2 ? 1 : 0; g2 < b.length; g2++) {
      var h2 = b[g2];
      h2 = "function" === typeof h2 ? h2.call(a, e2, c, d) : h2;
      null != h2 && (f2 ? (f2 = false, e2 = B$1({}, e2, h2)) : B$1(e2, h2));
    }
    a.state = e2;
  }
  else e2.queue = null;
}
var fb$1 = { id: 1, overflow: "" };
function gb$1(a, b, c) {
  var d = a.id;
  a = a.overflow;
  var f2 = 32 - H$1(d) - 1;
  d &= ~(1 << f2);
  c += 1;
  var e2 = 32 - H$1(b) + f2;
  if (30 < e2) {
    var g2 = f2 - f2 % 5;
    e2 = (d & (1 << g2) - 1).toString(32);
    d >>= g2;
    f2 -= g2;
    return { id: 1 << 32 - H$1(b) + f2 | c << f2 | d, overflow: e2 + a };
  }
  return { id: 1 << e2 | c << f2 | d, overflow: a };
}
var H$1 = Math.clz32 ? Math.clz32 : hb$1, ib$1 = Math.log, jb$1 = Math.LN2;
function hb$1(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (ib$1(a) / jb$1 | 0) | 0;
}
function kb$1(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var lb$1 = "function" === typeof Object.is ? Object.is : kb$1, I$1 = null, ob$1 = null, J$1 = null, K$1 = null, L$2 = false, M$1 = false, N$1 = 0, O$1 = null, P$1 = 0;
function Q$1() {
  if (null === I$1) throw Error(l$2(321));
  return I$1;
}
function pb$1() {
  if (0 < P$1) throw Error(l$2(312));
  return { memoizedState: null, queue: null, next: null };
}
function qb$1() {
  null === K$1 ? null === J$1 ? (L$2 = false, J$1 = K$1 = pb$1()) : (L$2 = true, K$1 = J$1) : null === K$1.next ? (L$2 = false, K$1 = K$1.next = pb$1()) : (L$2 = true, K$1 = K$1.next);
  return K$1;
}
function rb$1() {
  ob$1 = I$1 = null;
  M$1 = false;
  J$1 = null;
  P$1 = 0;
  K$1 = O$1 = null;
}
function sb$1(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function tb$1(a, b, c) {
  I$1 = Q$1();
  K$1 = qb$1();
  if (L$2) {
    var d = K$1.queue;
    b = d.dispatch;
    if (null !== O$1 && (c = O$1.get(d), void 0 !== c)) {
      O$1.delete(d);
      d = K$1.memoizedState;
      do
        d = a(d, c.action), c = c.next;
      while (null !== c);
      K$1.memoizedState = d;
      return [d, b];
    }
    return [K$1.memoizedState, b];
  }
  a = a === sb$1 ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
  K$1.memoizedState = a;
  a = K$1.queue = { last: null, dispatch: null };
  a = a.dispatch = ub$1.bind(null, I$1, a);
  return [K$1.memoizedState, a];
}
function vb$1(a, b) {
  I$1 = Q$1();
  K$1 = qb$1();
  b = void 0 === b ? null : b;
  if (null !== K$1) {
    var c = K$1.memoizedState;
    if (null !== c && null !== b) {
      var d = c[1];
      a: if (null === d) d = false;
      else {
        for (var f2 = 0; f2 < d.length && f2 < b.length; f2++) if (!lb$1(b[f2], d[f2])) {
          d = false;
          break a;
        }
        d = true;
      }
      if (d) return c[0];
    }
  }
  a = a();
  K$1.memoizedState = [a, b];
  return a;
}
function ub$1(a, b, c) {
  if (25 <= P$1) throw Error(l$2(301));
  if (a === I$1) if (M$1 = true, a = { action: c, next: null }, null === O$1 && (O$1 = /* @__PURE__ */ new Map()), c = O$1.get(b), void 0 === c) O$1.set(b, a);
  else {
    for (b = c; null !== b.next; ) b = b.next;
    b.next = a;
  }
}
function wb$1() {
  throw Error(l$2(394));
}
function R$1() {
}
var xb$1 = { readContext: function(a) {
  return a._currentValue2;
}, useContext: function(a) {
  Q$1();
  return a._currentValue2;
}, useMemo: vb$1, useReducer: tb$1, useRef: function(a) {
  I$1 = Q$1();
  K$1 = qb$1();
  var b = K$1.memoizedState;
  return null === b ? (a = { current: a }, K$1.memoizedState = a) : b;
}, useState: function(a) {
  return tb$1(sb$1, a);
}, useInsertionEffect: R$1, useLayoutEffect: function() {
}, useCallback: function(a, b) {
  return vb$1(function() {
    return a;
  }, b);
}, useImperativeHandle: R$1, useEffect: R$1, useDebugValue: R$1, useDeferredValue: function(a) {
  Q$1();
  return a;
}, useTransition: function() {
  Q$1();
  return [
    false,
    wb$1
  ];
}, useId: function() {
  var a = ob$1.treeContext;
  var b = a.overflow;
  a = a.id;
  a = (a & ~(1 << 32 - H$1(a) - 1)).toString(32) + b;
  var c = S$1;
  if (null === c) throw Error(l$2(404));
  b = N$1++;
  a = ":" + c.idPrefix + "R" + a;
  0 < b && (a += "H" + b.toString(32));
  return a + ":";
}, useMutableSource: function(a, b) {
  Q$1();
  return b(a._source);
}, useSyncExternalStore: function(a, b, c) {
  if (void 0 === c) throw Error(l$2(407));
  return c();
} }, S$1 = null, yb$1 = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
function zb$1(a) {
  console.error(a);
  return null;
}
function T$1() {
}
function Ab$1(a, b, c, d, f2, e2, g2, h2, k2) {
  var m2 = [], n2 = /* @__PURE__ */ new Set();
  b = { destination: null, responseState: b, progressiveChunkSize: void 0 === d ? 12800 : d, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: n2, pingedTasks: m2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f2 ? zb$1 : f2, onAllReady: T$1, onShellReady: void 0 === g2 ? T$1 : g2, onShellError: T$1, onFatalError: T$1 };
  c = U$1(b, 0, null, c, false, false);
  c.parentFlushed = true;
  a = Bb$1(b, a, null, c, n2, Ya$1, null, fb$1);
  m2.push(a);
  return b;
}
function Bb$1(a, b, c, d, f2, e2, g2, h2) {
  a.allPendingTasks++;
  null === c ? a.pendingRootTasks++ : c.pendingTasks++;
  var k2 = { node: b, ping: function() {
    var b2 = a.pingedTasks;
    b2.push(k2);
    1 === b2.length && Cb$1(a);
  }, blockedBoundary: c, blockedSegment: d, abortSet: f2, legacyContext: e2, context: g2, treeContext: h2 };
  f2.add(k2);
  return k2;
}
function U$1(a, b, c, d, f2, e2) {
  return { status: 0, id: -1, index: b, parentFlushed: false, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f2, textEmbedded: e2 };
}
function V$1(a, b) {
  a = a.onError(b);
  if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
  return a;
}
function W$1(a, b) {
  var c = a.onShellError;
  c(b);
  c = a.onFatalError;
  c(b);
  null !== a.destination ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
}
function Db$1(a, b, c, d, f2) {
  I$1 = {};
  ob$1 = b;
  N$1 = 0;
  for (a = c(d, f2); M$1; ) M$1 = false, N$1 = 0, P$1 += 1, K$1 = null, a = c(d, f2);
  rb$1();
  return a;
}
function Eb$1(a, b, c, d) {
  var f2 = c.render(), e2 = d.childContextTypes;
  if (null !== e2 && void 0 !== e2) {
    var g2 = b.legacyContext;
    if ("function" !== typeof c.getChildContext) d = g2;
    else {
      c = c.getChildContext();
      for (var h2 in c) if (!(h2 in e2)) throw Error(l$2(108, Xa$1(d) || "Unknown", h2));
      d = B$1({}, g2, c);
    }
    b.legacyContext = d;
    X$1(a, b, f2);
    b.legacyContext = g2;
  } else X$1(a, b, f2);
}
function Fb(a, b) {
  if (a && a.defaultProps) {
    b = B$1({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
function Gb$1(a, b, c, d, f2) {
  if ("function" === typeof c) if (c.prototype && c.prototype.isReactComponent) {
    f2 = Za$1(c, b.legacyContext);
    var e2 = c.contextType;
    e2 = new c(d, "object" === typeof e2 && null !== e2 ? e2._currentValue2 : f2);
    eb$1(e2, c, d, f2);
    Eb$1(a, b, e2, c);
  } else {
    e2 = Za$1(c, b.legacyContext);
    f2 = Db$1(a, b, c, d, e2);
    var g2 = 0 !== N$1;
    if ("object" === typeof f2 && null !== f2 && "function" === typeof f2.render && void 0 === f2.$$typeof) eb$1(f2, c, d, e2), Eb$1(a, b, f2, c);
    else if (g2) {
      d = b.treeContext;
      b.treeContext = gb$1(d, 1, 0);
      try {
        X$1(a, b, f2);
      } finally {
        b.treeContext = d;
      }
    } else X$1(a, b, f2);
  }
  else if ("string" === typeof c) {
    f2 = b.blockedSegment;
    e2 = ya$1(f2.chunks, c, d, a.responseState, f2.formatContext);
    f2.lastPushedText = false;
    g2 = f2.formatContext;
    f2.formatContext = ra$1(g2, c, d);
    Hb$1(a, b, e2);
    f2.formatContext = g2;
    switch (c) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;
      default:
        f2.chunks.push("</", c, ">");
    }
    f2.lastPushedText = false;
  } else {
    switch (c) {
      case Ua$1:
      case Ta$1:
      case Ja$1:
      case Ka$1:
      case Ia$1:
        X$1(a, b, d.children);
        return;
      case Pa$1:
        X$1(a, b, d.children);
        return;
      case Sa$1:
        throw Error(l$2(343));
      case Oa$1:
        a: {
          c = b.blockedBoundary;
          f2 = b.blockedSegment;
          e2 = d.fallback;
          d = d.children;
          g2 = /* @__PURE__ */ new Set();
          var h2 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g2, errorDigest: null }, k2 = U$1(a, f2.chunks.length, h2, f2.formatContext, false, false);
          f2.children.push(k2);
          f2.lastPushedText = false;
          var m2 = U$1(a, 0, null, f2.formatContext, false, false);
          m2.parentFlushed = true;
          b.blockedBoundary = h2;
          b.blockedSegment = m2;
          try {
            if (Hb$1(
              a,
              b,
              d
            ), a.responseState.generateStaticMarkup || m2.lastPushedText && m2.textEmbedded && m2.chunks.push("<!-- -->"), m2.status = 1, Y$1(h2, m2), 0 === h2.pendingTasks) break a;
          } catch (n2) {
            m2.status = 4, h2.forceClientRender = true, h2.errorDigest = V$1(a, n2);
          } finally {
            b.blockedBoundary = c, b.blockedSegment = f2;
          }
          b = Bb$1(a, e2, c, k2, g2, b.legacyContext, b.context, b.treeContext);
          a.pingedTasks.push(b);
        }
        return;
    }
    if ("object" === typeof c && null !== c) switch (c.$$typeof) {
      case Na$1:
        d = Db$1(a, b, c.render, d, f2);
        if (0 !== N$1) {
          c = b.treeContext;
          b.treeContext = gb$1(c, 1, 0);
          try {
            X$1(a, b, d);
          } finally {
            b.treeContext = c;
          }
        } else X$1(a, b, d);
        return;
      case Qa$1:
        c = c.type;
        d = Fb(c, d);
        Gb$1(a, b, c, d, f2);
        return;
      case La$1:
        f2 = d.children;
        c = c._context;
        d = d.value;
        e2 = c._currentValue2;
        c._currentValue2 = d;
        g2 = E$1;
        E$1 = d = { parent: g2, depth: null === g2 ? 0 : g2.depth + 1, context: c, parentValue: e2, value: d };
        b.context = d;
        X$1(a, b, f2);
        a = E$1;
        if (null === a) throw Error(l$2(403));
        d = a.parentValue;
        a.context._currentValue2 = d === Va$1 ? a.context._defaultValue : d;
        a = E$1 = a.parent;
        b.context = a;
        return;
      case Ma$1:
        d = d.children;
        d = d(c._currentValue2);
        X$1(a, b, d);
        return;
      case Ra$1:
        f2 = c._init;
        c = f2(c._payload);
        d = Fb(c, d);
        Gb$1(
          a,
          b,
          c,
          d,
          void 0
        );
        return;
    }
    throw Error(l$2(130, null == c ? c : typeof c, ""));
  }
}
function X$1(a, b, c) {
  b.node = c;
  if ("object" === typeof c && null !== c) {
    switch (c.$$typeof) {
      case Ga$1:
        Gb$1(a, b, c.type, c.props, c.ref);
        return;
      case Ha$1:
        throw Error(l$2(257));
      case Ra$1:
        var d = c._init;
        c = d(c._payload);
        X$1(a, b, c);
        return;
    }
    if (qa$1(c)) {
      Ib$1(a, b, c);
      return;
    }
    null === c || "object" !== typeof c ? d = null : (d = Wa$1 && c[Wa$1] || c["@@iterator"], d = "function" === typeof d ? d : null);
    if (d && (d = d.call(c))) {
      c = d.next();
      if (!c.done) {
        var f2 = [];
        do
          f2.push(c.value), c = d.next();
        while (!c.done);
        Ib$1(a, b, f2);
      }
      return;
    }
    a = Object.prototype.toString.call(c);
    throw Error(l$2(31, "[object Object]" === a ? "object with keys {" + Object.keys(c).join(", ") + "}" : a));
  }
  "string" === typeof c ? (d = b.blockedSegment, d.lastPushedText = Fa$1(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : "number" === typeof c && (d = b.blockedSegment, d.lastPushedText = Fa$1(b.blockedSegment.chunks, "" + c, a.responseState, d.lastPushedText));
}
function Ib$1(a, b, c) {
  for (var d = c.length, f2 = 0; f2 < d; f2++) {
    var e2 = b.treeContext;
    b.treeContext = gb$1(e2, d, f2);
    try {
      Hb$1(a, b, c[f2]);
    } finally {
      b.treeContext = e2;
    }
  }
}
function Hb$1(a, b, c) {
  var d = b.blockedSegment.formatContext, f2 = b.legacyContext, e2 = b.context;
  try {
    return X$1(a, b, c);
  } catch (k2) {
    if (rb$1(), "object" === typeof k2 && null !== k2 && "function" === typeof k2.then) {
      c = k2;
      var g2 = b.blockedSegment, h2 = U$1(a, g2.chunks.length, null, g2.formatContext, g2.lastPushedText, true);
      g2.children.push(h2);
      g2.lastPushedText = false;
      a = Bb$1(a, b.node, b.blockedBoundary, h2, b.abortSet, b.legacyContext, b.context, b.treeContext).ping;
      c.then(a, a);
      b.blockedSegment.formatContext = d;
      b.legacyContext = f2;
      b.context = e2;
      G(e2);
    } else throw b.blockedSegment.formatContext = d, b.legacyContext = f2, b.context = e2, G(e2), k2;
  }
}
function Jb$1(a) {
  var b = a.blockedBoundary;
  a = a.blockedSegment;
  a.status = 3;
  Kb$1(this, b, a);
}
function Lb$1(a, b, c) {
  var d = a.blockedBoundary;
  a.blockedSegment.status = 3;
  null === d ? (b.allPendingTasks--, 2 !== b.status && (b.status = 2, null !== b.destination && b.destination.push(null))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = true, a = void 0 === c ? Error(l$2(432)) : c, d.errorDigest = b.onError(a), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
    return Lb$1(a2, b, c);
  }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (d = b.onAllReady, d()));
}
function Y$1(a, b) {
  if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
    var c = b.children[0];
    c.id = b.id;
    c.parentFlushed = true;
    1 === c.status && Y$1(a, c);
  } else a.completedSegments.push(b);
}
function Kb$1(a, b, c) {
  if (null === b) {
    if (c.parentFlushed) {
      if (null !== a.completedRootSegment) throw Error(l$2(389));
      a.completedRootSegment = c;
    }
    a.pendingRootTasks--;
    0 === a.pendingRootTasks && (a.onShellError = T$1, b = a.onShellReady, b());
  } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && Y$1(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Jb$1, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (Y$1(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));
  a.allPendingTasks--;
  0 === a.allPendingTasks && (a = a.onAllReady, a());
}
function Cb$1(a) {
  if (2 !== a.status) {
    var b = E$1, c = yb$1.current;
    yb$1.current = xb$1;
    var d = S$1;
    S$1 = a.responseState;
    try {
      var f2 = a.pingedTasks, e2;
      for (e2 = 0; e2 < f2.length; e2++) {
        var g2 = f2[e2];
        var h2 = a, k2 = g2.blockedSegment;
        if (0 === k2.status) {
          G(g2.context);
          try {
            X$1(h2, g2, g2.node), h2.responseState.generateStaticMarkup || k2.lastPushedText && k2.textEmbedded && k2.chunks.push("<!-- -->"), g2.abortSet.delete(g2), k2.status = 1, Kb$1(h2, g2.blockedBoundary, k2);
          } catch (z2) {
            if (rb$1(), "object" === typeof z2 && null !== z2 && "function" === typeof z2.then) {
              var m2 = g2.ping;
              z2.then(m2, m2);
            } else {
              g2.abortSet.delete(g2);
              k2.status = 4;
              var n2 = g2.blockedBoundary, q2 = z2, C2 = V$1(h2, q2);
              null === n2 ? W$1(h2, q2) : (n2.pendingTasks--, n2.forceClientRender || (n2.forceClientRender = true, n2.errorDigest = C2, n2.parentFlushed && h2.clientRenderedBoundaries.push(n2)));
              h2.allPendingTasks--;
              if (0 === h2.allPendingTasks) {
                var D2 = h2.onAllReady;
                D2();
              }
            }
          } finally {
          }
        }
      }
      f2.splice(0, e2);
      null !== a.destination && Mb$1(a, a.destination);
    } catch (z2) {
      V$1(a, z2), W$1(a, z2);
    } finally {
      S$1 = d, yb$1.current = c, c === xb$1 && G(b);
    }
  }
}
function Z$1(a, b, c) {
  c.parentFlushed = true;
  switch (c.status) {
    case 0:
      var d = c.id = a.nextSegmentId++;
      c.lastPushedText = false;
      c.textEmbedded = false;
      a = a.responseState;
      b.push('<template id="');
      b.push(a.placeholderPrefix);
      a = d.toString(16);
      b.push(a);
      return b.push('"></template>');
    case 1:
      c.status = 2;
      var f2 = true;
      d = c.chunks;
      var e2 = 0;
      c = c.children;
      for (var g2 = 0; g2 < c.length; g2++) {
        for (f2 = c[g2]; e2 < f2.index; e2++) b.push(d[e2]);
        f2 = Nb$1(a, b, f2);
      }
      for (; e2 < d.length - 1; e2++) b.push(d[e2]);
      e2 < d.length && (f2 = b.push(d[e2]));
      return f2;
    default:
      throw Error(l$2(390));
  }
}
function Nb$1(a, b, c) {
  var d = c.boundary;
  if (null === d) return Z$1(a, b, c);
  d.parentFlushed = true;
  if (d.forceClientRender) return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("<!--$!-->"), b.push("<template"), d && (b.push(' data-dgst="'), d = v(d), b.push(d), b.push('"')), b.push("></template>")), Z$1(a, b, c), a = a.responseState.generateStaticMarkup ? true : b.push("<!--/$-->"), a;
  if (0 < d.pendingTasks) {
    d.rootSegmentID = a.nextSegmentId++;
    0 < d.completedSegments.length && a.partialBoundaries.push(d);
    var f2 = a.responseState;
    var e2 = f2.nextSuspenseID++;
    f2 = f2.boundaryPrefix + e2.toString(16);
    d = d.id = f2;
    za$1(b, a.responseState, d);
    Z$1(a, b, c);
    return b.push("<!--/$-->");
  }
  if (d.byteSize > a.progressiveChunkSize) return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), za$1(b, a.responseState, d.id), Z$1(a, b, c), b.push("<!--/$-->");
  a.responseState.generateStaticMarkup || b.push("<!--$-->");
  c = d.completedSegments;
  if (1 !== c.length) throw Error(l$2(391));
  Nb$1(a, b, c[0]);
  a = a.responseState.generateStaticMarkup ? true : b.push("<!--/$-->");
  return a;
}
function Ob$1(a, b, c) {
  Aa$1(b, a.responseState, c.formatContext, c.id);
  Nb$1(a, b, c);
  return Ba$1(b, c.formatContext);
}
function Pb$1(a, b, c) {
  for (var d = c.completedSegments, f2 = 0; f2 < d.length; f2++) Qb$1(a, b, c, d[f2]);
  d.length = 0;
  a = a.responseState;
  d = c.id;
  c = c.rootSegmentID;
  b.push(a.startInlineScript);
  a.sentCompleteBoundaryFunction ? b.push('$RC("') : (a.sentCompleteBoundaryFunction = true, b.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
  if (null === d) throw Error(l$2(395));
  c = c.toString(16);
  b.push(d);
  b.push('","');
  b.push(a.segmentPrefix);
  b.push(c);
  return b.push('")<\/script>');
}
function Qb$1(a, b, c, d) {
  if (2 === d.status) return true;
  var f2 = d.id;
  if (-1 === f2) {
    if (-1 === (d.id = c.rootSegmentID)) throw Error(l$2(392));
    return Ob$1(a, b, d);
  }
  Ob$1(a, b, d);
  a = a.responseState;
  b.push(a.startInlineScript);
  a.sentCompleteSegmentFunction ? b.push('$RS("') : (a.sentCompleteSegmentFunction = true, b.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
  b.push(a.segmentPrefix);
  f2 = f2.toString(16);
  b.push(f2);
  b.push('","');
  b.push(a.placeholderPrefix);
  b.push(f2);
  return b.push('")<\/script>');
}
function Mb$1(a, b) {
  try {
    var c = a.completedRootSegment;
    if (null !== c && 0 === a.pendingRootTasks) {
      Nb$1(a, b, c);
      a.completedRootSegment = null;
      var d = a.responseState.bootstrapChunks;
      for (c = 0; c < d.length - 1; c++) b.push(d[c]);
      c < d.length && b.push(d[c]);
    }
    var f2 = a.clientRenderedBoundaries, e2;
    for (e2 = 0; e2 < f2.length; e2++) {
      var g2 = f2[e2];
      d = b;
      var h2 = a.responseState, k2 = g2.id, m2 = g2.errorDigest, n2 = g2.errorMessage, q2 = g2.errorComponentStack;
      d.push(h2.startInlineScript);
      h2.sentClientRenderFunction ? d.push('$RX("') : (h2.sentClientRenderFunction = true, d.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
      if (null === k2) throw Error(l$2(395));
      d.push(k2);
      d.push('"');
      if (m2 || n2 || q2) {
        d.push(",");
        var C2 = Da$1(m2 || "");
        d.push(C2);
      }
      if (n2 || q2) {
        d.push(",");
        var D2 = Da$1(n2 || "");
        d.push(D2);
      }
      if (q2) {
        d.push(",");
        var z2 = Da$1(q2);
        d.push(z2);
      }
      if (!d.push(")<\/script>")) {
        a.destination = null;
        e2++;
        f2.splice(0, e2);
        return;
      }
    }
    f2.splice(0, e2);
    var ba2 = a.completedBoundaries;
    for (e2 = 0; e2 < ba2.length; e2++) if (!Pb$1(a, b, ba2[e2])) {
      a.destination = null;
      e2++;
      ba2.splice(0, e2);
      return;
    }
    ba2.splice(0, e2);
    var ca2 = a.partialBoundaries;
    for (e2 = 0; e2 < ca2.length; e2++) {
      var mb2 = ca2[e2];
      a: {
        f2 = a;
        g2 = b;
        var da2 = mb2.completedSegments;
        for (h2 = 0; h2 < da2.length; h2++) if (!Qb$1(f2, g2, mb2, da2[h2])) {
          h2++;
          da2.splice(0, h2);
          var nb2 = false;
          break a;
        }
        da2.splice(0, h2);
        nb2 = true;
      }
      if (!nb2) {
        a.destination = null;
        e2++;
        ca2.splice(0, e2);
        return;
      }
    }
    ca2.splice(0, e2);
    var ea2 = a.completedBoundaries;
    for (e2 = 0; e2 < ea2.length; e2++) if (!Pb$1(a, b, ea2[e2])) {
      a.destination = null;
      e2++;
      ea2.splice(0, e2);
      return;
    }
    ea2.splice(0, e2);
  } finally {
    0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && b.push(null);
  }
}
function Rb$1(a, b) {
  try {
    var c = a.abortableTasks;
    c.forEach(function(c2) {
      return Lb$1(c2, a, b);
    });
    c.clear();
    null !== a.destination && Mb$1(a, a.destination);
  } catch (d) {
    V$1(a, d), W$1(a, d);
  }
}
function Sb$1() {
}
function Tb$1(a, b, c, d) {
  var f2 = false, e2 = null, g2 = "", h2 = { push: function(a2) {
    null !== a2 && (g2 += a2);
    return true;
  }, destroy: function(a2) {
    f2 = true;
    e2 = a2;
  } }, k2 = false;
  a = Ab$1(a, Ea$1(c, b ? b.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, Infinity, Sb$1, void 0, function() {
    k2 = true;
  });
  Cb$1(a);
  Rb$1(a, d);
  if (1 === a.status) a.status = 2, h2.destroy(a.fatalError);
  else if (2 !== a.status && null === a.destination) {
    a.destination = h2;
    try {
      Mb$1(a, h2);
    } catch (m2) {
      V$1(a, m2), W$1(a, m2);
    }
  }
  if (f2) throw e2;
  if (!k2) throw Error(l$2(426));
  return g2;
}
reactDomServerLegacy_browser_production_min.renderToNodeStream = function() {
  throw Error(l$2(207));
};
reactDomServerLegacy_browser_production_min.renderToStaticMarkup = function(a, b) {
  return Tb$1(a, b, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
};
reactDomServerLegacy_browser_production_min.renderToStaticNodeStream = function() {
  throw Error(l$2(208));
};
reactDomServerLegacy_browser_production_min.renderToString = function(a, b) {
  return Tb$1(a, b, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
};
reactDomServerLegacy_browser_production_min.version = "18.3.1";
var reactDomServer_browser_production_min = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports;
function k(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var l$1 = null, n = 0;
function p(a, b) {
  if (0 !== b.length) if (512 < b.length) 0 < n && (a.enqueue(new Uint8Array(l$1.buffer, 0, n)), l$1 = new Uint8Array(512), n = 0), a.enqueue(b);
  else {
    var c = l$1.length - n;
    c < b.length && (0 === c ? a.enqueue(l$1) : (l$1.set(b.subarray(0, c), n), a.enqueue(l$1), b = b.subarray(c)), l$1 = new Uint8Array(512), n = 0);
    l$1.set(b, n);
    n += b.length;
  }
}
function t(a, b) {
  p(a, b);
  return true;
}
function ba(a) {
  l$1 && 0 < n && (a.enqueue(new Uint8Array(l$1.buffer, 0, n)), l$1 = null, n = 0);
}
var ca = new TextEncoder();
function u(a) {
  return ca.encode(a);
}
function w(a) {
  return ca.encode(a);
}
function da(a, b) {
  "function" === typeof a.error ? a.error(b) : a.close();
}
var x = Object.prototype.hasOwnProperty, ea = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, fa = {}, ha = {};
function ia(a) {
  if (x.call(ha, a)) return true;
  if (x.call(fa, a)) return false;
  if (ea.test(a)) return ha[a] = true;
  fa[a] = true;
  return false;
}
function y(a, b, c, d, f2, e2, g2) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = f2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = e2;
  this.removeEmptyString = g2;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z[a] = new y(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  z[b] = new y(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z[a] = new y(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z[a] = new y(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z[a] = new y(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z[a] = new y(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z[a] = new y(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z[a] = new y(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z[a] = new y(a, 5, false, a.toLowerCase(), null, false, false);
});
var ja = /[\-:]([a-z])/g;
function ka(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ja,
    ka
  );
  z[b] = new y(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ja, ka);
  z[b] = new y(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ja, ka);
  z[b] = new y(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z[a] = new y(a, 1, false, a.toLowerCase(), null, false, false);
});
z.xlinkHref = new y("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z[a] = new y(a, 1, false, a.toLowerCase(), null, true, true);
});
var B = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, la = ["Webkit", "ms", "Moz", "O"];
Object.keys(B).forEach(function(a) {
  la.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    B[b] = B[a];
  });
});
var oa = /["'&<>]/;
function C(a) {
  if ("boolean" === typeof a || "number" === typeof a) return "" + a;
  a = "" + a;
  var b = oa.exec(a);
  if (b) {
    var c = "", d, f2 = 0;
    for (d = b.index; d < a.length; d++) {
      switch (a.charCodeAt(d)) {
        case 34:
          b = "&quot;";
          break;
        case 38:
          b = "&amp;";
          break;
        case 39:
          b = "&#x27;";
          break;
        case 60:
          b = "&lt;";
          break;
        case 62:
          b = "&gt;";
          break;
        default:
          continue;
      }
      f2 !== d && (c += a.substring(f2, d));
      f2 = d + 1;
      c += b;
    }
    a = f2 !== d ? c + a.substring(f2, d) : c;
  }
  return a;
}
var pa = /([A-Z])/g, qa = /^ms-/, ra = Array.isArray, sa = w("<script>"), ta = w("<\/script>"), ua = w('<script src="'), va = w('<script type="module" src="'), wa = w('" async=""><\/script>'), xa = /(<\/|<)(s)(cript)/gi;
function ya(a, b, c, d) {
  return "" + b + ("s" === c ? "\\u0073" : "\\u0053") + d;
}
function za(a, b, c, d, f2) {
  a = void 0 === a ? "" : a;
  b = void 0 === b ? sa : w('<script nonce="' + C(b) + '">');
  var e2 = [];
  void 0 !== c && e2.push(b, u(("" + c).replace(xa, ya)), ta);
  if (void 0 !== d) for (c = 0; c < d.length; c++) e2.push(ua, u(C(d[c])), wa);
  if (void 0 !== f2) for (d = 0; d < f2.length; d++) e2.push(va, u(C(f2[d])), wa);
  return { bootstrapChunks: e2, startInlineScript: b, placeholderPrefix: w(a + "P:"), segmentPrefix: w(a + "S:"), boundaryPrefix: a + "B:", idPrefix: a, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false };
}
function D(a, b) {
  return { insertionMode: a, selectedValue: b };
}
function Aa(a) {
  return D("http://www.w3.org/2000/svg" === a ? 2 : "http://www.w3.org/1998/Math/MathML" === a ? 3 : 0, null);
}
function Ba(a, b, c) {
  switch (b) {
    case "select":
      return D(1, null != c.value ? c.value : c.defaultValue);
    case "svg":
      return D(2, null);
    case "math":
      return D(3, null);
    case "foreignObject":
      return D(1, null);
    case "table":
      return D(4, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return D(5, null);
    case "colgroup":
      return D(7, null);
    case "tr":
      return D(6, null);
  }
  return 4 <= a.insertionMode || 0 === a.insertionMode ? D(1, null) : a;
}
var Ca = w("<!-- -->");
function Da(a, b, c, d) {
  if ("" === b) return d;
  d && a.push(Ca);
  a.push(u(C(b)));
  return true;
}
var Ea = /* @__PURE__ */ new Map(), Fa = w(' style="'), Ga = w(":"), Ha = w(";");
function Ia(a, b, c) {
  if ("object" !== typeof c) throw Error(k(62));
  b = true;
  for (var d in c) if (x.call(c, d)) {
    var f2 = c[d];
    if (null != f2 && "boolean" !== typeof f2 && "" !== f2) {
      if (0 === d.indexOf("--")) {
        var e2 = u(C(d));
        f2 = u(C(("" + f2).trim()));
      } else {
        e2 = d;
        var g2 = Ea.get(e2);
        void 0 !== g2 ? e2 = g2 : (g2 = w(C(e2.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-"))), Ea.set(e2, g2), e2 = g2);
        f2 = "number" === typeof f2 ? 0 === f2 || x.call(B, d) ? u("" + f2) : u(f2 + "px") : u(C(("" + f2).trim()));
      }
      b ? (b = false, a.push(Fa, e2, Ga, f2)) : a.push(Ha, e2, Ga, f2);
    }
  }
  b || a.push(E);
}
var H = w(" "), I = w('="'), E = w('"'), Ja = w('=""');
function J(a, b, c, d) {
  switch (c) {
    case "style":
      Ia(a, b, d);
      return;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
      return;
  }
  if (!(2 < c.length) || "o" !== c[0] && "O" !== c[0] || "n" !== c[1] && "N" !== c[1]) {
    if (b = z.hasOwnProperty(c) ? z[c] : null, null !== b) {
      switch (typeof d) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (!b.acceptsBooleans) return;
      }
      c = u(b.attributeName);
      switch (b.type) {
        case 3:
          d && a.push(H, c, Ja);
          break;
        case 4:
          true === d ? a.push(H, c, Ja) : false !== d && a.push(H, c, I, u(C(d)), E);
          break;
        case 5:
          isNaN(d) || a.push(H, c, I, u(C(d)), E);
          break;
        case 6:
          !isNaN(d) && 1 <= d && a.push(H, c, I, u(C(d)), E);
          break;
        default:
          b.sanitizeURL && (d = "" + d), a.push(H, c, I, u(C(d)), E);
      }
    } else if (ia(c)) {
      switch (typeof d) {
        case "function":
        case "symbol":
          return;
        case "boolean":
          if (b = c.toLowerCase().slice(0, 5), "data-" !== b && "aria-" !== b) return;
      }
      a.push(H, u(c), I, u(C(d)), E);
    }
  }
}
var K = w(">"), Ka = w("/>");
function L$1(a, b, c) {
  if (null != b) {
    if (null != c) throw Error(k(60));
    if ("object" !== typeof b || !("__html" in b)) throw Error(k(61));
    b = b.__html;
    null !== b && void 0 !== b && a.push(u("" + b));
  }
}
function La(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    null != a2 && (b += a2);
  });
  return b;
}
var Ma = w(' selected=""');
function Na(a, b, c, d) {
  a.push(M(c));
  var f2 = c = null, e2;
  for (e2 in b) if (x.call(b, e2)) {
    var g2 = b[e2];
    if (null != g2) switch (e2) {
      case "children":
        c = g2;
        break;
      case "dangerouslySetInnerHTML":
        f2 = g2;
        break;
      default:
        J(a, d, e2, g2);
    }
  }
  a.push(K);
  L$1(a, f2, c);
  return "string" === typeof c ? (a.push(u(C(c))), null) : c;
}
var Oa = w("\n"), Pa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Qa = /* @__PURE__ */ new Map();
function M(a) {
  var b = Qa.get(a);
  if (void 0 === b) {
    if (!Pa.test(a)) throw Error(k(65, a));
    b = w("<" + a);
    Qa.set(a, b);
  }
  return b;
}
var Ra = w("<!DOCTYPE html>");
function Sa(a, b, c, d, f2) {
  switch (b) {
    case "select":
      a.push(M("select"));
      var e2 = null, g2 = null;
      for (r2 in c) if (x.call(c, r2)) {
        var h2 = c[r2];
        if (null != h2) switch (r2) {
          case "children":
            e2 = h2;
            break;
          case "dangerouslySetInnerHTML":
            g2 = h2;
            break;
          case "defaultValue":
          case "value":
            break;
          default:
            J(a, d, r2, h2);
        }
      }
      a.push(K);
      L$1(a, g2, e2);
      return e2;
    case "option":
      g2 = f2.selectedValue;
      a.push(M("option"));
      var m2 = h2 = null, q2 = null;
      var r2 = null;
      for (e2 in c) if (x.call(c, e2)) {
        var v2 = c[e2];
        if (null != v2) switch (e2) {
          case "children":
            h2 = v2;
            break;
          case "selected":
            q2 = v2;
            break;
          case "dangerouslySetInnerHTML":
            r2 = v2;
            break;
          case "value":
            m2 = v2;
          default:
            J(a, d, e2, v2);
        }
      }
      if (null != g2) if (c = null !== m2 ? "" + m2 : La(h2), ra(g2)) for (d = 0; d < g2.length; d++) {
        if ("" + g2[d] === c) {
          a.push(Ma);
          break;
        }
      }
      else "" + g2 === c && a.push(Ma);
      else q2 && a.push(Ma);
      a.push(K);
      L$1(a, r2, h2);
      return h2;
    case "textarea":
      a.push(M("textarea"));
      r2 = g2 = e2 = null;
      for (h2 in c) if (x.call(c, h2) && (m2 = c[h2], null != m2)) switch (h2) {
        case "children":
          r2 = m2;
          break;
        case "value":
          e2 = m2;
          break;
        case "defaultValue":
          g2 = m2;
          break;
        case "dangerouslySetInnerHTML":
          throw Error(k(91));
        default:
          J(a, d, h2, m2);
      }
      null === e2 && null !== g2 && (e2 = g2);
      a.push(K);
      if (null != r2) {
        if (null != e2) throw Error(k(92));
        if (ra(r2) && 1 < r2.length) throw Error(k(93));
        e2 = "" + r2;
      }
      "string" === typeof e2 && "\n" === e2[0] && a.push(Oa);
      null !== e2 && a.push(u(C("" + e2)));
      return null;
    case "input":
      a.push(M("input"));
      m2 = r2 = h2 = e2 = null;
      for (g2 in c) if (x.call(c, g2) && (q2 = c[g2], null != q2)) switch (g2) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(k(399, "input"));
        case "defaultChecked":
          m2 = q2;
          break;
        case "defaultValue":
          h2 = q2;
          break;
        case "checked":
          r2 = q2;
          break;
        case "value":
          e2 = q2;
          break;
        default:
          J(a, d, g2, q2);
      }
      null !== r2 ? J(
        a,
        d,
        "checked",
        r2
      ) : null !== m2 && J(a, d, "checked", m2);
      null !== e2 ? J(a, d, "value", e2) : null !== h2 && J(a, d, "value", h2);
      a.push(Ka);
      return null;
    case "menuitem":
      a.push(M("menuitem"));
      for (var A2 in c) if (x.call(c, A2) && (e2 = c[A2], null != e2)) switch (A2) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(k(400));
        default:
          J(a, d, A2, e2);
      }
      a.push(K);
      return null;
    case "title":
      a.push(M("title"));
      e2 = null;
      for (v2 in c) if (x.call(c, v2) && (g2 = c[v2], null != g2)) switch (v2) {
        case "children":
          e2 = g2;
          break;
        case "dangerouslySetInnerHTML":
          throw Error(k(434));
        default:
          J(a, d, v2, g2);
      }
      a.push(K);
      return e2;
    case "listing":
    case "pre":
      a.push(M(b));
      g2 = e2 = null;
      for (m2 in c) if (x.call(c, m2) && (h2 = c[m2], null != h2)) switch (m2) {
        case "children":
          e2 = h2;
          break;
        case "dangerouslySetInnerHTML":
          g2 = h2;
          break;
        default:
          J(a, d, m2, h2);
      }
      a.push(K);
      if (null != g2) {
        if (null != e2) throw Error(k(60));
        if ("object" !== typeof g2 || !("__html" in g2)) throw Error(k(61));
        c = g2.__html;
        null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push(Oa, u(c)) : a.push(u("" + c)));
      }
      "string" === typeof e2 && "\n" === e2[0] && a.push(Oa);
      return e2;
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "img":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      a.push(M(b));
      for (var F2 in c) if (x.call(c, F2) && (e2 = c[F2], null != e2)) switch (F2) {
        case "children":
        case "dangerouslySetInnerHTML":
          throw Error(k(399, b));
        default:
          J(a, d, F2, e2);
      }
      a.push(Ka);
      return null;
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return Na(a, c, b, d);
    case "html":
      return 0 === f2.insertionMode && a.push(Ra), Na(a, c, b, d);
    default:
      if (-1 === b.indexOf("-") && "string" !== typeof c.is) return Na(a, c, b, d);
      a.push(M(b));
      g2 = e2 = null;
      for (q2 in c) if (x.call(c, q2) && (h2 = c[q2], null != h2)) switch (q2) {
        case "children":
          e2 = h2;
          break;
        case "dangerouslySetInnerHTML":
          g2 = h2;
          break;
        case "style":
          Ia(a, d, h2);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          break;
        default:
          ia(q2) && "function" !== typeof h2 && "symbol" !== typeof h2 && a.push(H, u(q2), I, u(C(h2)), E);
      }
      a.push(K);
      L$1(a, g2, e2);
      return e2;
  }
}
var Ta = w("</"), Ua = w(">"), Va = w('<template id="'), Wa = w('"></template>'), Xa = w("<!--$-->"), Ya = w('<!--$?--><template id="'), Za = w('"></template>'), $a = w("<!--$!-->"), ab = w("<!--/$-->"), bb = w("<template"), cb = w('"'), db = w(' data-dgst="');
w(' data-msg="');
w(' data-stck="');
var eb = w("></template>");
function fb(a, b, c) {
  p(a, Ya);
  if (null === c) throw Error(k(395));
  p(a, c);
  return t(a, Za);
}
var gb = w('<div hidden id="'), hb = w('">'), ib = w("</div>"), jb = w('<svg aria-hidden="true" style="display:none" id="'), kb = w('">'), lb = w("</svg>"), mb = w('<math aria-hidden="true" style="display:none" id="'), nb = w('">'), ob = w("</math>"), pb = w('<table hidden id="'), qb = w('">'), rb = w("</table>"), sb = w('<table hidden><tbody id="'), tb = w('">'), ub = w("</tbody></table>"), vb = w('<table hidden><tr id="'), wb = w('">'), xb = w("</tr></table>"), yb = w('<table hidden><colgroup id="'), zb = w('">'), Ab = w("</colgroup></table>");
function Bb(a, b, c, d) {
  switch (c.insertionMode) {
    case 0:
    case 1:
      return p(a, gb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, hb);
    case 2:
      return p(a, jb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, kb);
    case 3:
      return p(a, mb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, nb);
    case 4:
      return p(a, pb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, qb);
    case 5:
      return p(a, sb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, tb);
    case 6:
      return p(a, vb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, wb);
    case 7:
      return p(
        a,
        yb
      ), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, zb);
    default:
      throw Error(k(397));
  }
}
function Cb(a, b) {
  switch (b.insertionMode) {
    case 0:
    case 1:
      return t(a, ib);
    case 2:
      return t(a, lb);
    case 3:
      return t(a, ob);
    case 4:
      return t(a, rb);
    case 5:
      return t(a, ub);
    case 6:
      return t(a, xb);
    case 7:
      return t(a, Ab);
    default:
      throw Error(k(397));
  }
}
var Db = w('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Eb = w('$RS("'), Gb = w('","'), Hb = w('")<\/script>'), Ib = w('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Jb = w('$RC("'), Kb = w('","'), Lb = w('")<\/script>'), Mb = w('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Nb = w('$RX("'), Ob = w('"'), Pb = w(")<\/script>"), Qb = w(","), Rb = /[<\u2028\u2029]/g;
function Sb(a) {
  return JSON.stringify(a).replace(Rb, function(a2) {
    switch (a2) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
var N = Object.assign, Tb = Symbol.for("react.element"), Ub = Symbol.for("react.portal"), Vb = Symbol.for("react.fragment"), Wb = Symbol.for("react.strict_mode"), Xb = Symbol.for("react.profiler"), Yb = Symbol.for("react.provider"), Zb = Symbol.for("react.context"), $b = Symbol.for("react.forward_ref"), ac = Symbol.for("react.suspense"), bc = Symbol.for("react.suspense_list"), cc = Symbol.for("react.memo"), dc = Symbol.for("react.lazy"), ec = Symbol.for("react.scope"), fc = Symbol.for("react.debug_trace_mode"), gc = Symbol.for("react.legacy_hidden"), hc = Symbol.for("react.default_value"), ic = Symbol.iterator;
function jc(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case Vb:
      return "Fragment";
    case Ub:
      return "Portal";
    case Xb:
      return "Profiler";
    case Wb:
      return "StrictMode";
    case ac:
      return "Suspense";
    case bc:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Zb:
      return (a.displayName || "Context") + ".Consumer";
    case Yb:
      return (a._context.displayName || "Context") + ".Provider";
    case $b:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case cc:
      return b = a.displayName || null, null !== b ? b : jc(a.type) || "Memo";
    case dc:
      b = a._payload;
      a = a._init;
      try {
        return jc(a(b));
      } catch (c) {
      }
  }
  return null;
}
var kc = {};
function lc(a, b) {
  a = a.contextTypes;
  if (!a) return kc;
  var c = {}, d;
  for (d in a) c[d] = b[d];
  return c;
}
var O = null;
function P(a, b) {
  if (a !== b) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    var c = b.parent;
    if (null === a) {
      if (null !== c) throw Error(k(401));
    } else {
      if (null === c) throw Error(k(401));
      P(a, c);
    }
    b.context._currentValue = b.value;
  }
}
function mc(a) {
  a.context._currentValue = a.parentValue;
  a = a.parent;
  null !== a && mc(a);
}
function nc(a) {
  var b = a.parent;
  null !== b && nc(b);
  a.context._currentValue = a.value;
}
function oc(a, b) {
  a.context._currentValue = a.parentValue;
  a = a.parent;
  if (null === a) throw Error(k(402));
  a.depth === b.depth ? P(a, b) : oc(a, b);
}
function pc(a, b) {
  var c = b.parent;
  if (null === c) throw Error(k(402));
  a.depth === c.depth ? P(a, c) : pc(a, c);
  b.context._currentValue = b.value;
}
function Q(a) {
  var b = O;
  b !== a && (null === b ? nc(a) : null === a ? mc(b) : b.depth === a.depth ? P(b, a) : b.depth > a.depth ? oc(b, a) : pc(b, a), O = a);
}
var qc = { isMounted: function() {
  return false;
}, enqueueSetState: function(a, b) {
  a = a._reactInternals;
  null !== a.queue && a.queue.push(b);
}, enqueueReplaceState: function(a, b) {
  a = a._reactInternals;
  a.replace = true;
  a.queue = [b];
}, enqueueForceUpdate: function() {
} };
function rc(a, b, c, d) {
  var f2 = void 0 !== a.state ? a.state : null;
  a.updater = qc;
  a.props = c;
  a.state = f2;
  var e2 = { queue: [], replace: false };
  a._reactInternals = e2;
  var g2 = b.contextType;
  a.context = "object" === typeof g2 && null !== g2 ? g2._currentValue : d;
  g2 = b.getDerivedStateFromProps;
  "function" === typeof g2 && (g2 = g2(c, f2), f2 = null === g2 || void 0 === g2 ? f2 : N({}, f2, g2), a.state = f2);
  if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && qc.enqueueReplaceState(a, a.state, null), null !== e2.queue && 0 < e2.queue.length) if (b = e2.queue, g2 = e2.replace, e2.queue = null, e2.replace = false, g2 && 1 === b.length) a.state = b[0];
  else {
    e2 = g2 ? b[0] : a.state;
    f2 = true;
    for (g2 = g2 ? 1 : 0; g2 < b.length; g2++) {
      var h2 = b[g2];
      h2 = "function" === typeof h2 ? h2.call(a, e2, c, d) : h2;
      null != h2 && (f2 ? (f2 = false, e2 = N({}, e2, h2)) : N(e2, h2));
    }
    a.state = e2;
  }
  else e2.queue = null;
}
var sc = { id: 1, overflow: "" };
function tc(a, b, c) {
  var d = a.id;
  a = a.overflow;
  var f2 = 32 - uc(d) - 1;
  d &= ~(1 << f2);
  c += 1;
  var e2 = 32 - uc(b) + f2;
  if (30 < e2) {
    var g2 = f2 - f2 % 5;
    e2 = (d & (1 << g2) - 1).toString(32);
    d >>= g2;
    f2 -= g2;
    return { id: 1 << 32 - uc(b) + f2 | c << f2 | d, overflow: e2 + a };
  }
  return { id: 1 << e2 | c << f2 | d, overflow: a };
}
var uc = Math.clz32 ? Math.clz32 : vc, wc = Math.log, xc = Math.LN2;
function vc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (wc(a) / xc | 0) | 0;
}
function yc(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var zc = "function" === typeof Object.is ? Object.is : yc, R = null, Ac = null, Bc = null, S = null, T = false, Cc = false, U = 0, V = null, Dc = 0;
function W() {
  if (null === R) throw Error(k(321));
  return R;
}
function Ec() {
  if (0 < Dc) throw Error(k(312));
  return { memoizedState: null, queue: null, next: null };
}
function Fc() {
  null === S ? null === Bc ? (T = false, Bc = S = Ec()) : (T = true, S = Bc) : null === S.next ? (T = false, S = S.next = Ec()) : (T = true, S = S.next);
  return S;
}
function Gc() {
  Ac = R = null;
  Cc = false;
  Bc = null;
  Dc = 0;
  S = V = null;
}
function Hc(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Ic(a, b, c) {
  R = W();
  S = Fc();
  if (T) {
    var d = S.queue;
    b = d.dispatch;
    if (null !== V && (c = V.get(d), void 0 !== c)) {
      V.delete(d);
      d = S.memoizedState;
      do
        d = a(d, c.action), c = c.next;
      while (null !== c);
      S.memoizedState = d;
      return [d, b];
    }
    return [S.memoizedState, b];
  }
  a = a === Hc ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
  S.memoizedState = a;
  a = S.queue = { last: null, dispatch: null };
  a = a.dispatch = Jc.bind(null, R, a);
  return [S.memoizedState, a];
}
function Kc(a, b) {
  R = W();
  S = Fc();
  b = void 0 === b ? null : b;
  if (null !== S) {
    var c = S.memoizedState;
    if (null !== c && null !== b) {
      var d = c[1];
      a: if (null === d) d = false;
      else {
        for (var f2 = 0; f2 < d.length && f2 < b.length; f2++) if (!zc(b[f2], d[f2])) {
          d = false;
          break a;
        }
        d = true;
      }
      if (d) return c[0];
    }
  }
  a = a();
  S.memoizedState = [a, b];
  return a;
}
function Jc(a, b, c) {
  if (25 <= Dc) throw Error(k(301));
  if (a === R) if (Cc = true, a = { action: c, next: null }, null === V && (V = /* @__PURE__ */ new Map()), c = V.get(b), void 0 === c) V.set(b, a);
  else {
    for (b = c; null !== b.next; ) b = b.next;
    b.next = a;
  }
}
function Lc() {
  throw Error(k(394));
}
function Mc() {
}
var Oc = { readContext: function(a) {
  return a._currentValue;
}, useContext: function(a) {
  W();
  return a._currentValue;
}, useMemo: Kc, useReducer: Ic, useRef: function(a) {
  R = W();
  S = Fc();
  var b = S.memoizedState;
  return null === b ? (a = { current: a }, S.memoizedState = a) : b;
}, useState: function(a) {
  return Ic(Hc, a);
}, useInsertionEffect: Mc, useLayoutEffect: function() {
}, useCallback: function(a, b) {
  return Kc(function() {
    return a;
  }, b);
}, useImperativeHandle: Mc, useEffect: Mc, useDebugValue: Mc, useDeferredValue: function(a) {
  W();
  return a;
}, useTransition: function() {
  W();
  return [false, Lc];
}, useId: function() {
  var a = Ac.treeContext;
  var b = a.overflow;
  a = a.id;
  a = (a & ~(1 << 32 - uc(a) - 1)).toString(32) + b;
  var c = Nc;
  if (null === c) throw Error(k(404));
  b = U++;
  a = ":" + c.idPrefix + "R" + a;
  0 < b && (a += "H" + b.toString(32));
  return a + ":";
}, useMutableSource: function(a, b) {
  W();
  return b(a._source);
}, useSyncExternalStore: function(a, b, c) {
  if (void 0 === c) throw Error(k(407));
  return c();
} }, Nc = null, Pc = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
function Qc(a) {
  console.error(a);
  return null;
}
function X() {
}
function Rc(a, b, c, d, f2, e2, g2, h2, m2) {
  var q2 = [], r2 = /* @__PURE__ */ new Set();
  b = { destination: null, responseState: b, progressiveChunkSize: void 0 === d ? 12800 : d, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: r2, pingedTasks: q2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f2 ? Qc : f2, onAllReady: void 0 === e2 ? X : e2, onShellReady: void 0 === g2 ? X : g2, onShellError: void 0 === h2 ? X : h2, onFatalError: void 0 === m2 ? X : m2 };
  c = Sc(b, 0, null, c, false, false);
  c.parentFlushed = true;
  a = Tc(b, a, null, c, r2, kc, null, sc);
  q2.push(a);
  return b;
}
function Tc(a, b, c, d, f2, e2, g2, h2) {
  a.allPendingTasks++;
  null === c ? a.pendingRootTasks++ : c.pendingTasks++;
  var m2 = { node: b, ping: function() {
    var b2 = a.pingedTasks;
    b2.push(m2);
    1 === b2.length && Uc(a);
  }, blockedBoundary: c, blockedSegment: d, abortSet: f2, legacyContext: e2, context: g2, treeContext: h2 };
  f2.add(m2);
  return m2;
}
function Sc(a, b, c, d, f2, e2) {
  return { status: 0, id: -1, index: b, parentFlushed: false, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f2, textEmbedded: e2 };
}
function Y(a, b) {
  a = a.onError(b);
  if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
  return a;
}
function Vc(a, b) {
  var c = a.onShellError;
  c(b);
  c = a.onFatalError;
  c(b);
  null !== a.destination ? (a.status = 2, da(a.destination, b)) : (a.status = 1, a.fatalError = b);
}
function Wc(a, b, c, d, f2) {
  R = {};
  Ac = b;
  U = 0;
  for (a = c(d, f2); Cc; ) Cc = false, U = 0, Dc += 1, S = null, a = c(d, f2);
  Gc();
  return a;
}
function Xc(a, b, c, d) {
  var f2 = c.render(), e2 = d.childContextTypes;
  if (null !== e2 && void 0 !== e2) {
    var g2 = b.legacyContext;
    if ("function" !== typeof c.getChildContext) d = g2;
    else {
      c = c.getChildContext();
      for (var h2 in c) if (!(h2 in e2)) throw Error(k(108, jc(d) || "Unknown", h2));
      d = N({}, g2, c);
    }
    b.legacyContext = d;
    Z(a, b, f2);
    b.legacyContext = g2;
  } else Z(a, b, f2);
}
function Yc(a, b) {
  if (a && a.defaultProps) {
    b = N({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
function Zc(a, b, c, d, f2) {
  if ("function" === typeof c) if (c.prototype && c.prototype.isReactComponent) {
    f2 = lc(c, b.legacyContext);
    var e2 = c.contextType;
    e2 = new c(d, "object" === typeof e2 && null !== e2 ? e2._currentValue : f2);
    rc(e2, c, d, f2);
    Xc(a, b, e2, c);
  } else {
    e2 = lc(c, b.legacyContext);
    f2 = Wc(a, b, c, d, e2);
    var g2 = 0 !== U;
    if ("object" === typeof f2 && null !== f2 && "function" === typeof f2.render && void 0 === f2.$$typeof) rc(f2, c, d, e2), Xc(a, b, f2, c);
    else if (g2) {
      d = b.treeContext;
      b.treeContext = tc(d, 1, 0);
      try {
        Z(a, b, f2);
      } finally {
        b.treeContext = d;
      }
    } else Z(a, b, f2);
  }
  else if ("string" === typeof c) {
    f2 = b.blockedSegment;
    e2 = Sa(f2.chunks, c, d, a.responseState, f2.formatContext);
    f2.lastPushedText = false;
    g2 = f2.formatContext;
    f2.formatContext = Ba(g2, c, d);
    $c(a, b, e2);
    f2.formatContext = g2;
    switch (c) {
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "input":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        break;
      default:
        f2.chunks.push(Ta, u(c), Ua);
    }
    f2.lastPushedText = false;
  } else {
    switch (c) {
      case gc:
      case fc:
      case Wb:
      case Xb:
      case Vb:
        Z(a, b, d.children);
        return;
      case bc:
        Z(a, b, d.children);
        return;
      case ec:
        throw Error(k(343));
      case ac:
        a: {
          c = b.blockedBoundary;
          f2 = b.blockedSegment;
          e2 = d.fallback;
          d = d.children;
          g2 = /* @__PURE__ */ new Set();
          var h2 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g2, errorDigest: null }, m2 = Sc(a, f2.chunks.length, h2, f2.formatContext, false, false);
          f2.children.push(m2);
          f2.lastPushedText = false;
          var q2 = Sc(a, 0, null, f2.formatContext, false, false);
          q2.parentFlushed = true;
          b.blockedBoundary = h2;
          b.blockedSegment = q2;
          try {
            if ($c(
              a,
              b,
              d
            ), q2.lastPushedText && q2.textEmbedded && q2.chunks.push(Ca), q2.status = 1, ad(h2, q2), 0 === h2.pendingTasks) break a;
          } catch (r2) {
            q2.status = 4, h2.forceClientRender = true, h2.errorDigest = Y(a, r2);
          } finally {
            b.blockedBoundary = c, b.blockedSegment = f2;
          }
          b = Tc(a, e2, c, m2, g2, b.legacyContext, b.context, b.treeContext);
          a.pingedTasks.push(b);
        }
        return;
    }
    if ("object" === typeof c && null !== c) switch (c.$$typeof) {
      case $b:
        d = Wc(a, b, c.render, d, f2);
        if (0 !== U) {
          c = b.treeContext;
          b.treeContext = tc(c, 1, 0);
          try {
            Z(a, b, d);
          } finally {
            b.treeContext = c;
          }
        } else Z(a, b, d);
        return;
      case cc:
        c = c.type;
        d = Yc(c, d);
        Zc(a, b, c, d, f2);
        return;
      case Yb:
        f2 = d.children;
        c = c._context;
        d = d.value;
        e2 = c._currentValue;
        c._currentValue = d;
        g2 = O;
        O = d = { parent: g2, depth: null === g2 ? 0 : g2.depth + 1, context: c, parentValue: e2, value: d };
        b.context = d;
        Z(a, b, f2);
        a = O;
        if (null === a) throw Error(k(403));
        d = a.parentValue;
        a.context._currentValue = d === hc ? a.context._defaultValue : d;
        a = O = a.parent;
        b.context = a;
        return;
      case Zb:
        d = d.children;
        d = d(c._currentValue);
        Z(a, b, d);
        return;
      case dc:
        f2 = c._init;
        c = f2(c._payload);
        d = Yc(c, d);
        Zc(a, b, c, d, void 0);
        return;
    }
    throw Error(k(
      130,
      null == c ? c : typeof c,
      ""
    ));
  }
}
function Z(a, b, c) {
  b.node = c;
  if ("object" === typeof c && null !== c) {
    switch (c.$$typeof) {
      case Tb:
        Zc(a, b, c.type, c.props, c.ref);
        return;
      case Ub:
        throw Error(k(257));
      case dc:
        var d = c._init;
        c = d(c._payload);
        Z(a, b, c);
        return;
    }
    if (ra(c)) {
      bd(a, b, c);
      return;
    }
    null === c || "object" !== typeof c ? d = null : (d = ic && c[ic] || c["@@iterator"], d = "function" === typeof d ? d : null);
    if (d && (d = d.call(c))) {
      c = d.next();
      if (!c.done) {
        var f2 = [];
        do
          f2.push(c.value), c = d.next();
        while (!c.done);
        bd(a, b, f2);
      }
      return;
    }
    a = Object.prototype.toString.call(c);
    throw Error(k(31, "[object Object]" === a ? "object with keys {" + Object.keys(c).join(", ") + "}" : a));
  }
  "string" === typeof c ? (d = b.blockedSegment, d.lastPushedText = Da(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : "number" === typeof c && (d = b.blockedSegment, d.lastPushedText = Da(b.blockedSegment.chunks, "" + c, a.responseState, d.lastPushedText));
}
function bd(a, b, c) {
  for (var d = c.length, f2 = 0; f2 < d; f2++) {
    var e2 = b.treeContext;
    b.treeContext = tc(e2, d, f2);
    try {
      $c(a, b, c[f2]);
    } finally {
      b.treeContext = e2;
    }
  }
}
function $c(a, b, c) {
  var d = b.blockedSegment.formatContext, f2 = b.legacyContext, e2 = b.context;
  try {
    return Z(a, b, c);
  } catch (m2) {
    if (Gc(), "object" === typeof m2 && null !== m2 && "function" === typeof m2.then) {
      c = m2;
      var g2 = b.blockedSegment, h2 = Sc(a, g2.chunks.length, null, g2.formatContext, g2.lastPushedText, true);
      g2.children.push(h2);
      g2.lastPushedText = false;
      a = Tc(a, b.node, b.blockedBoundary, h2, b.abortSet, b.legacyContext, b.context, b.treeContext).ping;
      c.then(a, a);
      b.blockedSegment.formatContext = d;
      b.legacyContext = f2;
      b.context = e2;
      Q(e2);
    } else throw b.blockedSegment.formatContext = d, b.legacyContext = f2, b.context = e2, Q(e2), m2;
  }
}
function cd(a) {
  var b = a.blockedBoundary;
  a = a.blockedSegment;
  a.status = 3;
  dd(this, b, a);
}
function ed(a, b, c) {
  var d = a.blockedBoundary;
  a.blockedSegment.status = 3;
  null === d ? (b.allPendingTasks--, 2 !== b.status && (b.status = 2, null !== b.destination && b.destination.close())) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = true, a = void 0 === c ? Error(k(432)) : c, d.errorDigest = b.onError(a), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
    return ed(a2, b, c);
  }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (d = b.onAllReady, d()));
}
function ad(a, b) {
  if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
    var c = b.children[0];
    c.id = b.id;
    c.parentFlushed = true;
    1 === c.status && ad(a, c);
  } else a.completedSegments.push(b);
}
function dd(a, b, c) {
  if (null === b) {
    if (c.parentFlushed) {
      if (null !== a.completedRootSegment) throw Error(k(389));
      a.completedRootSegment = c;
    }
    a.pendingRootTasks--;
    0 === a.pendingRootTasks && (a.onShellError = X, b = a.onShellReady, b());
  } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && ad(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(cd, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (ad(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));
  a.allPendingTasks--;
  0 === a.allPendingTasks && (a = a.onAllReady, a());
}
function Uc(a) {
  if (2 !== a.status) {
    var b = O, c = Pc.current;
    Pc.current = Oc;
    var d = Nc;
    Nc = a.responseState;
    try {
      var f2 = a.pingedTasks, e2;
      for (e2 = 0; e2 < f2.length; e2++) {
        var g2 = f2[e2];
        var h2 = a, m2 = g2.blockedSegment;
        if (0 === m2.status) {
          Q(g2.context);
          try {
            Z(h2, g2, g2.node), m2.lastPushedText && m2.textEmbedded && m2.chunks.push(Ca), g2.abortSet.delete(g2), m2.status = 1, dd(h2, g2.blockedBoundary, m2);
          } catch (G2) {
            if (Gc(), "object" === typeof G2 && null !== G2 && "function" === typeof G2.then) {
              var q2 = g2.ping;
              G2.then(q2, q2);
            } else {
              g2.abortSet.delete(g2);
              m2.status = 4;
              var r2 = g2.blockedBoundary, v2 = G2, A2 = Y(h2, v2);
              null === r2 ? Vc(h2, v2) : (r2.pendingTasks--, r2.forceClientRender || (r2.forceClientRender = true, r2.errorDigest = A2, r2.parentFlushed && h2.clientRenderedBoundaries.push(r2)));
              h2.allPendingTasks--;
              if (0 === h2.allPendingTasks) {
                var F2 = h2.onAllReady;
                F2();
              }
            }
          } finally {
          }
        }
      }
      f2.splice(0, e2);
      null !== a.destination && fd(a, a.destination);
    } catch (G2) {
      Y(a, G2), Vc(a, G2);
    } finally {
      Nc = d, Pc.current = c, c === Oc && Q(b);
    }
  }
}
function gd(a, b, c) {
  c.parentFlushed = true;
  switch (c.status) {
    case 0:
      var d = c.id = a.nextSegmentId++;
      c.lastPushedText = false;
      c.textEmbedded = false;
      a = a.responseState;
      p(b, Va);
      p(b, a.placeholderPrefix);
      a = u(d.toString(16));
      p(b, a);
      return t(b, Wa);
    case 1:
      c.status = 2;
      var f2 = true;
      d = c.chunks;
      var e2 = 0;
      c = c.children;
      for (var g2 = 0; g2 < c.length; g2++) {
        for (f2 = c[g2]; e2 < f2.index; e2++) p(b, d[e2]);
        f2 = hd(a, b, f2);
      }
      for (; e2 < d.length - 1; e2++) p(b, d[e2]);
      e2 < d.length && (f2 = t(b, d[e2]));
      return f2;
    default:
      throw Error(k(390));
  }
}
function hd(a, b, c) {
  var d = c.boundary;
  if (null === d) return gd(a, b, c);
  d.parentFlushed = true;
  if (d.forceClientRender) d = d.errorDigest, t(b, $a), p(b, bb), d && (p(b, db), p(b, u(C(d))), p(b, cb)), t(b, eb), gd(a, b, c);
  else if (0 < d.pendingTasks) {
    d.rootSegmentID = a.nextSegmentId++;
    0 < d.completedSegments.length && a.partialBoundaries.push(d);
    var f2 = a.responseState;
    var e2 = f2.nextSuspenseID++;
    f2 = w(f2.boundaryPrefix + e2.toString(16));
    d = d.id = f2;
    fb(b, a.responseState, d);
    gd(a, b, c);
  } else if (d.byteSize > a.progressiveChunkSize) d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), fb(b, a.responseState, d.id), gd(a, b, c);
  else {
    t(b, Xa);
    c = d.completedSegments;
    if (1 !== c.length) throw Error(k(391));
    hd(a, b, c[0]);
  }
  return t(b, ab);
}
function id(a, b, c) {
  Bb(b, a.responseState, c.formatContext, c.id);
  hd(a, b, c);
  return Cb(b, c.formatContext);
}
function jd(a, b, c) {
  for (var d = c.completedSegments, f2 = 0; f2 < d.length; f2++) kd(a, b, c, d[f2]);
  d.length = 0;
  a = a.responseState;
  d = c.id;
  c = c.rootSegmentID;
  p(b, a.startInlineScript);
  a.sentCompleteBoundaryFunction ? p(b, Jb) : (a.sentCompleteBoundaryFunction = true, p(b, Ib));
  if (null === d) throw Error(k(395));
  c = u(c.toString(16));
  p(b, d);
  p(b, Kb);
  p(b, a.segmentPrefix);
  p(b, c);
  return t(b, Lb);
}
function kd(a, b, c, d) {
  if (2 === d.status) return true;
  var f2 = d.id;
  if (-1 === f2) {
    if (-1 === (d.id = c.rootSegmentID)) throw Error(k(392));
    return id(a, b, d);
  }
  id(a, b, d);
  a = a.responseState;
  p(b, a.startInlineScript);
  a.sentCompleteSegmentFunction ? p(b, Eb) : (a.sentCompleteSegmentFunction = true, p(b, Db));
  p(b, a.segmentPrefix);
  f2 = u(f2.toString(16));
  p(b, f2);
  p(b, Gb);
  p(b, a.placeholderPrefix);
  p(b, f2);
  return t(b, Hb);
}
function fd(a, b) {
  l$1 = new Uint8Array(512);
  n = 0;
  try {
    var c = a.completedRootSegment;
    if (null !== c && 0 === a.pendingRootTasks) {
      hd(a, b, c);
      a.completedRootSegment = null;
      var d = a.responseState.bootstrapChunks;
      for (c = 0; c < d.length - 1; c++) p(b, d[c]);
      c < d.length && t(b, d[c]);
    }
    var f2 = a.clientRenderedBoundaries, e2;
    for (e2 = 0; e2 < f2.length; e2++) {
      var g2 = f2[e2];
      d = b;
      var h2 = a.responseState, m2 = g2.id, q2 = g2.errorDigest, r2 = g2.errorMessage, v2 = g2.errorComponentStack;
      p(d, h2.startInlineScript);
      h2.sentClientRenderFunction ? p(d, Nb) : (h2.sentClientRenderFunction = true, p(
        d,
        Mb
      ));
      if (null === m2) throw Error(k(395));
      p(d, m2);
      p(d, Ob);
      if (q2 || r2 || v2) p(d, Qb), p(d, u(Sb(q2 || "")));
      if (r2 || v2) p(d, Qb), p(d, u(Sb(r2 || "")));
      v2 && (p(d, Qb), p(d, u(Sb(v2))));
      if (!t(d, Pb)) ;
    }
    f2.splice(0, e2);
    var A2 = a.completedBoundaries;
    for (e2 = 0; e2 < A2.length; e2++) if (!jd(a, b, A2[e2])) ;
    A2.splice(0, e2);
    ba(b);
    l$1 = new Uint8Array(512);
    n = 0;
    var F2 = a.partialBoundaries;
    for (e2 = 0; e2 < F2.length; e2++) {
      var G2 = F2[e2];
      a: {
        f2 = a;
        g2 = b;
        var ma2 = G2.completedSegments;
        for (h2 = 0; h2 < ma2.length; h2++) if (!kd(
          f2,
          g2,
          G2,
          ma2[h2]
        )) {
          h2++;
          ma2.splice(0, h2);
          var Fb2 = false;
          break a;
        }
        ma2.splice(0, h2);
        Fb2 = true;
      }
      if (!Fb2) {
        a.destination = null;
        e2++;
        F2.splice(0, e2);
        return;
      }
    }
    F2.splice(0, e2);
    var na2 = a.completedBoundaries;
    for (e2 = 0; e2 < na2.length; e2++) if (!jd(a, b, na2[e2])) ;
    na2.splice(0, e2);
  } finally {
    ba(b), 0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && b.close();
  }
}
function ld(a, b) {
  try {
    var c = a.abortableTasks;
    c.forEach(function(c2) {
      return ed(c2, a, b);
    });
    c.clear();
    null !== a.destination && fd(a, a.destination);
  } catch (d) {
    Y(a, d), Vc(a, d);
  }
}
reactDomServer_browser_production_min.renderToReadableStream = function(a, b) {
  return new Promise(function(c, d) {
    var f2, e2, g2 = new Promise(function(a2, b2) {
      e2 = a2;
      f2 = b2;
    }), h2 = Rc(a, za(b ? b.identifierPrefix : void 0, b ? b.nonce : void 0, b ? b.bootstrapScriptContent : void 0, b ? b.bootstrapScripts : void 0, b ? b.bootstrapModules : void 0), Aa(b ? b.namespaceURI : void 0), b ? b.progressiveChunkSize : void 0, b ? b.onError : void 0, e2, function() {
      var a2 = new ReadableStream({ type: "bytes", pull: function(a3) {
        if (1 === h2.status) h2.status = 2, da(a3, h2.fatalError);
        else if (2 !== h2.status && null === h2.destination) {
          h2.destination = a3;
          try {
            fd(h2, a3);
          } catch (A2) {
            Y(h2, A2), Vc(h2, A2);
          }
        }
      }, cancel: function() {
        ld(h2);
      } }, { highWaterMark: 0 });
      a2.allReady = g2;
      c(a2);
    }, function(a2) {
      g2.catch(function() {
      });
      d(a2);
    }, f2);
    if (b && b.signal) {
      var m2 = b.signal, q2 = function() {
        ld(h2, m2.reason);
        m2.removeEventListener("abort", q2);
      };
      m2.addEventListener("abort", q2);
    }
    Uc(h2);
  });
};
reactDomServer_browser_production_min.version = "18.3.1";
var l, s;
{
  l = reactDomServerLegacy_browser_production_min;
  s = reactDomServer_browser_production_min;
}
l.version;
var renderToString = l.renderToString;
l.renderToStaticMarkup;
l.renderToNodeStream;
l.renderToStaticNodeStream;
s.renderToReadableStream;
var GeoJSON = createPathComponent(
  function createGeoJSON({ data, ...options }, ctx) {
    const geoJSON = new leafletSrcExports.GeoJSON(data, options);
    return createElementObject(
      geoJSON,
      extendContext(ctx, { overlayContainer: geoJSON })
    );
  },
  function updateGeoJSON(layer, props, prevProps) {
    if (props.data !== prevProps.data) {
      layer.clearLayers().addData(props.data);
    }
    if (props.style !== prevProps.style) {
      if (props.style == null) {
        layer.resetStyle();
      } else {
        layer.setStyle(props.style);
      }
    }
  }
);
var tpl = (str, data) => str ? lodashExports.template(str, { interpolate: /{{([\s\S]+?)}}/g })(data) : "";
function PopupTemplate(props) {
  const { template: template2, heading, content, data } = props;
  if (template2) return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: tpl(template2, data) } });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pc-heading", children: tpl(heading, data) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    lodashExports.isArray(content) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: content == null ? void 0 : content.map((c, k2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "pc-content-label", children: [
        c.label,
        ": "
      ] }),
      lodashExports.get(data, c.value)
    ] }, k2)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: tpl(content, data) } })
  ] });
}
var PopupTemplate_default = PopupTemplate;
function GeoJSONAjax(props) {
  const { dataUrl, children, ...opts } = props;
  const [enabled, setEnabled] = reactExports.useState(false);
  const [data, setData] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (enabled && dataUrl) {
      fetch(dataUrl).then((resp) => resp.json()).then((resp) => {
        setData(resp);
      });
    }
  }, [enabled, dataUrl]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    GeoJSON,
    {
      ...opts,
      data,
      eventHandlers: {
        add: (event) => {
          setEnabled(true);
        },
        remove: (event) => {
          setEnabled(false);
        }
      },
      children: lodashExports.isFunction(children) && data && children(data)
    }
  );
}
var GeoJSONAjax_default = GeoJSONAjax;
var featuresAdapter = createEntityAdapter();
var featuresSelectors = featuresAdapter.getSelectors((state) => state);
var initialState = featuresAdapter.getInitialState({
  $wire: null,
  $watch: null,
  state: null,
  config: {}
});
var actions = (set2, get3) => ({
  addFeature: (feature2) => set2((state) => {
    featuresAdapter.addOne(state, { id: nanoid(), ...feature2 });
  }),
  updateFeature: (payload) => set2((state) => {
    featuresAdapter.updateOne(state, payload);
  }),
  removeFeature: (id2) => set2((state) => {
    featuresAdapter.removeOne(state, id2);
  }),
  setFeatures: (features) => set2((state) => {
    featuresAdapter.setAll(state, features);
  }),
  removeFeatures: () => set2((state) => {
    featuresAdapter.removeAll(state);
  })
});
var MapStoreContext = reactExports.createContext(null);
var MapStoreProvider = ({ children, value }) => {
  const storeRef = reactExports.useRef();
  if (!storeRef.current) {
    storeRef.current = createStore()(immer((set2, get3) => ({
      ...initialState,
      ...value,
      ...actions(set2),
      reset: () => ({
        ...initialState,
        ...value
      })
    })));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MapStoreContext.Provider, { value: storeRef.current, children });
};
var useMapStore = (selector) => {
  const store = reactExports.useContext(MapStoreContext);
  if (!store) {
    throw new Error("Missing MapStoreProvider");
  }
  return useStore(store, selector);
};
function setFeaturesByState({ state, setFeatures }) {
  const type2 = getType(state);
  if (type2 === "MultiPoint") {
    setFeatures(
      getCoords(state).map((coord) => ({
        id: nanoid(),
        ...point(coord)
      }))
    );
  } else if (type2 === "MultiLineString") {
    setFeatures(
      getCoords(state).map((coord) => ({
        id: nanoid(),
        ...lineString(coord)
      }))
    );
  } else if (type2 === "MultiPolygon") {
    setFeatures(
      getCoords(state).map((coord) => ({
        id: nanoid(),
        ...polygon(coord)
      }))
    );
  } else if (["Point", "LineString", "Polygon"].includes(type2)) {
    setFeatures([
      {
        id: nanoid(),
        ...feature(state)
      }
    ]);
  } else if (type2 === "GeometryCollection") {
    let newFeatures = [];
    flattenEach(state, (currentFeature) => newFeatures.push({ id: nanoid(), ...currentFeature }));
    setFeatures(newFeatures);
  }
}
var setFeaturesByState_default = setFeaturesByState;
function setDefaultIcon(options = {}) {
  L$3.Icon.Default.mergeOptions({
    iconUrl: MarkerIcon,
    iconRetinaUrl: MarkerIcon2x,
    shadowUrl: MarkerShadowIcon,
    ...options
  });
}
var setDefaultIcon_default = setDefaultIcon;
function toLatLng(data) {
  if (!data) return data;
  return getCoord(turf_flip_default(turf_center_default(data)));
}
var toLatLng_default = toLatLng;
function toBounds(data) {
  const arr = bbox(data);
  return [
    [arr[1], arr[0]],
    [arr[3], arr[2]]
  ];
}
var toBounds_default = toBounds;
function zoomToFeatureByState({
  state,
  config: { zoomToFeature },
  map
}) {
  const geometry2 = getGeom(state);
  if (geojsonValidation.isPoint(geometry2)) {
    if (zoomToFeature) {
      const bounds = toBounds_default(circle(state, 0.25, { steps: 4 }));
      map.fitBounds(bounds, { animate: false });
    } else {
      map.panTo(toLatLng_default(state), { animate: false });
    }
    return;
  }
  if (geojsonValidation.isGeoJSONObject(geometry2)) {
    if (zoomToFeature) {
      const bounds = toBounds_default(state);
      map.fitBounds(bounds, { animate: false });
    } else {
      map.panTo(toLatLng_default(pointOnFeature(state)));
    }
  }
}
var zoomToFeatureByState_default = zoomToFeatureByState;
function FeatureManager() {
  const map$1 = useMap();
  const [
    state,
    $wire,
    geomType,
    latitudeField,
    longitudeField,
    drawField,
    zoomToFeature,
    markerOptions,
    polylineOptions,
    polygonOptions,
    rectangleOptions,
    features,
    updateFeature,
    setFeatures,
    removeFeature
  ] = useMapStore((state2) => [
    state2.state,
    state2.$wire,
    state2.config.geomType,
    state2.config.latitudeField,
    state2.config.longitudeField,
    state2.config.drawField,
    state2.config.zoomToFeature,
    state2.config.markerOptions,
    state2.config.polylineOptions,
    state2.config.polygonOptions,
    state2.config.rectangleOptions,
    featuresSelectors.selectAll(state2),
    state2.updateFeature,
    state2.setFeatures,
    state2.removeFeature
  ]);
  reactExports.useEffect(() => {
    if (!state) return;
    setFeaturesByState_default({
      state,
      setFeatures
    });
    zoomToFeatureByState_default({
      state,
      config: { zoomToFeature },
      map: map$1
    });
  }, []);
  useUpdateEffect(() => {
    if (features == null ? void 0 : features.length) {
      console.log(features);
      if (["Point", "LineString", "Polygon"].includes(geomType) && (features == null ? void 0 : features.length) === 1) {
        const geometry2 = getGeom(lodashExports.last(features));
        if (geomType === "Point") {
          const coords = getCoord(geometry2);
          latitudeField && $wire.set(latitudeField, coords[1], false);
          longitudeField && $wire.set(longitudeField, coords[0], false);
        }
        drawField && $wire.set(drawField, JSON.stringify(geometry2), false);
      } else if (geomType === "MultiPoint") {
        const geometry2 = getGeom(multiPoint(lodashExports.map(features, (i) => getCoord(i))));
        drawField && $wire.set(drawField, JSON.stringify(geometry2), false);
      } else if (geomType === "MultiLineString") {
        const geometry2 = getGeom(
          multiLineString(lodashExports.map(features, (i) => getCoords(i)))
        );
        drawField && $wire.set(drawField, JSON.stringify(geometry2), false);
      } else if (geomType === "MultiPolygon") {
        const geometry2 = getGeom(
          multiPolygon(lodashExports.map(features, (i) => getCoords(i)))
        );
        drawField && $wire.set(drawField, JSON.stringify(geometry2), false);
      } else if (geomType === "GeometryCollection") {
        const geometry2 = getGeom(
          geometryCollection(lodashExports.map(features, (i) => getGeom(i)))
        );
        drawField && $wire.set(drawField, JSON.stringify(geometry2), false);
      }
    } else {
      drawField && $wire.set(drawField, "", false);
    }
  }, [JSON.stringify(features)]);
  let geojsonOpts = {
    pointToLayer: (point2, latlng) => {
      let markerOpts = { ...markerOptions };
      if (markerOpts.icon) markerOpts.icon = L$3.icon(markerOpts.icon);
      return L$3.marker(latlng, markerOpts);
    },
    style: () => {
      return {
        ...polylineOptions,
        ...polygonOptions,
        ...rectangleOptions
      };
    },
    eventHandlers: {
      "pm:update": ({ layer, target }) => {
        featureEach(target.toGeoJSON(), (feature2, index) => {
          updateFeature({
            id: feature2.id,
            changes: feature2
          });
        });
      },
      "pm:cut": (e2) => {
        map$1.removeLayer(e2.layer);
        const id2 = lodashExports.get(e2, "originalLayer.feature.id");
        removeFeature(id2);
        const type2 = getType(e2.layer.toGeoJSON());
        const geometry2 = getGeom(
          type2 === geomType ? e2.layer.toGeoJSON() : e2.originalLayer.toGeoJSON()
        );
        setFeaturesByState_default({
          state: geometry2,
          setFeatures
        });
      }
    },
    pane: ["Point", "MultiPoint"].includes(geomType) ? "stateMarkerPane" : "stateOverlayPane"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Pane, { name: "stateOverlayPane", style: { zIndex: 450 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Pane, { name: "stateMarkerPane", style: { zIndex: 650 } }),
    features == null ? void 0 : features.map((f2, k2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      GeoJSON,
      {
        data: f2,
        ...geojsonOpts
      },
      k2
    ))
  ] });
}
var FeatureManager_default = FeatureManager;
var FullscreenControl = createControlComponent(function createFullscreenControl(props) {
  return new leafletSrcExports.Control.FullScreen(props);
});
function DynamicLayer(props) {
  const { type: type2, popupTemplate, ...other } = props;
  let tplPopupProps = popupTemplate ? lodashExports.isString(popupTemplate) ? { template: popupTemplate } : popupTemplate : {};
  if (type2 === "wms") {
    const opts = {
      url: "",
      format: "image/png",
      transparent: true,
      ...other
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(WMSTileLayer, { ...opts });
  }
  if (type2 === "geojson") {
    let opts = {
      // pmIgnore: true,
      pointToLayer: (point2, latlng) => {
        let markerOpts = { ...other.markerOptions };
        if (markerOpts.icon) markerOpts.icon = L$3.icon(markerOpts.icon);
        return L$3.marker(latlng, markerOpts);
      },
      style: (feature2) => {
        return {
          ...other.polylineOptions,
          ...other.polygonOptions,
          ...other.rectangleOptions
        };
      },
      onEachFeature: (feature2, layer) => {
        popupTemplate && layer.bindPopup(() => {
          return renderToString(
            /* @__PURE__ */ jsxRuntimeExports.jsx(PopupTemplate_default, { data: feature2 == null ? void 0 : feature2.properties, ...tplPopupProps })
          );
        });
      }
    };
    if (other.data) {
      opts = {
        ...opts,
        data: lodashExports.isString(other.data) ? JSON.parse(other.data) : other.data
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GeoJSON, { ...opts });
    }
    if (other.dataUrl) {
      opts = {
        ...opts,
        dataUrl: other.dataUrl
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GeoJSONAjax_default, { ...opts });
    }
  }
  return null;
}
var DynamicLayer_default = DynamicLayer;
var controlComponents = {
  zoomControl: ZoomControl,
  layersControl: LayersControl,
  drawControl: GeomanControls,
  attributionControl: AttributionControl,
  scaleControl: ScaleControl,
  fullscreenControl: FullscreenControl
};
var defaultDrawControlOptions = {
  drawMarker: false,
  drawCircle: false,
  drawCircleMarker: false,
  drawPolyline: false,
  drawRectangle: false,
  drawPolygon: false,
  drawText: false,
  editMode: true,
  dragMode: false,
  cutPolygon: false,
  removalMode: true,
  rotateMode: false
};
function ControlManager() {
  const [geomType, layers, baseLayers, _controls] = useMapStore((state) => [
    state.config.geomType,
    state.config.layers,
    state.config.baseLayers,
    state.config.controls
  ]);
  const [addFeature, removeFeature, removeFeatures] = useMapStore((state) => [
    state.addFeature,
    state.removeFeature,
    state.removeFeatures
  ]);
  const handleCreate = (e2) => {
    e2.target.removeLayer(e2.layer);
    if (["Point", "LineString", "Polygon"].includes(geomType)) removeFeatures();
    addFeature(e2.layer.toGeoJSON());
  };
  const handleRemove = ({ layer, target }) => {
    const id2 = layer.feature.id;
    id2 && removeFeature(id2);
  };
  const controls = reactExports.useMemo(() => lodashExports.map(_controls, (opts, name) => {
    const Component = controlComponents[name];
    if (!opts || (opts == null ? void 0 : opts.enabled) == false || !Component) return null;
    let options = { ...opts };
    let children = null;
    if (name === "layersControl") {
      children = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
        baseLayers == null ? void 0 : baseLayers.map(
          ({ selected = false, title = "None", ...layerProps }, k2) => /* @__PURE__ */ jsxRuntimeExports.jsx(LayersControl.BaseLayer, { name: title, checked: selected, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TileLayer, { url: "", ...layerProps }) }, k2)
        ),
        layers == null ? void 0 : layers.map(
          ({ selected = false, title = "None", ...layerProps }, k2) => /* @__PURE__ */ jsxRuntimeExports.jsx(LayersControl.Overlay, { name: title, checked: selected, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DynamicLayer_default,
            {
              ...layerProps,
              zIndex: 100
            }
          ) }, k2)
        )
      ] });
    }
    if (name === "drawControl") {
      options = {
        ...options,
        options: defaultDrawControlOptions
      };
      if (["Point", "MultiPoint"].includes(geomType)) {
        options.options = {
          ...options.options,
          drawMarker: true,
          editMode: true,
          removalMode: true
        };
      } else if (["LineString", "MultiLineString"].includes(geomType)) {
        options.options = {
          ...options.options,
          drawPolyline: true,
          editMode: true,
          dragMode: true,
          cutPolygon: true,
          removalMode: true,
          rotateMode: true
        };
      } else if (["Polygon", "MultiPolygon"].includes(geomType)) {
        options.options = {
          ...options.options,
          drawRectangle: true,
          drawPolygon: true,
          editMode: true,
          dragMode: true,
          cutPolygon: true,
          removalMode: true,
          rotateMode: true
        };
      } else {
        options.options = {
          ...options.options,
          drawMarker: true,
          drawCircle: true,
          drawPolyline: true,
          drawRectangle: true,
          drawPolygon: true,
          editMode: true,
          dragMode: true,
          cutPolygon: true,
          removalMode: true,
          rotateMode: true
        };
      }
      options.onCreate = handleCreate;
      options.onMapRemove = handleRemove;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...options, children }, name);
  }).filter((v2) => v2), [JSON.stringify(_controls)]);
  return controls.map((control) => control);
}
var ControlManager_default = ControlManager;
const Alpine$1 = window["Alpine"];
setDefaultIcon_default();
function App(props) {
  const { $root, $wire, $watch, state, config } = props;
  const {
    statePath,
    defaultCenter,
    defaultZoom,
    latitudeField,
    longitudeField,
    drawField,
    baseLayers,
    geomType,
    zoomToFeature,
    ...other
  } = config;
  const [setFeatures, removeFeatures] = useMapStore(
    (state2) => [
      state2.setFeatures,
      state2.removeFeatures
    ]
  );
  const [geocompleteLocation, setGeocompleteLocation] = reactExports.useState();
  const mapRef = reactExports.useRef(null);
  const mapOptions = {
    style: {
      height: "100%"
    },
    zoomControl: false,
    attributionControl: false,
    ...other.mapOptions,
    center: defaultCenter,
    zoom: defaultZoom,
    whenReady: ({ target: map }) => {
      $root.dispatchEvent(
        new CustomEvent("filament-map::mapWhenReady", {
          detail: { target: map },
          bubbles: true
        })
      );
      map.on("moveend", (e2) => {
        $root.dispatchEvent(
          new CustomEvent("filament-map::mapMoveend", {
            detail: e2,
            bubbles: true
          })
        );
      });
      setTimeout(() => {
        map.invalidateSize();
      }, 100);
    }
  };
  reactExports.useEffect(() => {
    $watch("state", (value) => {
      if (!value) {
        removeFeatures();
        return;
      }
      const map = mapRef.current;
      const state2 = lodashExports.cloneDeep(Alpine$1.raw(value));
      setFeaturesByState_default({
        state: state2,
        setFeatures
      });
      zoomToFeatureByState_default({
        state: state2,
        config: { zoomToFeature },
        map
      });
    });
    window.addEventListener("filament-map::geocompleteSelected", (event) => {
      const location = lodashExports.get(event, "detail.geometry.location");
      const viewport = lodashExports.get(event, "detail.geometry.viewport");
      let markerOpts = { ...config.markerOptions };
      if (markerOpts.icon) markerOpts.icon = L$3.icon(markerOpts.icon);
      if (!["Point", "MultiPoint"].includes(config.geomType)) {
        setGeocompleteLocation(location);
      }
      mapRef.current.fitBounds([
        [viewport.southwest.lat, viewport.southwest.lng],
        [viewport.northeast.lat, viewport.northeast.lng]
      ]);
    });
  }, []);
  const getMarkerOpts = reactExports.useCallback(() => {
    let markerOpts = { ...config.markerOptions };
    if (markerOpts.icon) markerOpts.icon = L$3.icon(markerOpts.icon);
    return markerOpts;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MapContainer, { ...mapOptions, ref: mapRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ControlManager_default, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureManager_default, {}),
    geocompleteLocation && /* @__PURE__ */ jsxRuntimeExports.jsx(Marker, { position: geocompleteLocation, ...getMarkerOpts() })
  ] });
}
const Alpine = window["Alpine"];
function filamentMapField({
  state,
  config,
  mapEl
}) {
  return {
    state,
    init: function() {
      const root = createRoot(mapEl);
      const appProps = {
        $root: this["$root"],
        $watch: this["$watch"],
        state: lodashExports.cloneDeep(Alpine.raw(this.state)),
        config
      };
      root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(MapStoreProvider, { value: lodashExports.pick(appProps, ["$wire", "state", "config"]), children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, { ...appProps }) }));
    }
  };
}
window["filamentMapField"] = filamentMapField;
