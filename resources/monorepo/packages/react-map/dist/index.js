import { createPathComponent, createElementObject, extendContext, createControlComponent } from '@react-leaflet/core';
import ie, { GeoJSON, Control } from 'leaflet';
import { point, lineString, polygon, feature, multiPoint, multiLineString, multiPolygon, geometryCollection } from '@turf/helpers';
import { getType, getCoords, getCoord, getGeom } from '@turf/invariant';
import { flattenEach, featureEach } from '@turf/meta';
import { last, map, get } from 'lodash';
import { createContext, useRef, useContext, useEffect, useMemo, Fragment } from 'react';
import { useMap, LayersControl, TileLayer, WMSTileLayer, ZoomControl, AttributionControl, ScaleControl } from 'react-leaflet';
import { createEntityAdapter, nanoid } from '@reduxjs/toolkit';
import { createStore, useStore } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useUpdateEffect } from 'react-use';
import { circle } from '@turf/circle';
import { pointOnFeature } from '@turf/point-on-feature';
import { isPoint, isGeoJSONObject } from 'geojson-validation';
import se from 'leaflet/dist/images/marker-icon.png';
import ce from 'leaflet/dist/images/marker-icon-2x.png';
import ue from 'leaflet/dist/images/marker-shadow.png';
import pe from '@turf/center';
import ye from '@turf/flip';
import { bbox } from '@turf/bbox';
import { GeomanControls } from 'react-leaflet-geoman-v2';
import 'leaflet.fullscreen';
import 'leaflet.fullscreen/Control.FullScreen.css';

var h=createPathComponent(function({data:r,...t},o){let i=new GeoJSON(r,t);return createElementObject(i,extendContext(o,{overlayContainer:i}))},function(r,t,o){t.data!==o.data&&r.clearLayers().addData(t.data),t.style!==o.style&&(t.style==null?r.resetStyle():r.setStyle(t.style));});var p=createEntityAdapter(),R=p.getSelectors(e=>e),W=p.getInitialState({$wire:null,$watch:null,state:null,config:{}}),_=(e,r)=>({addFeature:t=>e(o=>{p.addOne(o,{id:nanoid(),...t});}),updateFeature:t=>e(o=>{p.updateOne(o,t);}),removeFeature:t=>e(o=>{p.removeOne(o,t);}),setFeatures:t=>e(o=>{p.setAll(o,t);}),removeFeatures:()=>e(t=>{p.removeAll(t);})}),Y=createContext(null),K=({children:e,value:r})=>{let t=useRef();return t.current||(t.current=createStore()(immer((o,i)=>({...W,...r,..._(o),reset:()=>({...W,...r})})))),jsx(Y.Provider,{value:t.current,children:e})},b=e=>{let r=useContext(Y);if(!r)throw new Error("Missing MapStoreProvider");return useStore(r,e)};function le({state:e,setFeatures:r}){let t=getType(e);if(t==="MultiPoint")r(getCoords(e).map(o=>({id:nanoid(),...point(o)})));else if(t==="MultiLineString")r(getCoords(e).map(o=>({id:nanoid(),...lineString(o)})));else if(t==="MultiPolygon")r(getCoords(e).map(o=>({id:nanoid(),...polygon(o)})));else if(["Point","LineString","Polygon"].includes(t))r([{id:nanoid(),...feature(e)}]);else if(t==="GeometryCollection"){let o=[];flattenEach(e,i=>o.push({id:nanoid(),...i})),r(o);}}var F=le;function me(e={}){ie.Icon.Default.mergeOptions({iconUrl:se,iconRetinaUrl:ce,shadowUrl:ue,...e});}var de=me;function ge(e){return e&&getCoord(ye(pe(e)))}var x=ge;function Ge(e){let r=bbox(e);return [[r[1],r[0]],[r[3],r[2]]]}var S=Ge;function Me({state:e,config:{zoomToFeature:r},map:t}){let o=getGeom(e);if(isPoint(o)){if(r){let i=S(circle(e,.25,{steps:4}));t.fitBounds(i,{animate:!1});}else t.panTo(x(e),{animate:!1});return}if(isGeoJSONObject(o))if(r){let i=S(e);t.fitBounds(i,{animate:!1});}else t.panTo(x(pointOnFeature(e)));}var V=Me;function we(){let e=useMap(),[r,t,o,i,J,s,L,c,v,l,d]=b(n=>[n.state,n.$wire,n.config.geomType,n.config.latitudeField,n.config.longitudeField,n.config.drawField,n.config.zoomToFeature,R.selectAll(n),n.updateFeature,n.setFeatures,n.removeFeature]);return useEffect(()=>{r&&(F({state:r,setFeatures:l}),V({state:r,config:{zoomToFeature:L},map:e}));},[]),useUpdateEffect(()=>{if(c?.length){if(["Point","LineString","Polygon"].includes(o)&&c?.length===1){let n=getGeom(last(c));if(o==="Point"){let a=getCoord(n);i&&t.set(i,a[1],!1),J&&t.set(J,a[0],!1);}s&&t.set(s,JSON.stringify(n),!1);}else if(o==="MultiPoint"){let n=getGeom(multiPoint(map(c,a=>getCoord(a))));s&&t.set(s,JSON.stringify(n),!1);}else if(o==="MultiLineString"){let n=getGeom(multiLineString(map(c,a=>getCoords(a))));s&&t.set(s,JSON.stringify(n),!1);}else if(o==="MultiPolygon"){let n=getGeom(multiPolygon(map(c,a=>getCoords(a))));s&&t.set(s,JSON.stringify(n),!1);}else if(o==="GeometryCollection"){let n=getGeom(geometryCollection(map(c,a=>getGeom(a))));s&&t.set(s,JSON.stringify(n),!1);}}else s&&t.set(s,"",!1);},[JSON.stringify(c)]),c?.map((n,a)=>jsx(h,{data:n,eventHandlers:{"pm:update":({layer:u,target:f})=>{featureEach(f.toGeoJSON(),(m,g)=>{v({id:m.id,changes:m});});},"pm:cut":u=>{e.removeLayer(u.layer);let f=get(u,"originalLayer.feature.id");d(f);let m=getType(u.layer.toGeoJSON()),g=getGeom(m===o?u.layer.toGeoJSON():u.originalLayer.toGeoJSON());F({state:g,setFeatures:l});}}},a))}var Pe=we;var X=createControlComponent(function(r){return new Control.FullScreen(r)});function Ue(e){let{type:r,...t}=e;if(r==="wms"){let o={url:"",format:"image/png",transparent:!0,...t};return jsx(WMSTileLayer,{...o})}return null}var A=Ue;var Ke={zoomControl:ZoomControl,layersControl:LayersControl,drawControl:GeomanControls,attributionControl:AttributionControl,scaleControl:ScaleControl,fullscreenControl:X},qe={drawMarker:!0,drawCircle:!1,drawCircleMarker:!1,drawPolyline:!1,drawRectangle:!1,drawPolygon:!1,drawText:!1,editMode:!0,dragMode:!1,cutPolygon:!1,removalMode:!0,rotateMode:!1};function et(){let[e,r,t,o]=b(l=>[l.config.geomType,l.config.layers,l.config.baseLayers,l.config.controls]),[i,J,s]=b(l=>[l.addFeature,l.removeFeature,l.removeFeatures]),L=l=>{l.target.removeLayer(l.layer),["Point","LineString","Polygon"].includes(e)&&s(),i(l.layer.toGeoJSON());},c=({layer:l,target:d})=>{let n=l.feature.id;n&&J(n);};return useMemo(()=>map(o,(l,d)=>{let n=Ke[d];if(!l||l?.enabled==!1||!n)return null;let a={...l},u=null;return d==="layersControl"&&(u=jsxs(Fragment,{children:[t?.map(({selected:f=!1,title:m="None",...g},O)=>jsx(LayersControl.BaseLayer,{name:m,checked:f,children:jsx(TileLayer,{url:"",...g})},O)),r?.map(({selected:f=!1,title:m="None",...g},O)=>jsx(LayersControl.Overlay,{name:m,checked:f,children:jsx(A,{...g})},O))]})),d==="drawControl"&&(a={...a,options:qe},["Point","MultiPoint"].includes(e)?a.options={...a.options,drawMarker:!0,editMode:!0,removalMode:!0}:["LineString","MultiLineString"].includes(e)?a.options={...a.options,drawPolyline:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0}:["Polygon","MultiPolygon"].includes(e)?a.options={...a.options,drawRectangle:!0,drawPolygon:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0}:a.options={...a.options,drawMarker:!0,drawCircle:!0,drawPolyline:!0,drawRectangle:!0,drawPolygon:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0},a.onCreate=L,a.onMapRemove=c),jsx(n,{...a,children:u},d)}).filter(l=>l),[JSON.stringify(o)]).map(l=>l)}var tt=et;

export { tt as ControlManager, Pe as FeatureManager, X as FullscreenControl, h as GeoJSON, K as MapStoreProvider, R as featuresSelectors, de as setDefaultIcon, F as setFeaturesByState, S as toBounds, x as toLatLng, b as useMapStore, V as zoomToFeatureByState };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map