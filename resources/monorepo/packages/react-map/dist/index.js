import { createPathComponent, createElementObject, extendContext, createControlComponent } from '@react-leaflet/core';
import he, { GeoJSON, Control } from 'leaflet';
import { isArray, get, isFunction, last, map, template, isString } from 'lodash';
import { jsx, jsxs } from 'react/jsx-runtime';
import { createContext, useRef, useContext, useState, useEffect, useMemo, Fragment } from 'react';
import { point, lineString, polygon, feature, multiPoint, multiLineString, multiPolygon, geometryCollection } from '@turf/helpers';
import { getType, getCoords, getCoord, getGeom } from '@turf/invariant';
import { flattenEach, featureEach } from '@turf/meta';
import { useMap, LayersControl, TileLayer, WMSTileLayer, ZoomControl, AttributionControl, ScaleControl } from 'react-leaflet';
import { createEntityAdapter, nanoid } from '@reduxjs/toolkit';
import { createStore, useStore } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { useUpdateEffect } from 'react-use';
import { circle } from '@turf/circle';
import { pointOnFeature } from '@turf/point-on-feature';
import { isPoint, isGeoJSONObject } from 'geojson-validation';
import Oe from 'leaflet/dist/images/marker-icon.png';
import Xe from 'leaflet/dist/images/marker-icon-2x.png';
import Le from 'leaflet/dist/images/marker-shadow.png';
import ve from '@turf/center';
import Be from '@turf/flip';
import { bbox } from '@turf/bbox';
import { GeomanControls } from 'react-leaflet-geoman-v2';
import 'leaflet.fullscreen';
import 'leaflet.fullscreen/Control.FullScreen.css';
import { renderToString } from 'react-dom/server';

var g=createPathComponent(function({data:r,...e},o){let n=new GeoJSON(r,e);return createElementObject(n,extendContext(o,{overlayContainer:n}))},function(r,e,o){e.data!==o.data&&r.clearLayers().addData(e.data),e.style!==o.style&&(e.style==null?r.resetStyle():r.setStyle(e.style));});var v=(t,r)=>t?template(t,{interpolate:/{{([\s\S]+?)}}/g})(r):"";function ee(t){let{template:r,heading:e,content:o,data:n}=t;return r?jsx("div",{dangerouslySetInnerHTML:{__html:v(r,n)}}):jsxs("div",{children:[jsx("div",{className:"pc-heading",children:v(e,n)}),jsx("hr",{}),isArray(o)?jsx("div",{children:o?.map((p,s)=>jsxs("div",{children:[jsxs("span",{className:"pc-content-label",children:[p.label,": "]}),get(n,p.value)]},s))}):jsx("div",{dangerouslySetInnerHTML:{__html:v(o,n)}})]})}var O=ee;function ae(t){let{dataUrl:r,children:e,...o}=t,[n,p]=useState(null);return useEffect(()=>{r&&fetch(r).then(s=>s.json()).then(s=>{p(s);});},[r]),jsx(g,{...o,data:n,children:isFunction(e)&&n&&e(n)})}var V=ae;var b=createEntityAdapter(),W=b.getSelectors(t=>t),Y=b.getInitialState({$wire:null,$watch:null,state:null,config:{}}),fe=(t,r)=>({addFeature:e=>t(o=>{b.addOne(o,{id:nanoid(),...e});}),updateFeature:e=>t(o=>{b.updateOne(o,e);}),removeFeature:e=>t(o=>{b.removeOne(o,e);}),setFeatures:e=>t(o=>{b.setAll(o,e);}),removeFeatures:()=>t(e=>{b.removeAll(e);})}),A=createContext(null),ye=({children:t,value:r})=>{let e=useRef();return e.current||(e.current=createStore()(immer((o,n)=>({...Y,...r,...fe(o),reset:()=>({...Y,...r})})))),jsx(A.Provider,{value:e.current,children:t})},F=t=>{let r=useContext(A);if(!r)throw new Error("Missing MapStoreProvider");return useStore(r,t)};function Je({state:t,setFeatures:r}){let e=getType(t);if(e==="MultiPoint")r(getCoords(t).map(o=>({id:nanoid(),...point(o)})));else if(e==="MultiLineString")r(getCoords(t).map(o=>({id:nanoid(),...lineString(o)})));else if(e==="MultiPolygon")r(getCoords(t).map(o=>({id:nanoid(),...polygon(o)})));else if(["Point","LineString","Polygon"].includes(e))r([{id:nanoid(),...feature(t)}]);else if(e==="GeometryCollection"){let o=[];flattenEach(t,n=>o.push({id:nanoid(),...n})),r(o);}}var X=Je;function Ie(t={}){he.Icon.Default.mergeOptions({iconUrl:Oe,iconRetinaUrl:Xe,shadowUrl:Le,...t});}var Ze=Ie;function Ve(t){return t&&getCoord(Be(ve(t)))}var L=Ve;function Re(t){let r=bbox(t);return [[r[1],r[0]],[r[3],r[2]]]}var I=Re;function Ae({state:t,config:{zoomToFeature:r},map:e}){let o=getGeom(t);if(isPoint(o)){if(r){let n=I(circle(t,.25,{steps:4}));e.fitBounds(n,{animate:!1});}else e.panTo(L(t),{animate:!1});return}if(isGeoJSONObject(o))if(r){let n=I(t);e.fitBounds(n,{animate:!1});}else e.panTo(L(pointOnFeature(t)));}var N=Ae;function Ke(){let t=useMap(),[r,e,o,n,p,s,d,c,U,i,f]=F(a=>[a.state,a.$wire,a.config.geomType,a.config.latitudeField,a.config.longitudeField,a.config.drawField,a.config.zoomToFeature,W.selectAll(a),a.updateFeature,a.setFeatures,a.removeFeature]);return useEffect(()=>{r&&(X({state:r,setFeatures:i}),N({state:r,config:{zoomToFeature:d},map:t}));},[]),useUpdateEffect(()=>{if(c?.length){if(["Point","LineString","Polygon"].includes(o)&&c?.length===1){let a=getGeom(last(c));if(o==="Point"){let l=getCoord(a);n&&e.set(n,l[1],!1),p&&e.set(p,l[0],!1);}s&&e.set(s,JSON.stringify(a),!1);}else if(o==="MultiPoint"){let a=getGeom(multiPoint(map(c,l=>getCoord(l))));s&&e.set(s,JSON.stringify(a),!1);}else if(o==="MultiLineString"){let a=getGeom(multiLineString(map(c,l=>getCoords(l))));s&&e.set(s,JSON.stringify(a),!1);}else if(o==="MultiPolygon"){let a=getGeom(multiPolygon(map(c,l=>getCoords(l))));s&&e.set(s,JSON.stringify(a),!1);}else if(o==="GeometryCollection"){let a=getGeom(geometryCollection(map(c,l=>getGeom(l))));s&&e.set(s,JSON.stringify(a),!1);}}else s&&e.set(s,"",!1);},[JSON.stringify(c)]),c?.map((a,l)=>jsx(g,{data:a,eventHandlers:{"pm:update":({layer:m,target:y})=>{featureEach(y.toGeoJSON(),(u,C)=>{U({id:u.id,changes:u});});},"pm:cut":m=>{t.removeLayer(m.layer);let y=get(m,"originalLayer.feature.id");f(y);let u=getType(m.layer.toGeoJSON()),C=getGeom(u===o?m.layer.toGeoJSON():m.originalLayer.toGeoJSON());X({state:C,setFeatures:i});}}},l))}var et=Ke;var w=createControlComponent(function(r){return new Control.FullScreen(r)});function nt(t){let{type:r,popupTemplate:e,...o}=t,n=e?isString(e)?{template:e}:e:{};if(r==="wms"){let p={url:"",format:"image/png",transparent:!0,...o};return jsx(WMSTileLayer,{...p})}if(r==="geojson"){if(o.data){let p={data:isString(o.data)?JSON.parse(o.data):o.data,pmIgnore:!0,onEachFeature:(s,d)=>{e&&d.bindPopup(()=>renderToString(jsx(O,{data:s?.properties,...n})));}};return jsx(g,{...p})}if(o.dataUrl){let p={dataUrl:o.dataUrl,pmIgnore:!0,onEachFeature:(s,d)=>{e&&d.bindPopup(()=>renderToString(jsx(O,{data:s?.properties,...n})));}};return jsx(V,{...p})}}return null}var j=nt;var ft={zoomControl:ZoomControl,layersControl:LayersControl,drawControl:GeomanControls,attributionControl:AttributionControl,scaleControl:ScaleControl,fullscreenControl:w},yt={drawMarker:!0,drawCircle:!1,drawCircleMarker:!1,drawPolyline:!1,drawRectangle:!1,drawPolygon:!1,drawText:!1,editMode:!0,dragMode:!1,cutPolygon:!1,removalMode:!0,rotateMode:!1};function gt(){let[t,r,e,o]=F(i=>[i.config.geomType,i.config.layers,i.config.baseLayers,i.config.controls]),[n,p,s]=F(i=>[i.addFeature,i.removeFeature,i.removeFeatures]),d=i=>{i.target.removeLayer(i.layer),["Point","LineString","Polygon"].includes(t)&&s(),n(i.layer.toGeoJSON());},c=({layer:i,target:f})=>{let a=i.feature.id;a&&p(a);};return useMemo(()=>map(o,(i,f)=>{let a=ft[f];if(!i||i?.enabled==!1||!a)return null;let l={...i},m=null;return f==="layersControl"&&(m=jsxs(Fragment,{children:[e?.map(({selected:y=!1,title:u="None",...C},M)=>jsx(LayersControl.BaseLayer,{name:u,checked:y,children:jsx(TileLayer,{url:"",...C})},M)),r?.map(({selected:y=!1,title:u="None",...C},M)=>jsx(LayersControl.Overlay,{name:u,checked:y,children:jsx(j,{...C})},M))]})),f==="drawControl"&&(l={...l,options:yt},["Point","MultiPoint"].includes(t)?l.options={...l.options,drawMarker:!0,editMode:!0,removalMode:!0}:["LineString","MultiLineString"].includes(t)?l.options={...l.options,drawPolyline:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0}:["Polygon","MultiPolygon"].includes(t)?l.options={...l.options,drawRectangle:!0,drawPolygon:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0}:l.options={...l.options,drawMarker:!0,drawCircle:!0,drawPolyline:!0,drawRectangle:!0,drawPolygon:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0},l.onCreate=d,l.onMapRemove=c),jsx(a,{...l,children:m},f)}).filter(i=>i),[JSON.stringify(o)]).map(i=>i)}var bt=gt;

export { bt as ControlManager, et as FeatureManager, w as FullscreenControl, g as GeoJSON, V as GeoJSONAjax, ye as MapStoreProvider, O as PopupTemplate, W as featuresSelectors, Ze as setDefaultIcon, X as setFeaturesByState, I as toBounds, L as toLatLng, F as useMapStore, N as zoomToFeatureByState };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map