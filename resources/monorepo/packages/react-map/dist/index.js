import { createPathComponent, createElementObject, extendContext, createControlComponent } from '@react-leaflet/core';
import se, { GeoJSON, Control } from 'leaflet';
import { point, lineString, polygon, feature, multiPoint, multiLineString, multiPolygon, geometryCollection } from '@turf/helpers';
import { getType, getCoords, getCoord, getGeom } from '@turf/invariant';
import { flattenEach, featureEach } from '@turf/meta';
import { last, map, get } from 'lodash';
import { createContext, useRef, useContext, useEffect, useMemo, Fragment } from 'react';
import { useMap, LayersControl, TileLayer, WMSTileLayer, ZoomControl, AttributionControl, ScaleControl } from 'react-leaflet';
import { createEntityAdapter, nanoid } from '@reduxjs/toolkit';
import { createStore, useStore } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useUpdateEffect } from 'react-use';
import { circle } from '@turf/circle';
import { pointOnFeature } from '@turf/point-on-feature';
import { isPoint, isGeoJSONObject } from 'geojson-validation';
import ce from 'leaflet/dist/images/marker-icon.png';
import ue from 'leaflet/dist/images/marker-icon-2x.png';
import me from 'leaflet/dist/images/marker-shadow.png';
import ye from '@turf/center';
import ge from '@turf/flip';
import { bbox } from '@turf/bbox';
import { GeomanControls } from 'react-leaflet-geoman-v2';
import 'leaflet.fullscreen';
import 'leaflet.fullscreen/Control.FullScreen.css';

var G=createPathComponent(function({data:r,...e},o){let i=new GeoJSON(r,e);return createElementObject(i,extendContext(o,{overlayContainer:i}))},function(r,e,o){e.data!==o.data&&r.clearLayers().addData(e.data),e.style!==o.style&&(e.style==null?r.resetStyle():r.setStyle(e.style));});var p=createEntityAdapter(),R=p.getSelectors(t=>t),W=p.getInitialState({$wire:null,$watch:null,state:null,config:{}}),K=(t,r)=>({addFeature:e=>t(o=>{p.addOne(o,{id:nanoid(),...e});}),updateFeature:e=>t(o=>{p.updateOne(o,e);}),removeFeature:e=>t(o=>{p.removeOne(o,e);}),setFeatures:e=>t(o=>{p.setAll(o,e);}),removeFeatures:()=>t(e=>{p.removeAll(e);})}),Y=createContext(null),q=({children:t,value:r})=>{let e=useRef();return e.current||(e.current=createStore()(immer((o,i)=>({...W,...r,...K(o),reset:()=>({...W,...r})})))),jsx(Y.Provider,{value:e.current,children:t})},b=t=>{let r=useContext(Y);if(!r)throw new Error("Missing MapStoreProvider");return useStore(r,t)};function ie({state:t,setFeatures:r}){let e=getType(t);if(e==="MultiPoint")r(getCoords(t).map(o=>({id:nanoid(),...point(o)})));else if(e==="MultiLineString")r(getCoords(t).map(o=>({id:nanoid(),...lineString(o)})));else if(e==="MultiPolygon")r(getCoords(t).map(o=>({id:nanoid(),...polygon(o)})));else if(["Point","LineString","Polygon"].includes(e))r([{id:nanoid(),...feature(t)}]);else if(e==="GeometryCollection"){let o=[];flattenEach(t,i=>o.push({id:nanoid(),...i})),r(o);}}var S=ie;function de(t={}){se.Icon.Default.mergeOptions({iconUrl:ce,iconRetinaUrl:ue,shadowUrl:me,...t});}var fe=de;function be(t){return t&&getCoord(ge(ye(t)))}var x=be;function Ce(t){let r=bbox(t);return [[r[1],r[0]],[r[3],r[2]]]}var M=Ce;function Oe({state:t,config:{zoomToFeature:r},map:e}){let o=getGeom(t);if(isPoint(o)){if(r){let i=M(circle(t,.25,{steps:4}));e.fitBounds(i,{animate:!1});}else e.panTo(x(t),{animate:!1});return}if(isGeoJSONObject(o))if(r){let i=M(t);e.fitBounds(i,{animate:!1});}else e.panTo(x(pointOnFeature(t)));}var V=Oe;function Pe(){let t=useMap(),[r,e,o,i,F,s,L,c,v,l,d]=b(n=>[n.state,n.$wire,n.config.geomType,n.config.latitudeField,n.config.longitudeField,n.config.drawField,n.config.zoomToFeature,R.selectAll(n),n.updateFeature,n.setFeatures,n.removeFeature]);return useEffect(()=>{r&&(S({state:r,setFeatures:l}),V({state:r,config:{zoomToFeature:L},map:t}));},[]),useUpdateEffect(()=>{if(c?.length){if(["Point","LineString","Polygon"].includes(o)&&c?.length===1){let n=getGeom(last(c));if(o==="Point"){let a=getCoord(n);i&&e.set(i,a[1],!1),F&&e.set(F,a[0],!1);}s&&e.set(s,JSON.stringify(n),!1);}else if(o==="MultiPoint"){let n=getGeom(multiPoint(map(c,a=>getCoord(a))));s&&e.set(s,JSON.stringify(n),!1);}else if(o==="MultiLineString"){let n=getGeom(multiLineString(map(c,a=>getCoords(a))));s&&e.set(s,JSON.stringify(n),!1);}else if(o==="MultiPolygon"){let n=getGeom(multiPolygon(map(c,a=>getCoords(a))));s&&e.set(s,JSON.stringify(n),!1);}else if(o==="GeometryCollection"){let n=getGeom(geometryCollection(map(c,a=>getGeom(a))));s&&e.set(s,JSON.stringify(n),!1);}}else s&&e.set(s,"",!1);},[JSON.stringify(c)]),c?.map((n,a)=>jsx(G,{data:n,eventHandlers:{"pm:update":({layer:u,target:f})=>{featureEach(f.toGeoJSON(),(m,g)=>{v({id:m.id,changes:m});});},"pm:cut":u=>{t.removeLayer(u.layer);let f=get(u,"originalLayer.feature.id");d(f);let m=getType(u.layer.toGeoJSON()),g=getGeom(m===o?u.layer.toGeoJSON():u.originalLayer.toGeoJSON());S({state:g,setFeatures:l});}}},a))}var Ne=Pe;var I=createControlComponent(function(r){return new Control.FullScreen(r)});function ze(t){let{type:r,...e}=t;if(r==="wms"){let o={url:"",format:"image/png",transparent:!0,...e};return jsx(WMSTileLayer,{...o})}if(r==="geojson"){let o={data:JSON.parse(e.data),pmIgnore:!0};return jsx(G,{...o})}return null}var A=ze;var Ke={zoomControl:ZoomControl,layersControl:LayersControl,drawControl:GeomanControls,attributionControl:AttributionControl,scaleControl:ScaleControl,fullscreenControl:I},qe={drawMarker:!0,drawCircle:!1,drawCircleMarker:!1,drawPolyline:!1,drawRectangle:!1,drawPolygon:!1,drawText:!1,editMode:!0,dragMode:!1,cutPolygon:!1,removalMode:!0,rotateMode:!1};function et(){let[t,r,e,o]=b(l=>[l.config.geomType,l.config.layers,l.config.baseLayers,l.config.controls]),[i,F,s]=b(l=>[l.addFeature,l.removeFeature,l.removeFeatures]),L=l=>{l.target.removeLayer(l.layer),["Point","LineString","Polygon"].includes(t)&&s(),i(l.layer.toGeoJSON());},c=({layer:l,target:d})=>{let n=l.feature.id;n&&F(n);};return useMemo(()=>map(o,(l,d)=>{let n=Ke[d];if(!l||l?.enabled==!1||!n)return null;let a={...l},u=null;return d==="layersControl"&&(u=jsxs(Fragment,{children:[e?.map(({selected:f=!1,title:m="None",...g},h)=>jsx(LayersControl.BaseLayer,{name:m,checked:f,children:jsx(TileLayer,{url:"",...g})},h)),r?.map(({selected:f=!1,title:m="None",...g},h)=>jsx(LayersControl.Overlay,{name:m,checked:f,children:jsx(A,{...g})},h))]})),d==="drawControl"&&(a={...a,options:qe},["Point","MultiPoint"].includes(t)?a.options={...a.options,drawMarker:!0,editMode:!0,removalMode:!0}:["LineString","MultiLineString"].includes(t)?a.options={...a.options,drawPolyline:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0}:["Polygon","MultiPolygon"].includes(t)?a.options={...a.options,drawRectangle:!0,drawPolygon:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0}:a.options={...a.options,drawMarker:!0,drawCircle:!0,drawPolyline:!0,drawRectangle:!0,drawPolygon:!0,editMode:!0,dragMode:!0,cutPolygon:!0,removalMode:!0,rotateMode:!0},a.onCreate=L,a.onMapRemove=c),jsx(n,{...a,children:u},d)}).filter(l=>l),[JSON.stringify(o)]).map(l=>l)}var tt=et;

export { tt as ControlManager, Ne as FeatureManager, I as FullscreenControl, G as GeoJSON, q as MapStoreProvider, R as featuresSelectors, fe as setDefaultIcon, S as setFeaturesByState, M as toBounds, x as toLatLng, b as useMapStore, V as zoomToFeatureByState };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map